{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\"],\"names\":[\"parentHotUpdateCallback\",\"window\",\"chunkId\",\"moreModules\",\"hotAvailableFilesMap\",\"hotRequestedFilesMap\",\"moduleId\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"hotUpdate\",\"hotWaitingFiles\",\"hotChunksLoading\",\"hotUpdateDownloaded\",\"hotAddUpdateChunk\",\"hotCurrentChildModule\",\"hotApplyOnUpdate\",\"hotCurrentHash\",\"hotRequestTimeout\",\"hotCurrentModuleData\",\"hotCurrentParents\",\"hotCurrentParentsTemp\",\"hotCreateRequire\",\"me\",\"installedModules\",\"__webpack_require__\",\"fn\",\"request\",\"hot\",\"active\",\"parents\",\"includes\",\"push\",\"children\",\"console\",\"warn\",\"ObjectFactory\",\"name\",\"configurable\",\"enumerable\",\"get\",\"set\",\"value\",\"defineProperty\",\"e\",\"hotStatus\",\"hotSetStatus\",\"then\",\"finishChunkLoading\",\"err\",\"hotWaitingFilesMap\",\"hotEnsureUpdateChunk\",\"hotStatusHandlers\",\"newStatus\",\"i\",\"length\",\"hotDeferred\",\"hotUpdateNewHash\",\"toModuleId\",\"id\",\"hotCheck\",\"apply\",\"Error\",\"requestTimeout\",\"Promise\",\"resolve\",\"reject\",\"XMLHttpRequest\",\"requestPath\",\"p\",\"open\",\"timeout\",\"send\",\"onreadystatechange\",\"readyState\",\"status\",\"update\",\"JSON\",\"parse\",\"responseText\",\"c\",\"h\",\"promise\",\"head\",\"document\",\"getElementsByTagName\",\"script\",\"createElement\",\"charset\",\"src\",\"appendChild\",\"hotDownloadUpdateChunk\",\"deferred\",\"hotApply\",\"result\",\"outdatedModules\",\"options\",\"cb\",\"j\",\"module\",\"getAffectedStuff\",\"updateModuleId\",\"outdatedDependencies\",\"queue\",\"slice\",\"map\",\"chain\",\"queueItem\",\"pop\",\"_selfAccepted\",\"_selfDeclined\",\"type\",\"_main\",\"parentId\",\"parent\",\"_declinedDependencies\",\"concat\",\"_acceptedDependencies\",\"addAllToSet\",\"a\",\"b\",\"item\",\"appliedUpdate\",\"warnUnexpectedRequire\",\"abortError\",\"doApply\",\"doDispose\",\"chainInfo\",\"join\",\"onDeclined\",\"ignoreDeclined\",\"onUnaccepted\",\"ignoreUnaccepted\",\"onAccepted\",\"onDisposed\",\"idx\",\"outdatedSelfAcceptedModules\",\"errorHandler\",\"keys\",\"forEach\",\"installedChunks\",\"hotDisposeChunk\",\"dependency\",\"moduleOutdatedDependencies\",\"data\",\"disposeHandlers\",\"_disposeHandlers\",\"child\",\"indexOf\",\"splice\",\"modules\",\"error\",\"callbacks\",\"onErrored\",\"dependencyId\",\"ignoreErrored\",\"err2\",\"originalError\",\"exports\",\"l\",\"accept\",\"dep\",\"callback\",\"decline\",\"dispose\",\"addDisposeHandler\",\"removeDisposeHandler\",\"check\",\"addStatusHandler\",\"removeStatusHandler\",\"undefined\",\"hotCreateModule\",\"m\",\"d\",\"getter\",\"o\",\"r\",\"n\",\"__esModule\",\"object\",\"property\",\"s\"],\"mappings\":\"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\",\"sourcesContent\":[\" \\tfunction hotDisposeChunk(chunkId) {\\n \\t\\tdelete installedChunks[chunkId];\\n \\t}\\n \\tvar parentHotUpdateCallback = window[\\\"webpackHotUpdate\\\"];\\n \\twindow[\\\"webpackHotUpdate\\\"] = // eslint-disable-next-line no-unused-vars\\n \\tfunction webpackHotUpdateCallback(chunkId, moreModules) {\\n \\t\\thotAddUpdateChunk(chunkId, moreModules);\\n \\t\\tif (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\\n \\t} ;\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotDownloadUpdateChunk(chunkId) {\\n \\t\\tvar head = document.getElementsByTagName(\\\"head\\\")[0];\\n \\t\\tvar script = document.createElement(\\\"script\\\");\\n \\t\\tscript.charset = \\\"utf-8\\\";\\n \\t\\tscript.src = __webpack_require__.p + \\\"\\\" + chunkId + \\\".\\\" + hotCurrentHash + \\\".hot-update.js\\\";\\n \\t\\t;\\n \\t\\thead.appendChild(script);\\n \\t}\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotDownloadManifest(requestTimeout) {\\n \\t\\trequestTimeout = requestTimeout || 10000;\\n \\t\\treturn new Promise(function(resolve, reject) {\\n \\t\\t\\tif (typeof XMLHttpRequest === \\\"undefined\\\")\\n \\t\\t\\t\\treturn reject(new Error(\\\"No browser support\\\"));\\n \\t\\t\\ttry {\\n \\t\\t\\t\\tvar request = new XMLHttpRequest();\\n \\t\\t\\t\\tvar requestPath = __webpack_require__.p + \\\"\\\" + hotCurrentHash + \\\".hot-update.json\\\";\\n \\t\\t\\t\\trequest.open(\\\"GET\\\", requestPath, true);\\n \\t\\t\\t\\trequest.timeout = requestTimeout;\\n \\t\\t\\t\\trequest.send(null);\\n \\t\\t\\t} catch (err) {\\n \\t\\t\\t\\treturn reject(err);\\n \\t\\t\\t}\\n \\t\\t\\trequest.onreadystatechange = function() {\\n \\t\\t\\t\\tif (request.readyState !== 4) return;\\n \\t\\t\\t\\tif (request.status === 0) {\\n \\t\\t\\t\\t\\t// timeout\\n \\t\\t\\t\\t\\treject(\\n \\t\\t\\t\\t\\t\\tnew Error(\\\"Manifest request to \\\" + requestPath + \\\" timed out.\\\")\\n \\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t} else if (request.status === 404) {\\n \\t\\t\\t\\t\\t// no update available\\n \\t\\t\\t\\t\\tresolve();\\n \\t\\t\\t\\t} else if (request.status !== 200 && request.status !== 304) {\\n \\t\\t\\t\\t\\t// other failure\\n \\t\\t\\t\\t\\treject(new Error(\\\"Manifest request to \\\" + requestPath + \\\" failed.\\\"));\\n \\t\\t\\t\\t} else {\\n \\t\\t\\t\\t\\t// success\\n \\t\\t\\t\\t\\ttry {\\n \\t\\t\\t\\t\\t\\tvar update = JSON.parse(request.responseText);\\n \\t\\t\\t\\t\\t} catch (e) {\\n \\t\\t\\t\\t\\t\\treject(e);\\n \\t\\t\\t\\t\\t\\treturn;\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tresolve(update);\\n \\t\\t\\t\\t}\\n \\t\\t\\t};\\n \\t\\t});\\n \\t}\\n\\n \\tvar hotApplyOnUpdate = true;\\n \\tvar hotCurrentHash = \\\"8aed348f65f4e6e61c64\\\"; // eslint-disable-line no-unused-vars\\n \\tvar hotRequestTimeout = 10000;\\n \\tvar hotCurrentModuleData = {};\\n \\tvar hotCurrentChildModule; // eslint-disable-line no-unused-vars\\n \\tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\\n \\tvar hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotCreateRequire(moduleId) {\\n \\t\\tvar me = installedModules[moduleId];\\n \\t\\tif (!me) return __webpack_require__;\\n \\t\\tvar fn = function(request) {\\n \\t\\t\\tif (me.hot.active) {\\n \\t\\t\\t\\tif (installedModules[request]) {\\n \\t\\t\\t\\t\\tif (!installedModules[request].parents.includes(moduleId))\\n \\t\\t\\t\\t\\t\\tinstalledModules[request].parents.push(moduleId);\\n \\t\\t\\t\\t} else {\\n \\t\\t\\t\\t\\thotCurrentParents = [moduleId];\\n \\t\\t\\t\\t\\thotCurrentChildModule = request;\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (!me.children.includes(request)) me.children.push(request);\\n \\t\\t\\t} else {\\n \\t\\t\\t\\tconsole.warn(\\n \\t\\t\\t\\t\\t\\\"[HMR] unexpected require(\\\" +\\n \\t\\t\\t\\t\\t\\trequest +\\n \\t\\t\\t\\t\\t\\t\\\") from disposed module \\\" +\\n \\t\\t\\t\\t\\t\\tmoduleId\\n \\t\\t\\t\\t);\\n \\t\\t\\t\\thotCurrentParents = [];\\n \\t\\t\\t}\\n \\t\\t\\treturn __webpack_require__(request);\\n \\t\\t};\\n \\t\\tvar ObjectFactory = function ObjectFactory(name) {\\n \\t\\t\\treturn {\\n \\t\\t\\t\\tconfigurable: true,\\n \\t\\t\\t\\tenumerable: true,\\n \\t\\t\\t\\tget: function() {\\n \\t\\t\\t\\t\\treturn __webpack_require__[name];\\n \\t\\t\\t\\t},\\n \\t\\t\\t\\tset: function(value) {\\n \\t\\t\\t\\t\\t__webpack_require__[name] = value;\\n \\t\\t\\t\\t}\\n \\t\\t\\t};\\n \\t\\t};\\n \\t\\tfor (var name in __webpack_require__) {\\n \\t\\t\\tif (\\n \\t\\t\\t\\tObject.prototype.hasOwnProperty.call(__webpack_require__, name) &&\\n \\t\\t\\t\\tname !== \\\"e\\\"\\n \\t\\t\\t) {\\n \\t\\t\\t\\tObject.defineProperty(fn, name, ObjectFactory(name));\\n \\t\\t\\t}\\n \\t\\t}\\n \\t\\tfn.e = function(chunkId) {\\n \\t\\t\\tif (hotStatus === \\\"ready\\\") hotSetStatus(\\\"prepare\\\");\\n \\t\\t\\thotChunksLoading++;\\n \\t\\t\\treturn __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {\\n \\t\\t\\t\\tfinishChunkLoading();\\n \\t\\t\\t\\tthrow err;\\n \\t\\t\\t});\\n\\n \\t\\t\\tfunction finishChunkLoading() {\\n \\t\\t\\t\\thotChunksLoading--;\\n \\t\\t\\t\\tif (hotStatus === \\\"prepare\\\") {\\n \\t\\t\\t\\t\\tif (!hotWaitingFilesMap[chunkId]) {\\n \\t\\t\\t\\t\\t\\thotEnsureUpdateChunk(chunkId);\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tif (hotChunksLoading === 0 && hotWaitingFiles === 0) {\\n \\t\\t\\t\\t\\t\\thotUpdateDownloaded();\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t};\\n \\t\\treturn fn;\\n \\t}\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotCreateModule(moduleId) {\\n \\t\\tvar hot = {\\n \\t\\t\\t// private stuff\\n \\t\\t\\t_acceptedDependencies: {},\\n \\t\\t\\t_declinedDependencies: {},\\n \\t\\t\\t_selfAccepted: false,\\n \\t\\t\\t_selfDeclined: false,\\n \\t\\t\\t_disposeHandlers: [],\\n \\t\\t\\t_main: hotCurrentChildModule !== moduleId,\\n\\n \\t\\t\\t// Module API\\n \\t\\t\\tactive: true,\\n \\t\\t\\taccept: function(dep, callback) {\\n \\t\\t\\t\\tif (typeof dep === \\\"undefined\\\") hot._selfAccepted = true;\\n \\t\\t\\t\\telse if (typeof dep === \\\"function\\\") hot._selfAccepted = dep;\\n \\t\\t\\t\\telse if (typeof dep === \\\"object\\\")\\n \\t\\t\\t\\t\\tfor (var i = 0; i < dep.length; i++)\\n \\t\\t\\t\\t\\t\\thot._acceptedDependencies[dep[i]] = callback || function() {};\\n \\t\\t\\t\\telse hot._acceptedDependencies[dep] = callback || function() {};\\n \\t\\t\\t},\\n \\t\\t\\tdecline: function(dep) {\\n \\t\\t\\t\\tif (typeof dep === \\\"undefined\\\") hot._selfDeclined = true;\\n \\t\\t\\t\\telse if (typeof dep === \\\"object\\\")\\n \\t\\t\\t\\t\\tfor (var i = 0; i < dep.length; i++)\\n \\t\\t\\t\\t\\t\\thot._declinedDependencies[dep[i]] = true;\\n \\t\\t\\t\\telse hot._declinedDependencies[dep] = true;\\n \\t\\t\\t},\\n \\t\\t\\tdispose: function(callback) {\\n \\t\\t\\t\\thot._disposeHandlers.push(callback);\\n \\t\\t\\t},\\n \\t\\t\\taddDisposeHandler: function(callback) {\\n \\t\\t\\t\\thot._disposeHandlers.push(callback);\\n \\t\\t\\t},\\n \\t\\t\\tremoveDisposeHandler: function(callback) {\\n \\t\\t\\t\\tvar idx = hot._disposeHandlers.indexOf(callback);\\n \\t\\t\\t\\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\\n \\t\\t\\t},\\n\\n \\t\\t\\t// Management API\\n \\t\\t\\tcheck: hotCheck,\\n \\t\\t\\tapply: hotApply,\\n \\t\\t\\tstatus: function(l) {\\n \\t\\t\\t\\tif (!l) return hotStatus;\\n \\t\\t\\t\\thotStatusHandlers.push(l);\\n \\t\\t\\t},\\n \\t\\t\\taddStatusHandler: function(l) {\\n \\t\\t\\t\\thotStatusHandlers.push(l);\\n \\t\\t\\t},\\n \\t\\t\\tremoveStatusHandler: function(l) {\\n \\t\\t\\t\\tvar idx = hotStatusHandlers.indexOf(l);\\n \\t\\t\\t\\tif (idx >= 0) hotStatusHandlers.splice(idx, 1);\\n \\t\\t\\t},\\n\\n \\t\\t\\t//inherit from previous dispose call\\n \\t\\t\\tdata: hotCurrentModuleData[moduleId]\\n \\t\\t};\\n \\t\\thotCurrentChildModule = undefined;\\n \\t\\treturn hot;\\n \\t}\\n\\n \\tvar hotStatusHandlers = [];\\n \\tvar hotStatus = \\\"idle\\\";\\n\\n \\tfunction hotSetStatus(newStatus) {\\n \\t\\thotStatus = newStatus;\\n \\t\\tfor (var i = 0; i < hotStatusHandlers.length; i++)\\n \\t\\t\\thotStatusHandlers[i].call(null, newStatus);\\n \\t}\\n\\n \\t// while downloading\\n \\tvar hotWaitingFiles = 0;\\n \\tvar hotChunksLoading = 0;\\n \\tvar hotWaitingFilesMap = {};\\n \\tvar hotRequestedFilesMap = {};\\n \\tvar hotAvailableFilesMap = {};\\n \\tvar hotDeferred;\\n\\n \\t// The update info\\n \\tvar hotUpdate, hotUpdateNewHash;\\n\\n \\tfunction toModuleId(id) {\\n \\t\\tvar isNumber = +id + \\\"\\\" === id;\\n \\t\\treturn isNumber ? +id : id;\\n \\t}\\n\\n \\tfunction hotCheck(apply) {\\n \\t\\tif (hotStatus !== \\\"idle\\\")\\n \\t\\t\\tthrow new Error(\\\"check() is only allowed in idle status\\\");\\n \\t\\thotApplyOnUpdate = apply;\\n \\t\\thotSetStatus(\\\"check\\\");\\n \\t\\treturn hotDownloadManifest(hotRequestTimeout).then(function(update) {\\n \\t\\t\\tif (!update) {\\n \\t\\t\\t\\thotSetStatus(\\\"idle\\\");\\n \\t\\t\\t\\treturn null;\\n \\t\\t\\t}\\n \\t\\t\\thotRequestedFilesMap = {};\\n \\t\\t\\thotWaitingFilesMap = {};\\n \\t\\t\\thotAvailableFilesMap = update.c;\\n \\t\\t\\thotUpdateNewHash = update.h;\\n\\n \\t\\t\\thotSetStatus(\\\"prepare\\\");\\n \\t\\t\\tvar promise = new Promise(function(resolve, reject) {\\n \\t\\t\\t\\thotDeferred = {\\n \\t\\t\\t\\t\\tresolve: resolve,\\n \\t\\t\\t\\t\\treject: reject\\n \\t\\t\\t\\t};\\n \\t\\t\\t});\\n \\t\\t\\thotUpdate = {};\\n \\t\\t\\tvar chunkId = 0;\\n \\t\\t\\t{\\n \\t\\t\\t\\t// eslint-disable-line no-lone-blocks\\n \\t\\t\\t\\t/*globals chunkId */\\n \\t\\t\\t\\thotEnsureUpdateChunk(chunkId);\\n \\t\\t\\t}\\n \\t\\t\\tif (\\n \\t\\t\\t\\thotStatus === \\\"prepare\\\" &&\\n \\t\\t\\t\\thotChunksLoading === 0 &&\\n \\t\\t\\t\\thotWaitingFiles === 0\\n \\t\\t\\t) {\\n \\t\\t\\t\\thotUpdateDownloaded();\\n \\t\\t\\t}\\n \\t\\t\\treturn promise;\\n \\t\\t});\\n \\t}\\n\\n \\t// eslint-disable-next-line no-unused-vars\\n \\tfunction hotAddUpdateChunk(chunkId, moreModules) {\\n \\t\\tif (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\\n \\t\\t\\treturn;\\n \\t\\thotRequestedFilesMap[chunkId] = false;\\n \\t\\tfor (var moduleId in moreModules) {\\n \\t\\t\\tif (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\\n \\t\\t\\t\\thotUpdate[moduleId] = moreModules[moduleId];\\n \\t\\t\\t}\\n \\t\\t}\\n \\t\\tif (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\\n \\t\\t\\thotUpdateDownloaded();\\n \\t\\t}\\n \\t}\\n\\n \\tfunction hotEnsureUpdateChunk(chunkId) {\\n \\t\\tif (!hotAvailableFilesMap[chunkId]) {\\n \\t\\t\\thotWaitingFilesMap[chunkId] = true;\\n \\t\\t} else {\\n \\t\\t\\thotRequestedFilesMap[chunkId] = true;\\n \\t\\t\\thotWaitingFiles++;\\n \\t\\t\\thotDownloadUpdateChunk(chunkId);\\n \\t\\t}\\n \\t}\\n\\n \\tfunction hotUpdateDownloaded() {\\n \\t\\thotSetStatus(\\\"ready\\\");\\n \\t\\tvar deferred = hotDeferred;\\n \\t\\thotDeferred = null;\\n \\t\\tif (!deferred) return;\\n \\t\\tif (hotApplyOnUpdate) {\\n \\t\\t\\t// Wrap deferred object in Promise to mark it as a well-handled Promise to\\n \\t\\t\\t// avoid triggering uncaught exception warning in Chrome.\\n \\t\\t\\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\\n \\t\\t\\tPromise.resolve()\\n \\t\\t\\t\\t.then(function() {\\n \\t\\t\\t\\t\\treturn hotApply(hotApplyOnUpdate);\\n \\t\\t\\t\\t})\\n \\t\\t\\t\\t.then(\\n \\t\\t\\t\\t\\tfunction(result) {\\n \\t\\t\\t\\t\\t\\tdeferred.resolve(result);\\n \\t\\t\\t\\t\\t},\\n \\t\\t\\t\\t\\tfunction(err) {\\n \\t\\t\\t\\t\\t\\tdeferred.reject(err);\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t);\\n \\t\\t} else {\\n \\t\\t\\tvar outdatedModules = [];\\n \\t\\t\\tfor (var id in hotUpdate) {\\n \\t\\t\\t\\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\\n \\t\\t\\t\\t\\toutdatedModules.push(toModuleId(id));\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t\\tdeferred.resolve(outdatedModules);\\n \\t\\t}\\n \\t}\\n\\n \\tfunction hotApply(options) {\\n \\t\\tif (hotStatus !== \\\"ready\\\")\\n \\t\\t\\tthrow new Error(\\\"apply() is only allowed in ready status\\\");\\n \\t\\toptions = options || {};\\n\\n \\t\\tvar cb;\\n \\t\\tvar i;\\n \\t\\tvar j;\\n \\t\\tvar module;\\n \\t\\tvar moduleId;\\n\\n \\t\\tfunction getAffectedStuff(updateModuleId) {\\n \\t\\t\\tvar outdatedModules = [updateModuleId];\\n \\t\\t\\tvar outdatedDependencies = {};\\n\\n \\t\\t\\tvar queue = outdatedModules.slice().map(function(id) {\\n \\t\\t\\t\\treturn {\\n \\t\\t\\t\\t\\tchain: [id],\\n \\t\\t\\t\\t\\tid: id\\n \\t\\t\\t\\t};\\n \\t\\t\\t});\\n \\t\\t\\twhile (queue.length > 0) {\\n \\t\\t\\t\\tvar queueItem = queue.pop();\\n \\t\\t\\t\\tvar moduleId = queueItem.id;\\n \\t\\t\\t\\tvar chain = queueItem.chain;\\n \\t\\t\\t\\tmodule = installedModules[moduleId];\\n \\t\\t\\t\\tif (!module || module.hot._selfAccepted) continue;\\n \\t\\t\\t\\tif (module.hot._selfDeclined) {\\n \\t\\t\\t\\t\\treturn {\\n \\t\\t\\t\\t\\t\\ttype: \\\"self-declined\\\",\\n \\t\\t\\t\\t\\t\\tchain: chain,\\n \\t\\t\\t\\t\\t\\tmoduleId: moduleId\\n \\t\\t\\t\\t\\t};\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (module.hot._main) {\\n \\t\\t\\t\\t\\treturn {\\n \\t\\t\\t\\t\\t\\ttype: \\\"unaccepted\\\",\\n \\t\\t\\t\\t\\t\\tchain: chain,\\n \\t\\t\\t\\t\\t\\tmoduleId: moduleId\\n \\t\\t\\t\\t\\t};\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tfor (var i = 0; i < module.parents.length; i++) {\\n \\t\\t\\t\\t\\tvar parentId = module.parents[i];\\n \\t\\t\\t\\t\\tvar parent = installedModules[parentId];\\n \\t\\t\\t\\t\\tif (!parent) continue;\\n \\t\\t\\t\\t\\tif (parent.hot._declinedDependencies[moduleId]) {\\n \\t\\t\\t\\t\\t\\treturn {\\n \\t\\t\\t\\t\\t\\t\\ttype: \\\"declined\\\",\\n \\t\\t\\t\\t\\t\\t\\tchain: chain.concat([parentId]),\\n \\t\\t\\t\\t\\t\\t\\tmoduleId: moduleId,\\n \\t\\t\\t\\t\\t\\t\\tparentId: parentId\\n \\t\\t\\t\\t\\t\\t};\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tif (outdatedModules.includes(parentId)) continue;\\n \\t\\t\\t\\t\\tif (parent.hot._acceptedDependencies[moduleId]) {\\n \\t\\t\\t\\t\\t\\tif (!outdatedDependencies[parentId])\\n \\t\\t\\t\\t\\t\\t\\toutdatedDependencies[parentId] = [];\\n \\t\\t\\t\\t\\t\\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\\n \\t\\t\\t\\t\\t\\tcontinue;\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tdelete outdatedDependencies[parentId];\\n \\t\\t\\t\\t\\toutdatedModules.push(parentId);\\n \\t\\t\\t\\t\\tqueue.push({\\n \\t\\t\\t\\t\\t\\tchain: chain.concat([parentId]),\\n \\t\\t\\t\\t\\t\\tid: parentId\\n \\t\\t\\t\\t\\t});\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n\\n \\t\\t\\treturn {\\n \\t\\t\\t\\ttype: \\\"accepted\\\",\\n \\t\\t\\t\\tmoduleId: updateModuleId,\\n \\t\\t\\t\\toutdatedModules: outdatedModules,\\n \\t\\t\\t\\toutdatedDependencies: outdatedDependencies\\n \\t\\t\\t};\\n \\t\\t}\\n\\n \\t\\tfunction addAllToSet(a, b) {\\n \\t\\t\\tfor (var i = 0; i < b.length; i++) {\\n \\t\\t\\t\\tvar item = b[i];\\n \\t\\t\\t\\tif (!a.includes(item)) a.push(item);\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// at begin all updates modules are outdated\\n \\t\\t// the \\\"outdated\\\" status can propagate to parents if they don't accept the children\\n \\t\\tvar outdatedDependencies = {};\\n \\t\\tvar outdatedModules = [];\\n \\t\\tvar appliedUpdate = {};\\n\\n \\t\\tvar warnUnexpectedRequire = function warnUnexpectedRequire() {\\n \\t\\t\\tconsole.warn(\\n \\t\\t\\t\\t\\\"[HMR] unexpected require(\\\" + result.moduleId + \\\") to disposed module\\\"\\n \\t\\t\\t);\\n \\t\\t};\\n\\n \\t\\tfor (var id in hotUpdate) {\\n \\t\\t\\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\\n \\t\\t\\t\\tmoduleId = toModuleId(id);\\n \\t\\t\\t\\tvar result;\\n \\t\\t\\t\\tif (hotUpdate[id]) {\\n \\t\\t\\t\\t\\tresult = getAffectedStuff(moduleId);\\n \\t\\t\\t\\t} else {\\n \\t\\t\\t\\t\\tresult = {\\n \\t\\t\\t\\t\\t\\ttype: \\\"disposed\\\",\\n \\t\\t\\t\\t\\t\\tmoduleId: id\\n \\t\\t\\t\\t\\t};\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tvar abortError = false;\\n \\t\\t\\t\\tvar doApply = false;\\n \\t\\t\\t\\tvar doDispose = false;\\n \\t\\t\\t\\tvar chainInfo = \\\"\\\";\\n \\t\\t\\t\\tif (result.chain) {\\n \\t\\t\\t\\t\\tchainInfo = \\\"\\\\nUpdate propagation: \\\" + result.chain.join(\\\" -> \\\");\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tswitch (result.type) {\\n \\t\\t\\t\\t\\tcase \\\"self-declined\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onDeclined) options.onDeclined(result);\\n \\t\\t\\t\\t\\t\\tif (!options.ignoreDeclined)\\n \\t\\t\\t\\t\\t\\t\\tabortError = new Error(\\n \\t\\t\\t\\t\\t\\t\\t\\t\\\"Aborted because of self decline: \\\" +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tresult.moduleId +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tchainInfo\\n \\t\\t\\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tcase \\\"declined\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onDeclined) options.onDeclined(result);\\n \\t\\t\\t\\t\\t\\tif (!options.ignoreDeclined)\\n \\t\\t\\t\\t\\t\\t\\tabortError = new Error(\\n \\t\\t\\t\\t\\t\\t\\t\\t\\\"Aborted because of declined dependency: \\\" +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tresult.moduleId +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\t\\\" in \\\" +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tresult.parentId +\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tchainInfo\\n \\t\\t\\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tcase \\\"unaccepted\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onUnaccepted) options.onUnaccepted(result);\\n \\t\\t\\t\\t\\t\\tif (!options.ignoreUnaccepted)\\n \\t\\t\\t\\t\\t\\t\\tabortError = new Error(\\n \\t\\t\\t\\t\\t\\t\\t\\t\\\"Aborted because \\\" + moduleId + \\\" is not accepted\\\" + chainInfo\\n \\t\\t\\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tcase \\\"accepted\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onAccepted) options.onAccepted(result);\\n \\t\\t\\t\\t\\t\\tdoApply = true;\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tcase \\\"disposed\\\":\\n \\t\\t\\t\\t\\t\\tif (options.onDisposed) options.onDisposed(result);\\n \\t\\t\\t\\t\\t\\tdoDispose = true;\\n \\t\\t\\t\\t\\t\\tbreak;\\n \\t\\t\\t\\t\\tdefault:\\n \\t\\t\\t\\t\\t\\tthrow new Error(\\\"Unexception type \\\" + result.type);\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (abortError) {\\n \\t\\t\\t\\t\\thotSetStatus(\\\"abort\\\");\\n \\t\\t\\t\\t\\treturn Promise.reject(abortError);\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (doApply) {\\n \\t\\t\\t\\t\\tappliedUpdate[moduleId] = hotUpdate[moduleId];\\n \\t\\t\\t\\t\\taddAllToSet(outdatedModules, result.outdatedModules);\\n \\t\\t\\t\\t\\tfor (moduleId in result.outdatedDependencies) {\\n \\t\\t\\t\\t\\t\\tif (\\n \\t\\t\\t\\t\\t\\t\\tObject.prototype.hasOwnProperty.call(\\n \\t\\t\\t\\t\\t\\t\\t\\tresult.outdatedDependencies,\\n \\t\\t\\t\\t\\t\\t\\t\\tmoduleId\\n \\t\\t\\t\\t\\t\\t\\t)\\n \\t\\t\\t\\t\\t\\t) {\\n \\t\\t\\t\\t\\t\\t\\tif (!outdatedDependencies[moduleId])\\n \\t\\t\\t\\t\\t\\t\\t\\toutdatedDependencies[moduleId] = [];\\n \\t\\t\\t\\t\\t\\t\\taddAllToSet(\\n \\t\\t\\t\\t\\t\\t\\t\\toutdatedDependencies[moduleId],\\n \\t\\t\\t\\t\\t\\t\\t\\tresult.outdatedDependencies[moduleId]\\n \\t\\t\\t\\t\\t\\t\\t);\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t\\tif (doDispose) {\\n \\t\\t\\t\\t\\taddAllToSet(outdatedModules, [result.moduleId]);\\n \\t\\t\\t\\t\\tappliedUpdate[moduleId] = warnUnexpectedRequire;\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// Store self accepted outdated modules to require them later by the module system\\n \\t\\tvar outdatedSelfAcceptedModules = [];\\n \\t\\tfor (i = 0; i < outdatedModules.length; i++) {\\n \\t\\t\\tmoduleId = outdatedModules[i];\\n \\t\\t\\tif (\\n \\t\\t\\t\\tinstalledModules[moduleId] &&\\n \\t\\t\\t\\tinstalledModules[moduleId].hot._selfAccepted\\n \\t\\t\\t)\\n \\t\\t\\t\\toutdatedSelfAcceptedModules.push({\\n \\t\\t\\t\\t\\tmodule: moduleId,\\n \\t\\t\\t\\t\\terrorHandler: installedModules[moduleId].hot._selfAccepted\\n \\t\\t\\t\\t});\\n \\t\\t}\\n\\n \\t\\t// Now in \\\"dispose\\\" phase\\n \\t\\thotSetStatus(\\\"dispose\\\");\\n \\t\\tObject.keys(hotAvailableFilesMap).forEach(function(chunkId) {\\n \\t\\t\\tif (hotAvailableFilesMap[chunkId] === false) {\\n \\t\\t\\t\\thotDisposeChunk(chunkId);\\n \\t\\t\\t}\\n \\t\\t});\\n\\n \\t\\tvar idx;\\n \\t\\tvar queue = outdatedModules.slice();\\n \\t\\twhile (queue.length > 0) {\\n \\t\\t\\tmoduleId = queue.pop();\\n \\t\\t\\tmodule = installedModules[moduleId];\\n \\t\\t\\tif (!module) continue;\\n\\n \\t\\t\\tvar data = {};\\n\\n \\t\\t\\t// Call dispose handlers\\n \\t\\t\\tvar disposeHandlers = module.hot._disposeHandlers;\\n \\t\\t\\tfor (j = 0; j < disposeHandlers.length; j++) {\\n \\t\\t\\t\\tcb = disposeHandlers[j];\\n \\t\\t\\t\\tcb(data);\\n \\t\\t\\t}\\n \\t\\t\\thotCurrentModuleData[moduleId] = data;\\n\\n \\t\\t\\t// disable module (this disables requires from this module)\\n \\t\\t\\tmodule.hot.active = false;\\n\\n \\t\\t\\t// remove module from cache\\n \\t\\t\\tdelete installedModules[moduleId];\\n\\n \\t\\t\\t// when disposing there is no need to call dispose handler\\n \\t\\t\\tdelete outdatedDependencies[moduleId];\\n\\n \\t\\t\\t// remove \\\"parents\\\" references from all children\\n \\t\\t\\tfor (j = 0; j < module.children.length; j++) {\\n \\t\\t\\t\\tvar child = installedModules[module.children[j]];\\n \\t\\t\\t\\tif (!child) continue;\\n \\t\\t\\t\\tidx = child.parents.indexOf(moduleId);\\n \\t\\t\\t\\tif (idx >= 0) {\\n \\t\\t\\t\\t\\tchild.parents.splice(idx, 1);\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// remove outdated dependency from module children\\n \\t\\tvar dependency;\\n \\t\\tvar moduleOutdatedDependencies;\\n \\t\\tfor (moduleId in outdatedDependencies) {\\n \\t\\t\\tif (\\n \\t\\t\\t\\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\\n \\t\\t\\t) {\\n \\t\\t\\t\\tmodule = installedModules[moduleId];\\n \\t\\t\\t\\tif (module) {\\n \\t\\t\\t\\t\\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\\n \\t\\t\\t\\t\\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\\n \\t\\t\\t\\t\\t\\tdependency = moduleOutdatedDependencies[j];\\n \\t\\t\\t\\t\\t\\tidx = module.children.indexOf(dependency);\\n \\t\\t\\t\\t\\t\\tif (idx >= 0) module.children.splice(idx, 1);\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// Not in \\\"apply\\\" phase\\n \\t\\thotSetStatus(\\\"apply\\\");\\n\\n \\t\\thotCurrentHash = hotUpdateNewHash;\\n\\n \\t\\t// insert new code\\n \\t\\tfor (moduleId in appliedUpdate) {\\n \\t\\t\\tif (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\\n \\t\\t\\t\\tmodules[moduleId] = appliedUpdate[moduleId];\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// call accept handlers\\n \\t\\tvar error = null;\\n \\t\\tfor (moduleId in outdatedDependencies) {\\n \\t\\t\\tif (\\n \\t\\t\\t\\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\\n \\t\\t\\t) {\\n \\t\\t\\t\\tmodule = installedModules[moduleId];\\n \\t\\t\\t\\tif (module) {\\n \\t\\t\\t\\t\\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\\n \\t\\t\\t\\t\\tvar callbacks = [];\\n \\t\\t\\t\\t\\tfor (i = 0; i < moduleOutdatedDependencies.length; i++) {\\n \\t\\t\\t\\t\\t\\tdependency = moduleOutdatedDependencies[i];\\n \\t\\t\\t\\t\\t\\tcb = module.hot._acceptedDependencies[dependency];\\n \\t\\t\\t\\t\\t\\tif (cb) {\\n \\t\\t\\t\\t\\t\\t\\tif (callbacks.includes(cb)) continue;\\n \\t\\t\\t\\t\\t\\t\\tcallbacks.push(cb);\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tfor (i = 0; i < callbacks.length; i++) {\\n \\t\\t\\t\\t\\t\\tcb = callbacks[i];\\n \\t\\t\\t\\t\\t\\ttry {\\n \\t\\t\\t\\t\\t\\t\\tcb(moduleOutdatedDependencies);\\n \\t\\t\\t\\t\\t\\t} catch (err) {\\n \\t\\t\\t\\t\\t\\t\\tif (options.onErrored) {\\n \\t\\t\\t\\t\\t\\t\\t\\toptions.onErrored({\\n \\t\\t\\t\\t\\t\\t\\t\\t\\ttype: \\\"accept-errored\\\",\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tmoduleId: moduleId,\\n \\t\\t\\t\\t\\t\\t\\t\\t\\tdependencyId: moduleOutdatedDependencies[i],\\n \\t\\t\\t\\t\\t\\t\\t\\t\\terror: err\\n \\t\\t\\t\\t\\t\\t\\t\\t});\\n \\t\\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t\\t\\tif (!options.ignoreErrored) {\\n \\t\\t\\t\\t\\t\\t\\t\\tif (!error) error = err;\\n \\t\\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// Load self accepted modules\\n \\t\\tfor (i = 0; i < outdatedSelfAcceptedModules.length; i++) {\\n \\t\\t\\tvar item = outdatedSelfAcceptedModules[i];\\n \\t\\t\\tmoduleId = item.module;\\n \\t\\t\\thotCurrentParents = [moduleId];\\n \\t\\t\\ttry {\\n \\t\\t\\t\\t__webpack_require__(moduleId);\\n \\t\\t\\t} catch (err) {\\n \\t\\t\\t\\tif (typeof item.errorHandler === \\\"function\\\") {\\n \\t\\t\\t\\t\\ttry {\\n \\t\\t\\t\\t\\t\\titem.errorHandler(err);\\n \\t\\t\\t\\t\\t} catch (err2) {\\n \\t\\t\\t\\t\\t\\tif (options.onErrored) {\\n \\t\\t\\t\\t\\t\\t\\toptions.onErrored({\\n \\t\\t\\t\\t\\t\\t\\t\\ttype: \\\"self-accept-error-handler-errored\\\",\\n \\t\\t\\t\\t\\t\\t\\t\\tmoduleId: moduleId,\\n \\t\\t\\t\\t\\t\\t\\t\\terror: err2,\\n \\t\\t\\t\\t\\t\\t\\t\\toriginalError: err\\n \\t\\t\\t\\t\\t\\t\\t});\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t\\tif (!options.ignoreErrored) {\\n \\t\\t\\t\\t\\t\\t\\tif (!error) error = err2;\\n \\t\\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\t\\tif (!error) error = err;\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t} else {\\n \\t\\t\\t\\t\\tif (options.onErrored) {\\n \\t\\t\\t\\t\\t\\toptions.onErrored({\\n \\t\\t\\t\\t\\t\\t\\ttype: \\\"self-accept-errored\\\",\\n \\t\\t\\t\\t\\t\\t\\tmoduleId: moduleId,\\n \\t\\t\\t\\t\\t\\t\\terror: err\\n \\t\\t\\t\\t\\t\\t});\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t\\tif (!options.ignoreErrored) {\\n \\t\\t\\t\\t\\t\\tif (!error) error = err;\\n \\t\\t\\t\\t\\t}\\n \\t\\t\\t\\t}\\n \\t\\t\\t}\\n \\t\\t}\\n\\n \\t\\t// handle errors in accept handlers and self accepted module load\\n \\t\\tif (error) {\\n \\t\\t\\thotSetStatus(\\\"fail\\\");\\n \\t\\t\\treturn Promise.reject(error);\\n \\t\\t}\\n\\n \\t\\thotSetStatus(\\\"idle\\\");\\n \\t\\treturn new Promise(function(resolve) {\\n \\t\\t\\tresolve(outdatedModules);\\n \\t\\t});\\n \\t}\\n\\n \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {},\\n \\t\\t\\thot: hotCreateModule(moduleId),\\n \\t\\t\\tparents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\\n \\t\\t\\tchildren: []\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, {\\n \\t\\t\\t\\tconfigurable: false,\\n \\t\\t\\t\\tenumerable: true,\\n \\t\\t\\t\\tget: getter\\n \\t\\t\\t});\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"build/\\\";\\n\\n \\t// __webpack_hash__\\n \\t__webpack_require__.h = function() { return hotCurrentHash; };\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn hotCreateRequire(23)(__webpack_require__.s = 23);\\n\"]}","code":"!function(Q){var B=window.webpackHotUpdate;window.webpackHotUpdate=function(Q,F){!function(Q,B){if(!L[Q]||!G[Q])return;for(var F in G[Q]=!1,B)Object.prototype.hasOwnProperty.call(B,F)&&(d[F]=B[F]);0==--x&&0===a&&r()}(Q,F),B&&B(Q,F)};var F,U=!0,I=\"8aed348f65f4e6e61c64\",n=1e4,s={},l=[],t=[];function g(Q){var B=X[Q];if(!B)return W;var U=function(U){return B.hot.active?(X[U]?X[U].parents.includes(Q)||X[U].parents.push(Q):(l=[Q],F=U),B.children.includes(U)||B.children.push(U)):(console.warn(\"[HMR] unexpected require(\"+U+\") from disposed module \"+Q),l=[]),W(U)},I=function(Q){return{configurable:!0,enumerable:!0,get:function(){return W[Q]},set:function(B){W[Q]=B}}};for(var n in W)Object.prototype.hasOwnProperty.call(W,n)&&\"e\"!==n&&Object.defineProperty(U,n,I(n));return U.e=function(Q){return\"ready\"===C&&i(\"prepare\"),a++,W.e(Q).then(B,function(Q){throw B(),Q});function B(){a--,\"prepare\"===C&&(V[Q]||u(Q),0===a&&0===x&&r())}},U}var c=[],C=\"idle\";function i(Q){C=Q;for(var B=0;B<c.length;B++)c[B].call(null,Q)}var e,d,b,x=0,a=0,V={},G={},L={};function o(Q){return+Q+\"\"===Q?+Q:Q}function Z(Q){if(\"idle\"!==C)throw new Error(\"check() is only allowed in idle status\");return U=Q,i(\"check\"),(B=n,B=B||1e4,new Promise(function(Q,F){if(\"undefined\"==typeof XMLHttpRequest)return F(new Error(\"No browser support\"));try{var U=new XMLHttpRequest,n=W.p+\"\"+I+\".hot-update.json\";U.open(\"GET\",n,!0),U.timeout=B,U.send(null)}catch(Q){return F(Q)}U.onreadystatechange=function(){if(4===U.readyState)if(0===U.status)F(new Error(\"Manifest request to \"+n+\" timed out.\"));else if(404===U.status)Q();else if(200!==U.status&&304!==U.status)F(new Error(\"Manifest request to \"+n+\" failed.\"));else{try{var B=JSON.parse(U.responseText)}catch(Q){return void F(Q)}Q(B)}}})).then(function(Q){if(!Q)return i(\"idle\"),null;G={},V={},L=Q.c,b=Q.h,i(\"prepare\");var B=new Promise(function(Q,B){e={resolve:Q,reject:B}});d={};return u(0),\"prepare\"===C&&0===a&&0===x&&r(),B});var B}function u(Q){L[Q]?(G[Q]=!0,x++,function(Q){var B=document.getElementsByTagName(\"head\")[0],F=document.createElement(\"script\");F.charset=\"utf-8\",F.src=W.p+\"\"+Q+\".\"+I+\".hot-update.js\",B.appendChild(F)}(Q)):V[Q]=!0}function r(){i(\"ready\");var Q=e;if(e=null,Q)if(U)Promise.resolve().then(function(){return E(U)}).then(function(B){Q.resolve(B)},function(B){Q.reject(B)});else{var B=[];for(var F in d)Object.prototype.hasOwnProperty.call(d,F)&&B.push(o(F));Q.resolve(B)}}function E(B){if(\"ready\"!==C)throw new Error(\"apply() is only allowed in ready status\");var F,U,n,t,g;function c(Q){for(var B=[Q],F={},U=B.slice().map(function(Q){return{chain:[Q],id:Q}});U.length>0;){var I=U.pop(),n=I.id,s=I.chain;if((t=X[n])&&!t.hot._selfAccepted){if(t.hot._selfDeclined)return{type:\"self-declined\",chain:s,moduleId:n};if(t.hot._main)return{type:\"unaccepted\",chain:s,moduleId:n};for(var l=0;l<t.parents.length;l++){var g=t.parents[l],c=X[g];if(c){if(c.hot._declinedDependencies[n])return{type:\"declined\",chain:s.concat([g]),moduleId:n,parentId:g};B.includes(g)||(c.hot._acceptedDependencies[n]?(F[g]||(F[g]=[]),e(F[g],[n])):(delete F[g],B.push(g),U.push({chain:s.concat([g]),id:g})))}}}}return{type:\"accepted\",moduleId:Q,outdatedModules:B,outdatedDependencies:F}}function e(Q,B){for(var F=0;F<B.length;F++){var U=B[F];Q.includes(U)||Q.push(U)}}B=B||{};var x={},a=[],V={},G=function(){console.warn(\"[HMR] unexpected require(\"+u.moduleId+\") to disposed module\")};for(var Z in d)if(Object.prototype.hasOwnProperty.call(d,Z)){var u;g=o(Z);var r=!1,E=!1,R=!1,A=\"\";switch((u=d[Z]?c(g):{type:\"disposed\",moduleId:Z}).chain&&(A=\"\\nUpdate propagation: \"+u.chain.join(\" -> \")),u.type){case\"self-declined\":B.onDeclined&&B.onDeclined(u),B.ignoreDeclined||(r=new Error(\"Aborted because of self decline: \"+u.moduleId+A));break;case\"declined\":B.onDeclined&&B.onDeclined(u),B.ignoreDeclined||(r=new Error(\"Aborted because of declined dependency: \"+u.moduleId+\" in \"+u.parentId+A));break;case\"unaccepted\":B.onUnaccepted&&B.onUnaccepted(u),B.ignoreUnaccepted||(r=new Error(\"Aborted because \"+g+\" is not accepted\"+A));break;case\"accepted\":B.onAccepted&&B.onAccepted(u),E=!0;break;case\"disposed\":B.onDisposed&&B.onDisposed(u),R=!0;break;default:throw new Error(\"Unexception type \"+u.type)}if(r)return i(\"abort\"),Promise.reject(r);if(E)for(g in V[g]=d[g],e(a,u.outdatedModules),u.outdatedDependencies)Object.prototype.hasOwnProperty.call(u.outdatedDependencies,g)&&(x[g]||(x[g]=[]),e(x[g],u.outdatedDependencies[g]));R&&(e(a,[u.moduleId]),V[g]=G)}var m,y=[];for(U=0;U<a.length;U++)g=a[U],X[g]&&X[g].hot._selfAccepted&&y.push({module:g,errorHandler:X[g].hot._selfAccepted});i(\"dispose\"),Object.keys(L).forEach(function(Q){!1===L[Q]&&function(Q){delete installedChunks[Q]}(Q)});for(var N,S,h=a.slice();h.length>0;)if(g=h.pop(),t=X[g]){var J={},p=t.hot._disposeHandlers;for(n=0;n<p.length;n++)(F=p[n])(J);for(s[g]=J,t.hot.active=!1,delete X[g],delete x[g],n=0;n<t.children.length;n++){var Y=X[t.children[n]];Y&&((m=Y.parents.indexOf(g))>=0&&Y.parents.splice(m,1))}}for(g in x)if(Object.prototype.hasOwnProperty.call(x,g)&&(t=X[g]))for(S=x[g],n=0;n<S.length;n++)N=S[n],(m=t.children.indexOf(N))>=0&&t.children.splice(m,1);for(g in i(\"apply\"),I=b,V)Object.prototype.hasOwnProperty.call(V,g)&&(Q[g]=V[g]);var H=null;for(g in x)if(Object.prototype.hasOwnProperty.call(x,g)&&(t=X[g])){S=x[g];var v=[];for(U=0;U<S.length;U++)if(N=S[U],F=t.hot._acceptedDependencies[N]){if(v.includes(F))continue;v.push(F)}for(U=0;U<v.length;U++){F=v[U];try{F(S)}catch(Q){B.onErrored&&B.onErrored({type:\"accept-errored\",moduleId:g,dependencyId:S[U],error:Q}),B.ignoreErrored||H||(H=Q)}}}for(U=0;U<y.length;U++){var T=y[U];g=T.module,l=[g];try{W(g)}catch(Q){if(\"function\"==typeof T.errorHandler)try{T.errorHandler(Q)}catch(F){B.onErrored&&B.onErrored({type:\"self-accept-error-handler-errored\",moduleId:g,error:F,originalError:Q}),B.ignoreErrored||H||(H=F),H||(H=Q)}else B.onErrored&&B.onErrored({type:\"self-accept-errored\",moduleId:g,error:Q}),B.ignoreErrored||H||(H=Q)}}return H?(i(\"fail\"),Promise.reject(H)):(i(\"idle\"),new Promise(function(Q){Q(a)}))}var X={};function W(B){if(X[B])return X[B].exports;var U=X[B]={i:B,l:!1,exports:{},hot:function(Q){var B={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:F!==Q,active:!0,accept:function(Q,F){if(void 0===Q)B._selfAccepted=!0;else if(\"function\"==typeof Q)B._selfAccepted=Q;else if(\"object\"==typeof Q)for(var U=0;U<Q.length;U++)B._acceptedDependencies[Q[U]]=F||function(){};else B._acceptedDependencies[Q]=F||function(){}},decline:function(Q){if(void 0===Q)B._selfDeclined=!0;else if(\"object\"==typeof Q)for(var F=0;F<Q.length;F++)B._declinedDependencies[Q[F]]=!0;else B._declinedDependencies[Q]=!0},dispose:function(Q){B._disposeHandlers.push(Q)},addDisposeHandler:function(Q){B._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var F=B._disposeHandlers.indexOf(Q);F>=0&&B._disposeHandlers.splice(F,1)},check:Z,apply:E,status:function(Q){if(!Q)return C;c.push(Q)},addStatusHandler:function(Q){c.push(Q)},removeStatusHandler:function(Q){var B=c.indexOf(Q);B>=0&&c.splice(B,1)},data:s[Q]};return F=void 0,B}(B),parents:(t=l,l=[],t),children:[]};return Q[B].call(U.exports,U,U.exports,g(B)),U.l=!0,U.exports}W.m=Q,W.c=X,W.d=function(Q,B,F){W.o(Q,B)||Object.defineProperty(Q,B,{configurable:!1,enumerable:!0,get:F})},W.r=function(Q){Object.defineProperty(Q,\"__esModule\",{value:!0})},W.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return W.d(B,\"a\",B),B},W.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},W.p=\"build/\",W.h=function(){return I},g(23)(W.s=23)}([function(module,exports){eval('var logLevel = \"info\";\\n\\nfunction dummy() {}\\n\\nfunction shouldLog(level) {\\n\\tvar shouldLog = logLevel === \"info\" && level === \"info\" || [\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\" || [\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\";\\n\\treturn shouldLog;\\n}\\n\\nfunction logGroup(logFn) {\\n\\treturn function (level, msg) {\\n\\t\\tif (shouldLog(level)) {\\n\\t\\t\\tlogFn(msg);\\n\\t\\t}\\n\\t};\\n}\\n\\nmodule.exports = function (level, msg) {\\n\\tif (shouldLog(level)) {\\n\\t\\tif (level === \"info\") {\\n\\t\\t\\tconsole.log(msg);\\n\\t\\t} else if (level === \"warning\") {\\n\\t\\t\\tconsole.warn(msg);\\n\\t\\t} else if (level === \"error\") {\\n\\t\\t\\tconsole.error(msg);\\n\\t\\t}\\n\\t}\\n};\\n\\nvar group = console.group || dummy;\\nvar groupCollapsed = console.groupCollapsed || dummy;\\nvar groupEnd = console.groupEnd || dummy;\\n\\nmodule.exports.group = logGroup(group);\\n\\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\\n\\nmodule.exports.groupEnd = logGroup(groupEnd);\\n\\nmodule.exports.setLogLevel = function (level) {\\n\\tlogLevel = level;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanM/MWFmZCJdLCJuYW1lcyI6WyJsb2dMZXZlbCIsImR1bW15Iiwic2hvdWxkTG9nIiwibGV2ZWwiLCJpbmRleE9mIiwibG9nR3JvdXAiLCJsb2dGbiIsIm1zZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb25zb2xlIiwibG9nIiwid2FybiIsImVycm9yIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwic2V0TG9nTGV2ZWwiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFdBQVcsTUFBZjs7QUFFQSxTQUFTQyxLQUFULEdBQWlCLENBQUU7O0FBRW5CLFNBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO0FBQ3pCLEtBQUlELFlBQ0ZGLGFBQWEsTUFBYixJQUF1QkcsVUFBVSxNQUFsQyxJQUNDLENBQUMsTUFBRCxFQUFTLFNBQVQsRUFBb0JDLE9BQXBCLENBQTRCSixRQUE1QixLQUF5QyxDQUF6QyxJQUE4Q0csVUFBVSxTQUR6RCxJQUVDLENBQUMsTUFBRCxFQUFTLFNBQVQsRUFBb0IsT0FBcEIsRUFBNkJDLE9BQTdCLENBQXFDSixRQUFyQyxLQUFrRCxDQUFsRCxJQUF1REcsVUFBVSxPQUhuRTtBQUlBLFFBQU9ELFNBQVA7QUFDQTs7QUFFRCxTQUFTRyxRQUFULENBQWtCQyxLQUFsQixFQUF5QjtBQUN4QixRQUFPLFVBQVNILEtBQVQsRUFBZ0JJLEdBQWhCLEVBQXFCO0FBQzNCLE1BQUlMLFVBQVVDLEtBQVYsQ0FBSixFQUFzQjtBQUNyQkcsU0FBTUMsR0FBTjtBQUNBO0FBQ0QsRUFKRDtBQUtBOztBQUVEQyxPQUFPQyxPQUFQLEdBQWlCLFVBQVNOLEtBQVQsRUFBZ0JJLEdBQWhCLEVBQXFCO0FBQ3JDLEtBQUlMLFVBQVVDLEtBQVYsQ0FBSixFQUFzQjtBQUNyQixNQUFJQSxVQUFVLE1BQWQsRUFBc0I7QUFDckJPLFdBQVFDLEdBQVIsQ0FBWUosR0FBWjtBQUNBLEdBRkQsTUFFTyxJQUFJSixVQUFVLFNBQWQsRUFBeUI7QUFDL0JPLFdBQVFFLElBQVIsQ0FBYUwsR0FBYjtBQUNBLEdBRk0sTUFFQSxJQUFJSixVQUFVLE9BQWQsRUFBdUI7QUFDN0JPLFdBQVFHLEtBQVIsQ0FBY04sR0FBZDtBQUNBO0FBQ0Q7QUFDRCxDQVZEOztBQVlBLElBQUlPLFFBQVFKLFFBQVFJLEtBQVIsSUFBaUJiLEtBQTdCO0FBQ0EsSUFBSWMsaUJBQWlCTCxRQUFRSyxjQUFSLElBQTBCZCxLQUEvQztBQUNBLElBQUllLFdBQVdOLFFBQVFNLFFBQVIsSUFBb0JmLEtBQW5DOztBQUVBTyxPQUFPQyxPQUFQLENBQWVLLEtBQWYsR0FBdUJULFNBQVNTLEtBQVQsQ0FBdkI7O0FBRUFOLE9BQU9DLE9BQVAsQ0FBZU0sY0FBZixHQUFnQ1YsU0FBU1UsY0FBVCxDQUFoQzs7QUFFQVAsT0FBT0MsT0FBUCxDQUFlTyxRQUFmLEdBQTBCWCxTQUFTVyxRQUFULENBQTFCOztBQUVBUixPQUFPQyxPQUFQLENBQWVRLFdBQWYsR0FBNkIsVUFBU2QsS0FBVCxFQUFnQjtBQUM1Q0gsWUFBV0csS0FBWDtBQUNBLENBRkQiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBsb2dMZXZlbCA9IFwiaW5mb1wiO1xyXG5cclxuZnVuY3Rpb24gZHVtbXkoKSB7fVxyXG5cclxuZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsKSB7XHJcblx0dmFyIHNob3VsZExvZyA9XHJcblx0XHQobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIikgfHxcclxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIikgfHxcclxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIik7XHJcblx0cmV0dXJuIHNob3VsZExvZztcclxufVxyXG5cclxuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xyXG5cdFx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcclxuXHRcdFx0bG9nRm4obXNnKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcclxuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xyXG5cdFx0aWYgKGxldmVsID09PSBcImluZm9cIikge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhtc2cpO1xyXG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKG1zZyk7XHJcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcImVycm9yXCIpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XHJcbnZhciBncm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgfHwgZHVtbXk7XHJcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gbG9nR3JvdXAoZ3JvdXBDb2xsYXBzZWQpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7XHJcblx0bG9nTGV2ZWwgPSBsZXZlbDtcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///0\\n')},function(module,exports,__webpack_require__){eval(\"var EventEmitter = __webpack_require__(/*! events */ 5);\\nmodule.exports = new EventEmitter();//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzP2E2YmQiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLGVBQWUsbUJBQUFDLENBQVEsZUFBUixDQUFuQjtBQUNBQyxPQUFPQyxPQUFQLEdBQWlCLElBQUlILFlBQUosRUFBakIiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1\\n\")},function(module,exports){eval('var g;\\n\\n// This works in non-strict mode\\ng = function () {\\n\\treturn this;\\n}();\\n\\ntry {\\n\\t// This works if eval is allowed (see CSP)\\n\\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\\n} catch (e) {\\n\\t// This works if the window reference is available\\n\\tif (typeof window === \"object\") g = window;\\n}\\n\\n// g can still be undefined, but nothing to do about it...\\n// We return undefined, instead of nothing here, so it\\'s\\n// easier to handle this case. if(!global) { ...}\\n\\nmodule.exports = g;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxDQUFKOztBQUVBO0FBQ0FBLElBQUssWUFBVztBQUNmLFFBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsS0FBSUEsS0FBS0MsU0FBUyxhQUFULEdBQUwsSUFBa0MsQ0FBQyxHQUFHQyxJQUFKLEVBQVUsTUFBVixDQUF0QztBQUNBLENBSEQsQ0FHRSxPQUFPQyxDQUFQLEVBQVU7QUFDWDtBQUNBLEtBQUksT0FBT0MsTUFBUCxLQUFrQixRQUF0QixFQUFnQ0osSUFBSUksTUFBSjtBQUNoQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJOLENBQWpCIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///2\\n')},function(module,exports,__webpack_require__){eval('/*\\r\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\r\\n\\tAuthor Tobias Koppers @sokra\\r\\n*/\\nmodule.exports = function (updatedModules, renewedModules) {\\n\\tvar unacceptedModules = updatedModules.filter(function (moduleId) {\\n\\t\\treturn renewedModules && renewedModules.indexOf(moduleId) < 0;\\n\\t});\\n\\tvar log = __webpack_require__(/*! ./log */ 0);\\n\\n\\tif (unacceptedModules.length > 0) {\\n\\t\\tlog(\"warning\", \"[HMR] The following modules couldn\\'t be hot updated: (They would need a full reload!)\");\\n\\t\\tunacceptedModules.forEach(function (moduleId) {\\n\\t\\t\\tlog(\"warning\", \"[HMR]  - \" + moduleId);\\n\\t\\t});\\n\\t}\\n\\n\\tif (!renewedModules || renewedModules.length === 0) {\\n\\t\\tlog(\"info\", \"[HMR] Nothing hot updated.\");\\n\\t} else {\\n\\t\\tlog(\"info\", \"[HMR] Updated modules:\");\\n\\t\\trenewedModules.forEach(function (moduleId) {\\n\\t\\t\\tif (typeof moduleId === \"string\" && moduleId.indexOf(\"!\") !== -1) {\\n\\t\\t\\t\\tvar parts = moduleId.split(\"!\");\\n\\t\\t\\t\\tlog.groupCollapsed(\"info\", \"[HMR]  - \" + parts.pop());\\n\\t\\t\\t\\tlog(\"info\", \"[HMR]  - \" + moduleId);\\n\\t\\t\\t\\tlog.groupEnd(\"info\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlog(\"info\", \"[HMR]  - \" + moduleId);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tvar numberIds = renewedModules.every(function (moduleId) {\\n\\t\\t\\treturn typeof moduleId === \"number\";\\n\\t\\t});\\n\\t\\tif (numberIds) log(\"info\", \"[HMR] Consider using the NamedModulesPlugin for module names.\");\\n\\t}\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzP2U1MmUiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVwZGF0ZWRNb2R1bGVzIiwicmVuZXdlZE1vZHVsZXMiLCJ1bmFjY2VwdGVkTW9kdWxlcyIsImZpbHRlciIsIm1vZHVsZUlkIiwiaW5kZXhPZiIsImxvZyIsInJlcXVpcmUiLCJsZW5ndGgiLCJmb3JFYWNoIiwicGFydHMiLCJzcGxpdCIsImdyb3VwQ29sbGFwc2VkIiwicG9wIiwiZ3JvdXBFbmQiLCJudW1iZXJJZHMiLCJldmVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFJQUEsT0FBT0MsT0FBUCxHQUFpQixVQUFTQyxjQUFULEVBQXlCQyxjQUF6QixFQUF5QztBQUN6RCxLQUFJQyxvQkFBb0JGLGVBQWVHLE1BQWYsQ0FBc0IsVUFBU0MsUUFBVCxFQUFtQjtBQUNoRSxTQUFPSCxrQkFBa0JBLGVBQWVJLE9BQWYsQ0FBdUJELFFBQXZCLElBQW1DLENBQTVEO0FBQ0EsRUFGdUIsQ0FBeEI7QUFHQSxLQUFJRSxNQUFNLG1CQUFBQyxDQUFRLGNBQVIsQ0FBVjs7QUFFQSxLQUFJTCxrQkFBa0JNLE1BQWxCLEdBQTJCLENBQS9CLEVBQWtDO0FBQ2pDRixNQUNDLFNBREQsRUFFQyx1RkFGRDtBQUlBSixvQkFBa0JPLE9BQWxCLENBQTBCLFVBQVNMLFFBQVQsRUFBbUI7QUFDNUNFLE9BQUksU0FBSixFQUFlLGNBQWNGLFFBQTdCO0FBQ0EsR0FGRDtBQUdBOztBQUVELEtBQUksQ0FBQ0gsY0FBRCxJQUFtQkEsZUFBZU8sTUFBZixLQUEwQixDQUFqRCxFQUFvRDtBQUNuREYsTUFBSSxNQUFKLEVBQVksNEJBQVo7QUFDQSxFQUZELE1BRU87QUFDTkEsTUFBSSxNQUFKLEVBQVksd0JBQVo7QUFDQUwsaUJBQWVRLE9BQWYsQ0FBdUIsVUFBU0wsUUFBVCxFQUFtQjtBQUN6QyxPQUFJLE9BQU9BLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0NBLFNBQVNDLE9BQVQsQ0FBaUIsR0FBakIsTUFBMEIsQ0FBQyxDQUEvRCxFQUFrRTtBQUNqRSxRQUFJSyxRQUFRTixTQUFTTyxLQUFULENBQWUsR0FBZixDQUFaO0FBQ0FMLFFBQUlNLGNBQUosQ0FBbUIsTUFBbkIsRUFBMkIsY0FBY0YsTUFBTUcsR0FBTixFQUF6QztBQUNBUCxRQUFJLE1BQUosRUFBWSxjQUFjRixRQUExQjtBQUNBRSxRQUFJUSxRQUFKLENBQWEsTUFBYjtBQUNBLElBTEQsTUFLTztBQUNOUixRQUFJLE1BQUosRUFBWSxjQUFjRixRQUExQjtBQUNBO0FBQ0QsR0FURDtBQVVBLE1BQUlXLFlBQVlkLGVBQWVlLEtBQWYsQ0FBcUIsVUFBU1osUUFBVCxFQUFtQjtBQUN2RCxVQUFPLE9BQU9BLFFBQVAsS0FBb0IsUUFBM0I7QUFDQSxHQUZlLENBQWhCO0FBR0EsTUFBSVcsU0FBSixFQUNDVCxJQUNDLE1BREQsRUFFQywrREFGRDtBQUlEO0FBQ0QsQ0F2Q0QiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXBkYXRlZE1vZHVsZXMsIHJlbmV3ZWRNb2R1bGVzKSB7XHJcblx0dmFyIHVuYWNjZXB0ZWRNb2R1bGVzID0gdXBkYXRlZE1vZHVsZXMuZmlsdGVyKGZ1bmN0aW9uKG1vZHVsZUlkKSB7XHJcblx0XHRyZXR1cm4gcmVuZXdlZE1vZHVsZXMgJiYgcmVuZXdlZE1vZHVsZXMuaW5kZXhPZihtb2R1bGVJZCkgPCAwO1xyXG5cdH0pO1xyXG5cdHZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XHJcblxyXG5cdGlmICh1bmFjY2VwdGVkTW9kdWxlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRsb2coXHJcblx0XHRcdFwid2FybmluZ1wiLFxyXG5cdFx0XHRcIltITVJdIFRoZSBmb2xsb3dpbmcgbW9kdWxlcyBjb3VsZG4ndCBiZSBob3QgdXBkYXRlZDogKFRoZXkgd291bGQgbmVlZCBhIGZ1bGwgcmVsb2FkISlcIlxyXG5cdFx0KTtcclxuXHRcdHVuYWNjZXB0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcclxuXHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIXJlbmV3ZWRNb2R1bGVzIHx8IHJlbmV3ZWRNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdIE5vdGhpbmcgaG90IHVwZGF0ZWQuXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gVXBkYXRlZCBtb2R1bGVzOlwiKTtcclxuXHRcdHJlbmV3ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtb2R1bGVJZCA9PT0gXCJzdHJpbmdcIiAmJiBtb2R1bGVJZC5pbmRleE9mKFwiIVwiKSAhPT0gLTEpIHtcclxuXHRcdFx0XHR2YXIgcGFydHMgPSBtb2R1bGVJZC5zcGxpdChcIiFcIik7XHJcblx0XHRcdFx0bG9nLmdyb3VwQ29sbGFwc2VkKFwiaW5mb1wiLCBcIltITVJdICAtIFwiICsgcGFydHMucG9wKCkpO1xyXG5cdFx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcclxuXHRcdFx0XHRsb2cuZ3JvdXBFbmQoXCJpbmZvXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR2YXIgbnVtYmVySWRzID0gcmVuZXdlZE1vZHVsZXMuZXZlcnkoZnVuY3Rpb24obW9kdWxlSWQpIHtcclxuXHRcdFx0cmV0dXJuIHR5cGVvZiBtb2R1bGVJZCA9PT0gXCJudW1iZXJcIjtcclxuXHRcdH0pO1xyXG5cdFx0aWYgKG51bWJlcklkcylcclxuXHRcdFx0bG9nKFxyXG5cdFx0XHRcdFwiaW5mb1wiLFxyXG5cdFx0XHRcdFwiW0hNUl0gQ29uc2lkZXIgdXNpbmcgdGhlIE5hbWVkTW9kdWxlc1BsdWdpbiBmb3IgbW9kdWxlIG5hbWVzLlwiXHJcblx0XHRcdCk7XHJcblx0fVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///3\\n')},function(module,exports,__webpack_require__){eval('/*\\r\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\r\\n\\tAuthor Tobias Koppers @sokra\\r\\n*/\\n/*globals window __webpack_hash__ */\\nif (true) {\\n\\tvar lastHash;\\n\\tvar upToDate = function upToDate() {\\n\\t\\treturn lastHash.indexOf(__webpack_require__.h()) >= 0;\\n\\t};\\n\\tvar log = __webpack_require__(/*! ./log */ 0);\\n\\tvar check = function check() {\\n\\t\\tmodule.hot.check(true).then(function (updatedModules) {\\n\\t\\t\\tif (!updatedModules) {\\n\\t\\t\\t\\tlog(\"warning\", \"[HMR] Cannot find update. Need to do a full reload!\");\\n\\t\\t\\t\\tlog(\"warning\", \"[HMR] (Probably because of restarting the webpack-dev-server)\");\\n\\t\\t\\t\\twindow.location.reload();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!upToDate()) {\\n\\t\\t\\t\\tcheck();\\n\\t\\t\\t}\\n\\n\\t\\t\\t__webpack_require__(/*! ./log-apply-result */ 3)(updatedModules, updatedModules);\\n\\n\\t\\t\\tif (upToDate()) {\\n\\t\\t\\t\\tlog(\"info\", \"[HMR] App is up to date.\");\\n\\t\\t\\t}\\n\\t\\t}).catch(function (err) {\\n\\t\\t\\tvar status = module.hot.status();\\n\\t\\t\\tif ([\"abort\", \"fail\"].indexOf(status) >= 0) {\\n\\t\\t\\t\\tlog(\"warning\", \"[HMR] Cannot apply update. Need to do a full reload!\");\\n\\t\\t\\t\\tlog(\"warning\", \"[HMR] \" + err.stack || err.message);\\n\\t\\t\\t\\twindow.location.reload();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlog(\"warning\", \"[HMR] Update failed: \" + err.stack || err.message);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\tvar hotEmitter = __webpack_require__(/*! ./emitter */ 1);\\n\\thotEmitter.on(\"webpackHotUpdate\", function (currentHash) {\\n\\t\\tlastHash = currentHash;\\n\\t\\tif (!upToDate() && module.hot.status() === \"idle\") {\\n\\t\\t\\tlog(\"info\", \"[HMR] Checking for updates on the server...\");\\n\\t\\t\\tcheck();\\n\\t\\t}\\n\\t});\\n\\tlog(\"info\", \"[HMR] Waiting for update signal from WDS...\");\\n} else {}//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9kZXYtc2VydmVyLmpzPzY4OTUiXSwibmFtZXMiOlsibGFzdEhhc2giLCJ1cFRvRGF0ZSIsImluZGV4T2YiLCJsb2ciLCJyZXF1aXJlIiwiY2hlY2siLCJtb2R1bGUiLCJob3QiLCJ0aGVuIiwidXBkYXRlZE1vZHVsZXMiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInJlbG9hZCIsImNhdGNoIiwiZXJyIiwic3RhdHVzIiwic3RhY2siLCJtZXNzYWdlIiwiaG90RW1pdHRlciIsIm9uIiwiY3VycmVudEhhc2giXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBSUE7QUFDQSxJQUFJLElBQUosRUFBZ0I7QUFDZixLQUFJQSxRQUFKO0FBQ0EsS0FBSUMsV0FBVyxTQUFTQSxRQUFULEdBQW9CO0FBQ2xDLFNBQU9ELFNBQVNFLE9BQVQsQ0FBaUIsdUJBQWpCLEtBQXNDLENBQTdDO0FBQ0EsRUFGRDtBQUdBLEtBQUlDLE1BQU0sbUJBQUFDLENBQVEsY0FBUixDQUFWO0FBQ0EsS0FBSUMsUUFBUSxTQUFTQSxLQUFULEdBQWlCO0FBQzVCQyxTQUFPQyxHQUFQLENBQ0VGLEtBREYsQ0FDUSxJQURSLEVBRUVHLElBRkYsQ0FFTyxVQUFTQyxjQUFULEVBQXlCO0FBQzlCLE9BQUksQ0FBQ0EsY0FBTCxFQUFxQjtBQUNwQk4sUUFBSSxTQUFKLEVBQWUscURBQWY7QUFDQUEsUUFDQyxTQURELEVBRUMsK0RBRkQ7QUFJQU8sV0FBT0MsUUFBUCxDQUFnQkMsTUFBaEI7QUFDQTtBQUNBOztBQUVELE9BQUksQ0FBQ1gsVUFBTCxFQUFpQjtBQUNoQkk7QUFDQTs7QUFFREQsR0FBQSxtQkFBQUEsQ0FBUSwyQkFBUixFQUE4QkssY0FBOUIsRUFBOENBLGNBQTlDOztBQUVBLE9BQUlSLFVBQUosRUFBZ0I7QUFDZkUsUUFBSSxNQUFKLEVBQVksMEJBQVo7QUFDQTtBQUNELEdBdEJGLEVBdUJFVSxLQXZCRixDQXVCUSxVQUFTQyxHQUFULEVBQWM7QUFDcEIsT0FBSUMsU0FBU1QsT0FBT0MsR0FBUCxDQUFXUSxNQUFYLEVBQWI7QUFDQSxPQUFJLENBQUMsT0FBRCxFQUFVLE1BQVYsRUFBa0JiLE9BQWxCLENBQTBCYSxNQUExQixLQUFxQyxDQUF6QyxFQUE0QztBQUMzQ1osUUFDQyxTQURELEVBRUMsc0RBRkQ7QUFJQUEsUUFBSSxTQUFKLEVBQWUsV0FBV1csSUFBSUUsS0FBZixJQUF3QkYsSUFBSUcsT0FBM0M7QUFDQVAsV0FBT0MsUUFBUCxDQUFnQkMsTUFBaEI7QUFDQSxJQVBELE1BT087QUFDTlQsUUFBSSxTQUFKLEVBQWUsMEJBQTBCVyxJQUFJRSxLQUE5QixJQUF1Q0YsSUFBSUcsT0FBMUQ7QUFDQTtBQUNELEdBbkNGO0FBb0NBLEVBckNEO0FBc0NBLEtBQUlDLGFBQWEsbUJBQUFkLENBQVEsa0JBQVIsQ0FBakI7QUFDQWMsWUFBV0MsRUFBWCxDQUFjLGtCQUFkLEVBQWtDLFVBQVNDLFdBQVQsRUFBc0I7QUFDdkRwQixhQUFXb0IsV0FBWDtBQUNBLE1BQUksQ0FBQ25CLFVBQUQsSUFBZUssT0FBT0MsR0FBUCxDQUFXUSxNQUFYLE9BQXdCLE1BQTNDLEVBQW1EO0FBQ2xEWixPQUFJLE1BQUosRUFBWSw2Q0FBWjtBQUNBRTtBQUNBO0FBQ0QsRUFORDtBQU9BRixLQUFJLE1BQUosRUFBWSw2Q0FBWjtBQUNBLENBckRELE1BcURPIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vKmdsb2JhbHMgd2luZG93IF9fd2VicGFja19oYXNoX18gKi9cclxuaWYgKG1vZHVsZS5ob3QpIHtcclxuXHR2YXIgbGFzdEhhc2g7XHJcblx0dmFyIHVwVG9EYXRlID0gZnVuY3Rpb24gdXBUb0RhdGUoKSB7XHJcblx0XHRyZXR1cm4gbGFzdEhhc2guaW5kZXhPZihfX3dlYnBhY2tfaGFzaF9fKSA+PSAwO1xyXG5cdH07XHJcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcclxuXHR2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjaygpIHtcclxuXHRcdG1vZHVsZS5ob3RcclxuXHRcdFx0LmNoZWNrKHRydWUpXHJcblx0XHRcdC50aGVuKGZ1bmN0aW9uKHVwZGF0ZWRNb2R1bGVzKSB7XHJcblx0XHRcdFx0aWYgKCF1cGRhdGVkTW9kdWxlcykge1xyXG5cdFx0XHRcdFx0bG9nKFwid2FybmluZ1wiLCBcIltITVJdIENhbm5vdCBmaW5kIHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcclxuXHRcdFx0XHRcdGxvZyhcclxuXHRcdFx0XHRcdFx0XCJ3YXJuaW5nXCIsXHJcblx0XHRcdFx0XHRcdFwiW0hNUl0gKFByb2JhYmx5IGJlY2F1c2Ugb2YgcmVzdGFydGluZyB0aGUgd2VicGFjay1kZXYtc2VydmVyKVwiXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCF1cFRvRGF0ZSgpKSB7XHJcblx0XHRcdFx0XHRjaGVjaygpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmVxdWlyZShcIi4vbG9nLWFwcGx5LXJlc3VsdFwiKSh1cGRhdGVkTW9kdWxlcywgdXBkYXRlZE1vZHVsZXMpO1xyXG5cclxuXHRcdFx0XHRpZiAodXBUb0RhdGUoKSkge1xyXG5cdFx0XHRcdFx0bG9nKFwiaW5mb1wiLCBcIltITVJdIEFwcCBpcyB1cCB0byBkYXRlLlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHR2YXIgc3RhdHVzID0gbW9kdWxlLmhvdC5zdGF0dXMoKTtcclxuXHRcdFx0XHRpZiAoW1wiYWJvcnRcIiwgXCJmYWlsXCJdLmluZGV4T2Yoc3RhdHVzKSA+PSAwKSB7XHJcblx0XHRcdFx0XHRsb2coXHJcblx0XHRcdFx0XHRcdFwid2FybmluZ1wiLFxyXG5cdFx0XHRcdFx0XHRcIltITVJdIENhbm5vdCBhcHBseSB1cGRhdGUuIE5lZWQgdG8gZG8gYSBmdWxsIHJlbG9hZCFcIlxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBcIiArIGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XHJcblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBVcGRhdGUgZmFpbGVkOiBcIiArIGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9O1xyXG5cdHZhciBob3RFbWl0dGVyID0gcmVxdWlyZShcIi4vZW1pdHRlclwiKTtcclxuXHRob3RFbWl0dGVyLm9uKFwid2VicGFja0hvdFVwZGF0ZVwiLCBmdW5jdGlvbihjdXJyZW50SGFzaCkge1xyXG5cdFx0bGFzdEhhc2ggPSBjdXJyZW50SGFzaDtcclxuXHRcdGlmICghdXBUb0RhdGUoKSAmJiBtb2R1bGUuaG90LnN0YXR1cygpID09PSBcImlkbGVcIikge1xyXG5cdFx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gQ2hlY2tpbmcgZm9yIHVwZGF0ZXMgb24gdGhlIHNlcnZlci4uLlwiKTtcclxuXHRcdFx0Y2hlY2soKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gV2FpdGluZyBmb3IgdXBkYXRlIHNpZ25hbCBmcm9tIFdEUy4uLlwiKTtcclxufSBlbHNlIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///4\\n')},function(module,exports){eval(\"throw new Error(\\\"Module build failed: Error: ENOENT: no such file or directory, open 'D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\events\\\\\\\\events.js'\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI1LmpzIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///5\\n\")},function(module,exports,__webpack_require__){eval(\"var map = {\\n\\t\\\"./log\\\": 0\\n};\\n\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\tvar module = __webpack_require__(id);\\n\\treturn module;\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error('Cannot find module \\\"' + req + '\\\".');\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = 6;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdCBzeW5jIG5vbnJlY3Vyc2l2ZSBeXFwuXFwvbG9nJD8xYzNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFwID0ge1xuXHRcIi4vbG9nXCI6IDBcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG5cdHJldHVybiBtb2R1bGU7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIHsgLy8gY2hlY2sgZm9yIG51bWJlciBvciBzdHJpbmdcblx0XHR2YXIgZSA9IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgbW9kdWxlIFwiJyArIHJlcSArICdcIi4nKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gaWQ7XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gNjsiXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///6\\n\")},function(module,exports){eval(\"throw new Error(\\\"Module build failed: Error: ENOENT: no such file or directory, open 'D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\html-entities\\\\\\\\package.json'\\\\n    at Object.fs.openSync (fs.js:652:18)\\\\n    at Object.fs.readFileSync (fs.js:553:33)\\\\n    at ConfigChainBuilder.addConfig (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:146:32)\\\\n    at ConfigChainBuilder.findConfigs (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:102:30)\\\\n    at buildConfigChain (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:61:13)\\\\n    at OptionManager.init (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\option-manager.js:354:58)\\\\n    at File.initOptions (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\index.js:212:65)\\\\n    at new File (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\index.js:135:24)\\\\n    at Pipeline.transform (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\pipeline.js:46:16)\\\\n    at transpile (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-loader\\\\\\\\lib\\\\\\\\index.js:50:20)\\\\n    at Object.module.exports (D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\babel-loader\\\\\\\\lib\\\\\\\\index.js:175:20)\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI3LmpzIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///7\\n\")},function(module,exports){eval(\"throw new Error(\\\"Module build failed: Error: ENOENT: no such file or directory, open 'D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\ansi-html\\\\\\\\index.js'\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI4LmpzIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///8\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\n// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)\\n// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).\\n\\nvar ansiHTML = __webpack_require__(/*! ansi-html */ 8);\\nvar Entities = __webpack_require__(/*! html-entities */ 7).AllHtmlEntities;\\n\\nvar entities = new Entities();\\n\\nvar colors = {\\n  reset: ['transparent', 'transparent'],\\n  black: '181818',\\n  red: 'E36049',\\n  green: 'B3CB74',\\n  yellow: 'FFD080',\\n  blue: '7CAFC2',\\n  magenta: '7FACCA',\\n  cyan: 'C3C2EF',\\n  lightgrey: 'EBE7E3',\\n  darkgrey: '6D7891'\\n};\\nansiHTML.setColors(colors);\\n\\nfunction createOverlayIframe(onIframeLoad) {\\n  var iframe = document.createElement('iframe');\\n  iframe.id = 'webpack-dev-server-client-overlay';\\n  iframe.src = 'about:blank';\\n  iframe.style.position = 'fixed';\\n  iframe.style.left = 0;\\n  iframe.style.top = 0;\\n  iframe.style.right = 0;\\n  iframe.style.bottom = 0;\\n  iframe.style.width = '100vw';\\n  iframe.style.height = '100vh';\\n  iframe.style.border = 'none';\\n  iframe.style.zIndex = 9999999999;\\n  iframe.onload = onIframeLoad;\\n  return iframe;\\n}\\n\\nfunction addOverlayDivTo(iframe) {\\n  var div = iframe.contentDocument.createElement('div');\\n  div.id = 'webpack-dev-server-client-overlay-div';\\n  div.style.position = 'fixed';\\n  div.style.boxSizing = 'border-box';\\n  div.style.left = 0;\\n  div.style.top = 0;\\n  div.style.right = 0;\\n  div.style.bottom = 0;\\n  div.style.width = '100vw';\\n  div.style.height = '100vh';\\n  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\\n  div.style.color = '#E8E8E8';\\n  div.style.fontFamily = 'Menlo, Consolas, monospace';\\n  div.style.fontSize = 'large';\\n  div.style.padding = '2rem';\\n  div.style.lineHeight = '1.2';\\n  div.style.whiteSpace = 'pre-wrap';\\n  div.style.overflow = 'auto';\\n  iframe.contentDocument.body.appendChild(div);\\n  return div;\\n}\\n\\nvar overlayIframe = null;\\nvar overlayDiv = null;\\nvar lastOnOverlayDivReady = null;\\n\\nfunction ensureOverlayDivExists(onOverlayDivReady) {\\n  if (overlayDiv) {\\n    // Everything is ready, call the callback right away.\\n    onOverlayDivReady(overlayDiv);\\n    return;\\n  }\\n\\n  // Creating an iframe may be asynchronous so we'll schedule the callback.\\n  // In case of multiple calls, last callback wins.\\n  lastOnOverlayDivReady = onOverlayDivReady;\\n\\n  if (overlayIframe) {\\n    // We're already creating it.\\n    return;\\n  }\\n\\n  // Create iframe and, when it is ready, a div inside it.\\n  overlayIframe = createOverlayIframe(function () {\\n    overlayDiv = addOverlayDivTo(overlayIframe);\\n    // Now we can talk!\\n    lastOnOverlayDivReady(overlayDiv);\\n  });\\n\\n  // Zalgo alert: onIframeLoad() will be called either synchronously\\n  // or asynchronously depending on the browser.\\n  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.\\n  document.body.appendChild(overlayIframe);\\n}\\n\\nfunction showMessageOverlay(message) {\\n  ensureOverlayDivExists(function (div) {\\n    // Make it look similar to our terminal.\\n    div.innerHTML = '<span style=\\\"color: #' + colors.red + '\\\">Failed to compile.</span><br><br>' + ansiHTML(entities.encode(message));\\n  });\\n}\\n\\nfunction destroyErrorOverlay() {\\n  if (!overlayDiv) {\\n    // It is not there in the first place.\\n    return;\\n  }\\n\\n  // Clean up and reset internal state.\\n  document.body.removeChild(overlayIframe);\\n  overlayDiv = null;\\n  overlayIframe = null;\\n  lastOnOverlayDivReady = null;\\n}\\n\\n// Successful compilation.\\nexports.clear = function handleSuccess() {\\n  destroyErrorOverlay();\\n};\\n\\n// Compilation with errors (e.g. syntax error or missing modules).\\nexports.showMessage = function handleMessage(messages) {\\n  showMessageOverlay(messages[0]);\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanM/MmFjNiJdLCJuYW1lcyI6WyJhbnNpSFRNTCIsInJlcXVpcmUiLCJFbnRpdGllcyIsIkFsbEh0bWxFbnRpdGllcyIsImVudGl0aWVzIiwiY29sb3JzIiwicmVzZXQiLCJibGFjayIsInJlZCIsImdyZWVuIiwieWVsbG93IiwiYmx1ZSIsIm1hZ2VudGEiLCJjeWFuIiwibGlnaHRncmV5IiwiZGFya2dyZXkiLCJzZXRDb2xvcnMiLCJjcmVhdGVPdmVybGF5SWZyYW1lIiwib25JZnJhbWVMb2FkIiwiaWZyYW1lIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJzcmMiLCJzdHlsZSIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwid2lkdGgiLCJoZWlnaHQiLCJib3JkZXIiLCJ6SW5kZXgiLCJvbmxvYWQiLCJhZGRPdmVybGF5RGl2VG8iLCJkaXYiLCJjb250ZW50RG9jdW1lbnQiLCJib3hTaXppbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsInBhZGRpbmciLCJsaW5lSGVpZ2h0Iiwid2hpdGVTcGFjZSIsIm92ZXJmbG93IiwiYm9keSIsImFwcGVuZENoaWxkIiwib3ZlcmxheUlmcmFtZSIsIm92ZXJsYXlEaXYiLCJsYXN0T25PdmVybGF5RGl2UmVhZHkiLCJlbnN1cmVPdmVybGF5RGl2RXhpc3RzIiwib25PdmVybGF5RGl2UmVhZHkiLCJzaG93TWVzc2FnZU92ZXJsYXkiLCJtZXNzYWdlIiwiaW5uZXJIVE1MIiwiZW5jb2RlIiwiZGVzdHJveUVycm9yT3ZlcmxheSIsInJlbW92ZUNoaWxkIiwiZXhwb3J0cyIsImNsZWFyIiwiaGFuZGxlU3VjY2VzcyIsInNob3dNZXNzYWdlIiwiaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2VzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztB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QUZEIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBlcnJvciBvdmVybGF5IGlzIGluc3BpcmVkIChhbmQgbW9zdGx5IGNvcGllZCkgZnJvbSBDcmVhdGUgUmVhY3QgQXBwIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcClcbi8vIFRoZXksIGluIHR1cm4sIGdvdCBpbnNwaXJlZCBieSB3ZWJwYWNrLWhvdC1taWRkbGV3YXJlIChodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmUpLlxuXG52YXIgYW5zaUhUTUwgPSByZXF1aXJlKCdhbnNpLWh0bWwnKTtcbnZhciBFbnRpdGllcyA9IHJlcXVpcmUoJ2h0bWwtZW50aXRpZXMnKS5BbGxIdG1sRW50aXRpZXM7XG5cbnZhciBlbnRpdGllcyA9IG5ldyBFbnRpdGllcygpO1xuXG52YXIgY29sb3JzID0ge1xuICByZXNldDogWyd0cmFuc3BhcmVudCcsICd0cmFuc3BhcmVudCddLFxuICBibGFjazogJzE4MTgxOCcsXG4gIHJlZDogJ0UzNjA0OScsXG4gIGdyZWVuOiAnQjNDQjc0JyxcbiAgeWVsbG93OiAnRkZEMDgwJyxcbiAgYmx1ZTogJzdDQUZDMicsXG4gIG1hZ2VudGE6ICc3RkFDQ0EnLFxuICBjeWFuOiAnQzNDMkVGJyxcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcbiAgZGFya2dyZXk6ICc2RDc4OTEnXG59O1xuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXlJZnJhbWUob25JZnJhbWVMb2FkKSB7XG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgaWZyYW1lLmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheSc7XG4gIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBpZnJhbWUuc3R5bGUubGVmdCA9IDA7XG4gIGlmcmFtZS5zdHlsZS50b3AgPSAwO1xuICBpZnJhbWUuc3R5bGUucmlnaHQgPSAwO1xuICBpZnJhbWUuc3R5bGUuYm90dG9tID0gMDtcbiAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGlmcmFtZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gIGlmcmFtZS5zdHlsZS56SW5kZXggPSA5OTk5OTk5OTk5O1xuICBpZnJhbWUub25sb2FkID0gb25JZnJhbWVMb2FkO1xuICByZXR1cm4gaWZyYW1lO1xufVxuXG5mdW5jdGlvbiBhZGRPdmVybGF5RGl2VG8oaWZyYW1lKSB7XG4gIHZhciBkaXYgPSBpZnJhbWUuY29udGVudERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5LWRpdic7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGRpdi5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gIGRpdi5zdHlsZS5sZWZ0ID0gMDtcbiAgZGl2LnN0eWxlLnRvcCA9IDA7XG4gIGRpdi5zdHlsZS5yaWdodCA9IDA7XG4gIGRpdi5zdHlsZS5ib3R0b20gPSAwO1xuICBkaXYuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuODUpJztcbiAgZGl2LnN0eWxlLmNvbG9yID0gJyNFOEU4RTgnO1xuICBkaXYuc3R5bGUuZm9udEZhbWlseSA9ICdNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZSc7XG4gIGRpdi5zdHlsZS5mb250U2l6ZSA9ICdsYXJnZSc7XG4gIGRpdi5zdHlsZS5wYWRkaW5nID0gJzJyZW0nO1xuICBkaXYuc3R5bGUubGluZUhlaWdodCA9ICcxLjInO1xuICBkaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gIGRpdi5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHJldHVybiBkaXY7XG59XG5cbnZhciBvdmVybGF5SWZyYW1lID0gbnVsbDtcbnZhciBvdmVybGF5RGl2ID0gbnVsbDtcbnZhciBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKG9uT3ZlcmxheURpdlJlYWR5KSB7XG4gIGlmIChvdmVybGF5RGl2KSB7XG4gICAgLy8gRXZlcnl0aGluZyBpcyByZWFkeSwgY2FsbCB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheS5cbiAgICBvbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDcmVhdGluZyBhbiBpZnJhbWUgbWF5IGJlIGFzeW5jaHJvbm91cyBzbyB3ZSdsbCBzY2hlZHVsZSB0aGUgY2FsbGJhY2suXG4gIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgY2FsbHMsIGxhc3QgY2FsbGJhY2sgd2lucy5cbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gb25PdmVybGF5RGl2UmVhZHk7XG5cbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcbiAgICAvLyBXZSdyZSBhbHJlYWR5IGNyZWF0aW5nIGl0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENyZWF0ZSBpZnJhbWUgYW5kLCB3aGVuIGl0IGlzIHJlYWR5LCBhIGRpdiBpbnNpZGUgaXQuXG4gIG92ZXJsYXlJZnJhbWUgPSBjcmVhdGVPdmVybGF5SWZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICBvdmVybGF5RGl2ID0gYWRkT3ZlcmxheURpdlRvKG92ZXJsYXlJZnJhbWUpO1xuICAgIC8vIE5vdyB3ZSBjYW4gdGFsayFcbiAgICBsYXN0T25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gIH0pO1xuXG4gIC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxuICAvLyBvciBhc3luY2hyb25vdXNseSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gIC8vIFdlIGRlbGF5IGFkZGluZyBpdCBzbyBgb3ZlcmxheUlmcmFtZWAgaXMgc2V0IHdoZW4gYG9uSWZyYW1lTG9hZGAgZmlyZXMuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG59XG5cbmZ1bmN0aW9uIHNob3dNZXNzYWdlT3ZlcmxheShtZXNzYWdlKSB7XG4gIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMoZnVuY3Rpb24gKGRpdikge1xuICAgIC8vIE1ha2UgaXQgbG9vayBzaW1pbGFyIHRvIG91ciB0ZXJtaW5hbC5cbiAgICBkaXYuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiY29sb3I6ICMnICsgY29sb3JzLnJlZCArICdcIj5GYWlsZWQgdG8gY29tcGlsZS48L3NwYW4+PGJyPjxicj4nICsgYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1lc3NhZ2UpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lFcnJvck92ZXJsYXkoKSB7XG4gIGlmICghb3ZlcmxheURpdikge1xuICAgIC8vIEl0IGlzIG5vdCB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlLlxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG92ZXJsYXlJZnJhbWUpO1xuICBvdmVybGF5RGl2ID0gbnVsbDtcbiAgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG59XG5cbi8vIFN1Y2Nlc3NmdWwgY29tcGlsYXRpb24uXG5leHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcbiAgZGVzdHJveUVycm9yT3ZlcmxheSgpO1xufTtcblxuLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5leHBvcnRzLnNob3dNZXNzYWdlID0gZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlcykge1xuICBzaG93TWVzc2FnZU92ZXJsYXkobWVzc2FnZXNbMF0pO1xufTsiXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///9\\n\")},function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.1.4 | http://sockjs.org | MIT license */\\n(function (f) {\\n  if (true) {\\n    module.exports = f();\\n  } else { var g; }\\n})(function () {\\n  var define, module, exports;return function e(t, n, r) {\\n    function s(o, u) {\\n      if (!n[o]) {\\n        if (!t[o]) {\\n          var a = typeof require == \\\"function\\\" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error(\\\"Cannot find module '\\\" + o + \\\"'\\\");throw f.code = \\\"MODULE_NOT_FOUND\\\", f;\\n        }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\\n          var n = t[o][1][e];return s(n ? n : e);\\n        }, l, l.exports, e, t, n, r);\\n      }return n[o].exports;\\n    }var i = typeof require == \\\"function\\\" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;\\n  }({ 1: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var transportList = require('./transport-list');\\n\\n        module.exports = require('./main')(transportList);\\n\\n        // TODO can't get rid of this until all servers do\\n        if ('_sockjs_onload' in global) {\\n          setTimeout(global._sockjs_onload, 1);\\n        }\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./main\\\": 14, \\\"./transport-list\\\": 16 }], 2: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          Event = require('./event');\\n\\n      function CloseEvent() {\\n        Event.call(this);\\n        this.initEvent('close', false, false);\\n        this.wasClean = false;\\n        this.code = 0;\\n        this.reason = '';\\n      }\\n\\n      inherits(CloseEvent, Event);\\n\\n      module.exports = CloseEvent;\\n    }, { \\\"./event\\\": 4, \\\"inherits\\\": 57 }], 3: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          EventTarget = require('./eventtarget');\\n\\n      function EventEmitter() {\\n        EventTarget.call(this);\\n      }\\n\\n      inherits(EventEmitter, EventTarget);\\n\\n      EventEmitter.prototype.removeAllListeners = function (type) {\\n        if (type) {\\n          delete this._listeners[type];\\n        } else {\\n          this._listeners = {};\\n        }\\n      };\\n\\n      EventEmitter.prototype.once = function (type, listener) {\\n        var self = this,\\n            fired = false;\\n\\n        function g() {\\n          self.removeListener(type, g);\\n\\n          if (!fired) {\\n            fired = true;\\n            listener.apply(this, arguments);\\n          }\\n        }\\n\\n        this.on(type, g);\\n      };\\n\\n      EventEmitter.prototype.emit = function () {\\n        var type = arguments[0];\\n        var listeners = this._listeners[type];\\n        if (!listeners) {\\n          return;\\n        }\\n        // equivalent of Array.prototype.slice.call(arguments, 1);\\n        var l = arguments.length;\\n        var args = new Array(l - 1);\\n        for (var ai = 1; ai < l; ai++) {\\n          args[ai - 1] = arguments[ai];\\n        }\\n        for (var i = 0; i < listeners.length; i++) {\\n          listeners[i].apply(this, args);\\n        }\\n      };\\n\\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;\\n      EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;\\n\\n      module.exports.EventEmitter = EventEmitter;\\n    }, { \\\"./eventtarget\\\": 5, \\\"inherits\\\": 57 }], 4: [function (require, module, exports) {\\n      'use strict';\\n\\n      function Event(eventType) {\\n        this.type = eventType;\\n      }\\n\\n      Event.prototype.initEvent = function (eventType, canBubble, cancelable) {\\n        this.type = eventType;\\n        this.bubbles = canBubble;\\n        this.cancelable = cancelable;\\n        this.timeStamp = +new Date();\\n        return this;\\n      };\\n\\n      Event.prototype.stopPropagation = function () {};\\n      Event.prototype.preventDefault = function () {};\\n\\n      Event.CAPTURING_PHASE = 1;\\n      Event.AT_TARGET = 2;\\n      Event.BUBBLING_PHASE = 3;\\n\\n      module.exports = Event;\\n    }, {}], 5: [function (require, module, exports) {\\n      'use strict';\\n\\n      /* Simplified implementation of DOM2 EventTarget.\\n       *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\\n       */\\n\\n      function EventTarget() {\\n        this._listeners = {};\\n      }\\n\\n      EventTarget.prototype.addEventListener = function (eventType, listener) {\\n        if (!(eventType in this._listeners)) {\\n          this._listeners[eventType] = [];\\n        }\\n        var arr = this._listeners[eventType];\\n        // #4\\n        if (arr.indexOf(listener) === -1) {\\n          // Make a copy so as not to interfere with a current dispatchEvent.\\n          arr = arr.concat([listener]);\\n        }\\n        this._listeners[eventType] = arr;\\n      };\\n\\n      EventTarget.prototype.removeEventListener = function (eventType, listener) {\\n        var arr = this._listeners[eventType];\\n        if (!arr) {\\n          return;\\n        }\\n        var idx = arr.indexOf(listener);\\n        if (idx !== -1) {\\n          if (arr.length > 1) {\\n            // Make a copy so as not to interfere with a current dispatchEvent.\\n            this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\\n          } else {\\n            delete this._listeners[eventType];\\n          }\\n          return;\\n        }\\n      };\\n\\n      EventTarget.prototype.dispatchEvent = function () {\\n        var event = arguments[0];\\n        var t = event.type;\\n        // equivalent of Array.prototype.slice.call(arguments, 0);\\n        var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);\\n        // TODO: This doesn't match the real behavior; per spec, onfoo get\\n        // their place in line from the /first/ time they're set from\\n        // non-null. Although WebKit bumps it to the end every time it's\\n        // set.\\n        if (this['on' + t]) {\\n          this['on' + t].apply(this, args);\\n        }\\n        if (t in this._listeners) {\\n          // Grab a reference to the listeners list. removeEventListener may alter the list.\\n          var listeners = this._listeners[t];\\n          for (var i = 0; i < listeners.length; i++) {\\n            listeners[i].apply(this, args);\\n          }\\n        }\\n      };\\n\\n      module.exports = EventTarget;\\n    }, {}], 6: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          Event = require('./event');\\n\\n      function TransportMessageEvent(data) {\\n        Event.call(this);\\n        this.initEvent('message', false, false);\\n        this.data = data;\\n      }\\n\\n      inherits(TransportMessageEvent, Event);\\n\\n      module.exports = TransportMessageEvent;\\n    }, { \\\"./event\\\": 4, \\\"inherits\\\": 57 }], 7: [function (require, module, exports) {\\n      'use strict';\\n\\n      var JSON3 = require('json3'),\\n          iframeUtils = require('./utils/iframe');\\n\\n      function FacadeJS(transport) {\\n        this._transport = transport;\\n        transport.on('message', this._transportMessage.bind(this));\\n        transport.on('close', this._transportClose.bind(this));\\n      }\\n\\n      FacadeJS.prototype._transportClose = function (code, reason) {\\n        iframeUtils.postMessage('c', JSON3.stringify([code, reason]));\\n      };\\n      FacadeJS.prototype._transportMessage = function (frame) {\\n        iframeUtils.postMessage('t', frame);\\n      };\\n      FacadeJS.prototype._send = function (data) {\\n        this._transport.send(data);\\n      };\\n      FacadeJS.prototype._close = function () {\\n        this._transport.close();\\n        this._transport.removeAllListeners();\\n      };\\n\\n      module.exports = FacadeJS;\\n    }, { \\\"./utils/iframe\\\": 47, \\\"json3\\\": 58 }], 8: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var urlUtils = require('./utils/url'),\\n            eventUtils = require('./utils/event'),\\n            JSON3 = require('json3'),\\n            FacadeJS = require('./facade'),\\n            InfoIframeReceiver = require('./info-iframe-receiver'),\\n            iframeUtils = require('./utils/iframe'),\\n            loc = require('./location');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:iframe-bootstrap');\\n        }\\n\\n        module.exports = function (SockJS, availableTransports) {\\n          var transportMap = {};\\n          availableTransports.forEach(function (at) {\\n            if (at.facadeTransport) {\\n              transportMap[at.facadeTransport.transportName] = at.facadeTransport;\\n            }\\n          });\\n\\n          // hard-coded for the info iframe\\n          // TODO see if we can make this more dynamic\\n          transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;\\n          var parentOrigin;\\n\\n          /* eslint-disable camelcase */\\n          SockJS.bootstrap_iframe = function () {\\n            /* eslint-enable camelcase */\\n            var facade;\\n            iframeUtils.currentWindowId = loc.hash.slice(1);\\n            var onMessage = function (e) {\\n              if (e.source !== parent) {\\n                return;\\n              }\\n              if (typeof parentOrigin === 'undefined') {\\n                parentOrigin = e.origin;\\n              }\\n              if (e.origin !== parentOrigin) {\\n                return;\\n              }\\n\\n              var iframeMessage;\\n              try {\\n                iframeMessage = JSON3.parse(e.data);\\n              } catch (ignored) {\\n                debug('bad json', e.data);\\n                return;\\n              }\\n\\n              if (iframeMessage.windowId !== iframeUtils.currentWindowId) {\\n                return;\\n              }\\n              switch (iframeMessage.type) {\\n                case 's':\\n                  var p;\\n                  try {\\n                    p = JSON3.parse(iframeMessage.data);\\n                  } catch (ignored) {\\n                    debug('bad json', iframeMessage.data);\\n                    break;\\n                  }\\n                  var version = p[0];\\n                  var transport = p[1];\\n                  var transUrl = p[2];\\n                  var baseUrl = p[3];\\n                  debug(version, transport, transUrl, baseUrl);\\n                  // change this to semver logic\\n                  if (version !== SockJS.version) {\\n                    throw new Error('Incompatible SockJS! Main site uses:' + ' \\\"' + version + '\\\", the iframe:' + ' \\\"' + SockJS.version + '\\\".');\\n                  }\\n\\n                  if (!urlUtils.isOriginEqual(transUrl, loc.href) || !urlUtils.isOriginEqual(baseUrl, loc.href)) {\\n                    throw new Error('Can\\\\'t connect to different domain from within an ' + 'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');\\n                  }\\n                  facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));\\n                  break;\\n                case 'm':\\n                  facade._send(iframeMessage.data);\\n                  break;\\n                case 'c':\\n                  if (facade) {\\n                    facade._close();\\n                  }\\n                  facade = null;\\n                  break;\\n              }\\n            };\\n\\n            eventUtils.attachEvent('message', onMessage);\\n\\n            // Start\\n            iframeUtils.postMessage('s');\\n          };\\n        };\\n      }).call(this, { env: {} });\\n    }, { \\\"./facade\\\": 7, \\\"./info-iframe-receiver\\\": 10, \\\"./location\\\": 13, \\\"./utils/event\\\": 46, \\\"./utils/iframe\\\": 47, \\\"./utils/url\\\": 52, \\\"debug\\\": 55, \\\"json3\\\": 58 }], 9: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            JSON3 = require('json3'),\\n            objectUtils = require('./utils/object');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:info-ajax');\\n        }\\n\\n        function InfoAjax(url, AjaxObject) {\\n          EventEmitter.call(this);\\n\\n          var self = this;\\n          var t0 = +new Date();\\n          this.xo = new AjaxObject('GET', url);\\n\\n          this.xo.once('finish', function (status, text) {\\n            var info, rtt;\\n            if (status === 200) {\\n              rtt = +new Date() - t0;\\n              if (text) {\\n                try {\\n                  info = JSON3.parse(text);\\n                } catch (e) {\\n                  debug('bad json', text);\\n                }\\n              }\\n\\n              if (!objectUtils.isObject(info)) {\\n                info = {};\\n              }\\n            }\\n            self.emit('finish', info, rtt);\\n            self.removeAllListeners();\\n          });\\n        }\\n\\n        inherits(InfoAjax, EventEmitter);\\n\\n        InfoAjax.prototype.close = function () {\\n          this.removeAllListeners();\\n          this.xo.close();\\n        };\\n\\n        module.exports = InfoAjax;\\n      }).call(this, { env: {} });\\n    }, { \\\"./utils/object\\\": 49, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57, \\\"json3\\\": 58 }], 10: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          EventEmitter = require('events').EventEmitter,\\n          JSON3 = require('json3'),\\n          XHRLocalObject = require('./transport/sender/xhr-local'),\\n          InfoAjax = require('./info-ajax');\\n\\n      function InfoReceiverIframe(transUrl) {\\n        var self = this;\\n        EventEmitter.call(this);\\n\\n        this.ir = new InfoAjax(transUrl, XHRLocalObject);\\n        this.ir.once('finish', function (info, rtt) {\\n          self.ir = null;\\n          self.emit('message', JSON3.stringify([info, rtt]));\\n        });\\n      }\\n\\n      inherits(InfoReceiverIframe, EventEmitter);\\n\\n      InfoReceiverIframe.transportName = 'iframe-info-receiver';\\n\\n      InfoReceiverIframe.prototype.close = function () {\\n        if (this.ir) {\\n          this.ir.close();\\n          this.ir = null;\\n        }\\n        this.removeAllListeners();\\n      };\\n\\n      module.exports = InfoReceiverIframe;\\n    }, { \\\"./info-ajax\\\": 9, \\\"./transport/sender/xhr-local\\\": 37, \\\"events\\\": 3, \\\"inherits\\\": 57, \\\"json3\\\": 58 }], 11: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            JSON3 = require('json3'),\\n            utils = require('./utils/event'),\\n            IframeTransport = require('./transport/iframe'),\\n            InfoReceiverIframe = require('./info-iframe-receiver');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:info-iframe');\\n        }\\n\\n        function InfoIframe(baseUrl, url) {\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          var go = function () {\\n            var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);\\n\\n            ifr.once('message', function (msg) {\\n              if (msg) {\\n                var d;\\n                try {\\n                  d = JSON3.parse(msg);\\n                } catch (e) {\\n                  debug('bad json', msg);\\n                  self.emit('finish');\\n                  self.close();\\n                  return;\\n                }\\n\\n                var info = d[0],\\n                    rtt = d[1];\\n                self.emit('finish', info, rtt);\\n              }\\n              self.close();\\n            });\\n\\n            ifr.once('close', function () {\\n              self.emit('finish');\\n              self.close();\\n            });\\n          };\\n\\n          // TODO this seems the same as the 'needBody' from transports\\n          if (!global.document.body) {\\n            utils.attachEvent('load', go);\\n          } else {\\n            go();\\n          }\\n        }\\n\\n        inherits(InfoIframe, EventEmitter);\\n\\n        InfoIframe.enabled = function () {\\n          return IframeTransport.enabled();\\n        };\\n\\n        InfoIframe.prototype.close = function () {\\n          if (this.ifr) {\\n            this.ifr.close();\\n          }\\n          this.removeAllListeners();\\n          this.ifr = null;\\n        };\\n\\n        module.exports = InfoIframe;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./info-iframe-receiver\\\": 10, \\\"./transport/iframe\\\": 22, \\\"./utils/event\\\": 46, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57, \\\"json3\\\": 58 }], 12: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            urlUtils = require('./utils/url'),\\n            XDR = require('./transport/sender/xdr'),\\n            XHRCors = require('./transport/sender/xhr-cors'),\\n            XHRLocal = require('./transport/sender/xhr-local'),\\n            XHRFake = require('./transport/sender/xhr-fake'),\\n            InfoIframe = require('./info-iframe'),\\n            InfoAjax = require('./info-ajax');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:info-receiver');\\n        }\\n\\n        function InfoReceiver(baseUrl, urlInfo) {\\n          debug(baseUrl);\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          setTimeout(function () {\\n            self.doXhr(baseUrl, urlInfo);\\n          }, 0);\\n        }\\n\\n        inherits(InfoReceiver, EventEmitter);\\n\\n        // TODO this is currently ignoring the list of available transports and the whitelist\\n\\n        InfoReceiver._getReceiver = function (baseUrl, url, urlInfo) {\\n          // determine method of CORS support (if needed)\\n          if (urlInfo.sameOrigin) {\\n            return new InfoAjax(url, XHRLocal);\\n          }\\n          if (XHRCors.enabled) {\\n            return new InfoAjax(url, XHRCors);\\n          }\\n          if (XDR.enabled && urlInfo.sameScheme) {\\n            return new InfoAjax(url, XDR);\\n          }\\n          if (InfoIframe.enabled()) {\\n            return new InfoIframe(baseUrl, url);\\n          }\\n          return new InfoAjax(url, XHRFake);\\n        };\\n\\n        InfoReceiver.prototype.doXhr = function (baseUrl, urlInfo) {\\n          var self = this,\\n              url = urlUtils.addPath(baseUrl, '/info');\\n          debug('doXhr', url);\\n\\n          this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);\\n\\n          this.timeoutRef = setTimeout(function () {\\n            debug('timeout');\\n            self._cleanup(false);\\n            self.emit('finish');\\n          }, InfoReceiver.timeout);\\n\\n          this.xo.once('finish', function (info, rtt) {\\n            debug('finish', info, rtt);\\n            self._cleanup(true);\\n            self.emit('finish', info, rtt);\\n          });\\n        };\\n\\n        InfoReceiver.prototype._cleanup = function (wasClean) {\\n          debug('_cleanup');\\n          clearTimeout(this.timeoutRef);\\n          this.timeoutRef = null;\\n          if (!wasClean && this.xo) {\\n            this.xo.close();\\n          }\\n          this.xo = null;\\n        };\\n\\n        InfoReceiver.prototype.close = function () {\\n          debug('close');\\n          this.removeAllListeners();\\n          this._cleanup(false);\\n        };\\n\\n        InfoReceiver.timeout = 8000;\\n\\n        module.exports = InfoReceiver;\\n      }).call(this, { env: {} });\\n    }, { \\\"./info-ajax\\\": 9, \\\"./info-iframe\\\": 11, \\\"./transport/sender/xdr\\\": 34, \\\"./transport/sender/xhr-cors\\\": 35, \\\"./transport/sender/xhr-fake\\\": 36, \\\"./transport/sender/xhr-local\\\": 37, \\\"./utils/url\\\": 52, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 13: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        module.exports = global.location || {\\n          origin: 'http://localhost:80',\\n          protocol: 'http',\\n          host: 'localhost',\\n          port: 80,\\n          href: 'http://localhost/',\\n          hash: ''\\n        };\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 14: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        require('./shims');\\n\\n        var URL = require('url-parse'),\\n            inherits = require('inherits'),\\n            JSON3 = require('json3'),\\n            random = require('./utils/random'),\\n            escape = require('./utils/escape'),\\n            urlUtils = require('./utils/url'),\\n            eventUtils = require('./utils/event'),\\n            transport = require('./utils/transport'),\\n            objectUtils = require('./utils/object'),\\n            browser = require('./utils/browser'),\\n            log = require('./utils/log'),\\n            Event = require('./event/event'),\\n            EventTarget = require('./event/eventtarget'),\\n            loc = require('./location'),\\n            CloseEvent = require('./event/close'),\\n            TransportMessageEvent = require('./event/trans-message'),\\n            InfoReceiver = require('./info-receiver');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:main');\\n        }\\n\\n        var transports;\\n\\n        // follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface\\n        function SockJS(url, protocols, options) {\\n          if (!(this instanceof SockJS)) {\\n            return new SockJS(url, protocols, options);\\n          }\\n          if (arguments.length < 1) {\\n            throw new TypeError(\\\"Failed to construct 'SockJS: 1 argument required, but only 0 present\\\");\\n          }\\n          EventTarget.call(this);\\n\\n          this.readyState = SockJS.CONNECTING;\\n          this.extensions = '';\\n          this.protocol = '';\\n\\n          // non-standard extension\\n          options = options || {};\\n          if (options.protocols_whitelist) {\\n            log.warn(\\\"'protocols_whitelist' is DEPRECATED. Use 'transports' instead.\\\");\\n          }\\n          this._transportsWhitelist = options.transports;\\n          this._transportOptions = options.transportOptions || {};\\n\\n          var sessionId = options.sessionId || 8;\\n          if (typeof sessionId === 'function') {\\n            this._generateSessionId = sessionId;\\n          } else if (typeof sessionId === 'number') {\\n            this._generateSessionId = function () {\\n              return random.string(sessionId);\\n            };\\n          } else {\\n            throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');\\n          }\\n\\n          this._server = options.server || random.numberString(1000);\\n\\n          // Step 1 of WS spec - parse and validate the url. Issue #8\\n          var parsedUrl = new URL(url);\\n          if (!parsedUrl.host || !parsedUrl.protocol) {\\n            throw new SyntaxError(\\\"The URL '\\\" + url + \\\"' is invalid\\\");\\n          } else if (parsedUrl.hash) {\\n            throw new SyntaxError('The URL must not contain a fragment');\\n          } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\\n            throw new SyntaxError(\\\"The URL's scheme must be either 'http:' or 'https:'. '\\\" + parsedUrl.protocol + \\\"' is not allowed.\\\");\\n          }\\n\\n          var secure = parsedUrl.protocol === 'https:';\\n          // Step 2 - don't allow secure origin with an insecure protocol\\n          if (loc.protocol === 'https' && !secure) {\\n            throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');\\n          }\\n\\n          // Step 3 - check port access - no need here\\n          // Step 4 - parse protocols argument\\n          if (!protocols) {\\n            protocols = [];\\n          } else if (!Array.isArray(protocols)) {\\n            protocols = [protocols];\\n          }\\n\\n          // Step 5 - check protocols argument\\n          var sortedProtocols = protocols.sort();\\n          sortedProtocols.forEach(function (proto, i) {\\n            if (!proto) {\\n              throw new SyntaxError(\\\"The protocols entry '\\\" + proto + \\\"' is invalid.\\\");\\n            }\\n            if (i < sortedProtocols.length - 1 && proto === sortedProtocols[i + 1]) {\\n              throw new SyntaxError(\\\"The protocols entry '\\\" + proto + \\\"' is duplicated.\\\");\\n            }\\n          });\\n\\n          // Step 6 - convert origin\\n          var o = urlUtils.getOrigin(loc.href);\\n          this._origin = o ? o.toLowerCase() : null;\\n\\n          // remove the trailing slash\\n          parsedUrl.set('pathname', parsedUrl.pathname.replace(/\\\\/+$/, ''));\\n\\n          // store the sanitized url\\n          this.url = parsedUrl.href;\\n          debug('using url', this.url);\\n\\n          // Step 7 - start connection in background\\n          // obtain server info\\n          // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26\\n          this._urlInfo = {\\n            nullOrigin: !browser.hasDomain(),\\n            sameOrigin: urlUtils.isOriginEqual(this.url, loc.href),\\n            sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)\\n          };\\n\\n          this._ir = new InfoReceiver(this.url, this._urlInfo);\\n          this._ir.once('finish', this._receiveInfo.bind(this));\\n        }\\n\\n        inherits(SockJS, EventTarget);\\n\\n        function userSetCode(code) {\\n          return code === 1000 || code >= 3000 && code <= 4999;\\n        }\\n\\n        SockJS.prototype.close = function (code, reason) {\\n          // Step 1\\n          if (code && !userSetCode(code)) {\\n            throw new Error('InvalidAccessError: Invalid code');\\n          }\\n          // Step 2.4 states the max is 123 bytes, but we are just checking length\\n          if (reason && reason.length > 123) {\\n            throw new SyntaxError('reason argument has an invalid length');\\n          }\\n\\n          // Step 3.1\\n          if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {\\n            return;\\n          }\\n\\n          // TODO look at docs to determine how to set this\\n          var wasClean = true;\\n          this._close(code || 1000, reason || 'Normal closure', wasClean);\\n        };\\n\\n        SockJS.prototype.send = function (data) {\\n          // #13 - convert anything non-string to string\\n          // TODO this currently turns objects into [object Object]\\n          if (typeof data !== 'string') {\\n            data = '' + data;\\n          }\\n          if (this.readyState === SockJS.CONNECTING) {\\n            throw new Error('InvalidStateError: The connection has not been established yet');\\n          }\\n          if (this.readyState !== SockJS.OPEN) {\\n            return;\\n          }\\n          this._transport.send(escape.quote(data));\\n        };\\n\\n        SockJS.version = require('./version');\\n\\n        SockJS.CONNECTING = 0;\\n        SockJS.OPEN = 1;\\n        SockJS.CLOSING = 2;\\n        SockJS.CLOSED = 3;\\n\\n        SockJS.prototype._receiveInfo = function (info, rtt) {\\n          debug('_receiveInfo', rtt);\\n          this._ir = null;\\n          if (!info) {\\n            this._close(1002, 'Cannot connect to server');\\n            return;\\n          }\\n\\n          // establish a round-trip timeout (RTO) based on the\\n          // round-trip time (RTT)\\n          this._rto = this.countRTO(rtt);\\n          // allow server to override url used for the actual transport\\n          this._transUrl = info.base_url ? info.base_url : this.url;\\n          info = objectUtils.extend(info, this._urlInfo);\\n          debug('info', info);\\n          // determine list of desired and supported transports\\n          var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);\\n          this._transports = enabledTransports.main;\\n          debug(this._transports.length + ' enabled transports');\\n\\n          this._connect();\\n        };\\n\\n        SockJS.prototype._connect = function () {\\n          for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {\\n            debug('attempt', Transport.transportName);\\n            if (Transport.needBody) {\\n              if (!global.document.body || typeof global.document.readyState !== 'undefined' && global.document.readyState !== 'complete' && global.document.readyState !== 'interactive') {\\n                debug('waiting for body');\\n                this._transports.unshift(Transport);\\n                eventUtils.attachEvent('load', this._connect.bind(this));\\n                return;\\n              }\\n            }\\n\\n            // calculate timeout based on RTO and round trips. Default to 5s\\n            var timeoutMs = this._rto * Transport.roundTrips || 5000;\\n            this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);\\n            debug('using timeout', timeoutMs);\\n\\n            var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());\\n            var options = this._transportOptions[Transport.transportName];\\n            debug('transport url', transportUrl);\\n            var transportObj = new Transport(transportUrl, this._transUrl, options);\\n            transportObj.on('message', this._transportMessage.bind(this));\\n            transportObj.once('close', this._transportClose.bind(this));\\n            transportObj.transportName = Transport.transportName;\\n            this._transport = transportObj;\\n\\n            return;\\n          }\\n          this._close(2000, 'All transports failed', false);\\n        };\\n\\n        SockJS.prototype._transportTimeout = function () {\\n          debug('_transportTimeout');\\n          if (this.readyState === SockJS.CONNECTING) {\\n            this._transportClose(2007, 'Transport timed out');\\n          }\\n        };\\n\\n        SockJS.prototype._transportMessage = function (msg) {\\n          debug('_transportMessage', msg);\\n          var self = this,\\n              type = msg.slice(0, 1),\\n              content = msg.slice(1),\\n              payload;\\n\\n          // first check for messages that don't need a payload\\n          switch (type) {\\n            case 'o':\\n              this._open();\\n              return;\\n            case 'h':\\n              this.dispatchEvent(new Event('heartbeat'));\\n              debug('heartbeat', this.transport);\\n              return;\\n          }\\n\\n          if (content) {\\n            try {\\n              payload = JSON3.parse(content);\\n            } catch (e) {\\n              debug('bad json', content);\\n            }\\n          }\\n\\n          if (typeof payload === 'undefined') {\\n            debug('empty payload', content);\\n            return;\\n          }\\n\\n          switch (type) {\\n            case 'a':\\n              if (Array.isArray(payload)) {\\n                payload.forEach(function (p) {\\n                  debug('message', self.transport, p);\\n                  self.dispatchEvent(new TransportMessageEvent(p));\\n                });\\n              }\\n              break;\\n            case 'm':\\n              debug('message', this.transport, payload);\\n              this.dispatchEvent(new TransportMessageEvent(payload));\\n              break;\\n            case 'c':\\n              if (Array.isArray(payload) && payload.length === 2) {\\n                this._close(payload[0], payload[1], true);\\n              }\\n              break;\\n          }\\n        };\\n\\n        SockJS.prototype._transportClose = function (code, reason) {\\n          debug('_transportClose', this.transport, code, reason);\\n          if (this._transport) {\\n            this._transport.removeAllListeners();\\n            this._transport = null;\\n            this.transport = null;\\n          }\\n\\n          if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {\\n            this._connect();\\n            return;\\n          }\\n\\n          this._close(code, reason);\\n        };\\n\\n        SockJS.prototype._open = function () {\\n          debug('_open', this._transport.transportName, this.readyState);\\n          if (this.readyState === SockJS.CONNECTING) {\\n            if (this._transportTimeoutId) {\\n              clearTimeout(this._transportTimeoutId);\\n              this._transportTimeoutId = null;\\n            }\\n            this.readyState = SockJS.OPEN;\\n            this.transport = this._transport.transportName;\\n            this.dispatchEvent(new Event('open'));\\n            debug('connected', this.transport);\\n          } else {\\n            // The server might have been restarted, and lost track of our\\n            // connection.\\n            this._close(1006, 'Server lost session');\\n          }\\n        };\\n\\n        SockJS.prototype._close = function (code, reason, wasClean) {\\n          debug('_close', this.transport, code, reason, wasClean, this.readyState);\\n          var forceFail = false;\\n\\n          if (this._ir) {\\n            forceFail = true;\\n            this._ir.close();\\n            this._ir = null;\\n          }\\n          if (this._transport) {\\n            this._transport.close();\\n            this._transport = null;\\n            this.transport = null;\\n          }\\n\\n          if (this.readyState === SockJS.CLOSED) {\\n            throw new Error('InvalidStateError: SockJS has already been closed');\\n          }\\n\\n          this.readyState = SockJS.CLOSING;\\n          setTimeout(function () {\\n            this.readyState = SockJS.CLOSED;\\n\\n            if (forceFail) {\\n              this.dispatchEvent(new Event('error'));\\n            }\\n\\n            var e = new CloseEvent('close');\\n            e.wasClean = wasClean || false;\\n            e.code = code || 1000;\\n            e.reason = reason;\\n\\n            this.dispatchEvent(e);\\n            this.onmessage = this.onclose = this.onerror = null;\\n            debug('disconnected');\\n          }.bind(this), 0);\\n        };\\n\\n        // See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\\n        // and RFC 2988.\\n        SockJS.prototype.countRTO = function (rtt) {\\n          // In a local environment, when using IE8/9 and the `jsonp-polling`\\n          // transport the time needed to establish a connection (the time that pass\\n          // from the opening of the transport to the call of `_dispatchOpen`) is\\n          // around 200msec (the lower bound used in the article above) and this\\n          // causes spurious timeouts. For this reason we calculate a value slightly\\n          // larger than that used in the article.\\n          if (rtt > 100) {\\n            return 4 * rtt; // rto > 400msec\\n          }\\n          return 300 + rtt; // 300msec < rto <= 400msec\\n        };\\n\\n        module.exports = function (availableTransports) {\\n          transports = transport(availableTransports);\\n          require('./iframe-bootstrap')(SockJS, availableTransports);\\n          return SockJS;\\n        };\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./event/close\\\": 2, \\\"./event/event\\\": 4, \\\"./event/eventtarget\\\": 5, \\\"./event/trans-message\\\": 6, \\\"./iframe-bootstrap\\\": 8, \\\"./info-receiver\\\": 12, \\\"./location\\\": 13, \\\"./shims\\\": 15, \\\"./utils/browser\\\": 44, \\\"./utils/escape\\\": 45, \\\"./utils/event\\\": 46, \\\"./utils/log\\\": 48, \\\"./utils/object\\\": 49, \\\"./utils/random\\\": 50, \\\"./utils/transport\\\": 51, \\\"./utils/url\\\": 52, \\\"./version\\\": 53, \\\"debug\\\": 55, \\\"inherits\\\": 57, \\\"json3\\\": 58, \\\"url-parse\\\": 61 }], 15: [function (require, module, exports) {\\n      /* eslint-disable */\\n      /* jscs: disable */\\n      'use strict';\\n\\n      // pulled specific shims from https://github.com/es-shims/es5-shim\\n\\n      var ArrayPrototype = Array.prototype;\\n      var ObjectPrototype = Object.prototype;\\n      var FunctionPrototype = Function.prototype;\\n      var StringPrototype = String.prototype;\\n      var array_slice = ArrayPrototype.slice;\\n\\n      var _toString = ObjectPrototype.toString;\\n      var isFunction = function (val) {\\n        return ObjectPrototype.toString.call(val) === '[object Function]';\\n      };\\n      var isArray = function isArray(obj) {\\n        return _toString.call(obj) === '[object Array]';\\n      };\\n      var isString = function isString(obj) {\\n        return _toString.call(obj) === '[object String]';\\n      };\\n\\n      var supportsDescriptors = Object.defineProperty && function () {\\n        try {\\n          Object.defineProperty({}, 'x', {});\\n          return true;\\n        } catch (e) {\\n          /* this is ES3 */\\n          return false;\\n        }\\n      }();\\n\\n      // Define configurable, writable and non-enumerable props\\n      // if they don't exist.\\n      var defineProperty;\\n      if (supportsDescriptors) {\\n        defineProperty = function (object, name, method, forceAssign) {\\n          if (!forceAssign && name in object) {\\n            return;\\n          }\\n          Object.defineProperty(object, name, {\\n            configurable: true,\\n            enumerable: false,\\n            writable: true,\\n            value: method\\n          });\\n        };\\n      } else {\\n        defineProperty = function (object, name, method, forceAssign) {\\n          if (!forceAssign && name in object) {\\n            return;\\n          }\\n          object[name] = method;\\n        };\\n      }\\n      var defineProperties = function (object, map, forceAssign) {\\n        for (var name in map) {\\n          if (ObjectPrototype.hasOwnProperty.call(map, name)) {\\n            defineProperty(object, name, map[name], forceAssign);\\n          }\\n        }\\n      };\\n\\n      var toObject = function (o) {\\n        if (o == null) {\\n          // this matches both null and undefined\\n          throw new TypeError(\\\"can't convert \\\" + o + ' to object');\\n        }\\n        return Object(o);\\n      };\\n\\n      //\\n      // Util\\n      // ======\\n      //\\n\\n      // ES5 9.4\\n      // http://es5.github.com/#x9.4\\n      // http://jsperf.com/to-integer\\n\\n      function toInteger(num) {\\n        var n = +num;\\n        if (n !== n) {\\n          // isNaN\\n          n = 0;\\n        } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {\\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\\n        }\\n        return n;\\n      }\\n\\n      function ToUint32(x) {\\n        return x >>> 0;\\n      }\\n\\n      //\\n      // Function\\n      // ========\\n      //\\n\\n      // ES-5 15.3.4.5\\n      // http://es5.github.com/#x15.3.4.5\\n\\n      function Empty() {}\\n\\n      defineProperties(FunctionPrototype, {\\n        bind: function bind(that) {\\n          // .length is 1\\n          // 1. Let Target be the this value.\\n          var target = this;\\n          // 2. If IsCallable(Target) is false, throw a TypeError exception.\\n          if (!isFunction(target)) {\\n            throw new TypeError('Function.prototype.bind called on incompatible ' + target);\\n          }\\n          // 3. Let A be a new (possibly empty) internal list of all of the\\n          //   argument values provided after thisArg (arg1, arg2 etc), in order.\\n          // XXX slicedArgs will stand in for \\\"A\\\" if used\\n          var args = array_slice.call(arguments, 1); // for normal call\\n          // 4. Let F be a new native ECMAScript object.\\n          // 11. Set the [[Prototype]] internal property of F to the standard\\n          //   built-in Function prototype object as specified in 15.3.3.1.\\n          // 12. Set the [[Call]] internal property of F as described in\\n          //   15.3.4.5.1.\\n          // 13. Set the [[Construct]] internal property of F as described in\\n          //   15.3.4.5.2.\\n          // 14. Set the [[HasInstance]] internal property of F as described in\\n          //   15.3.4.5.3.\\n          var binder = function () {\\n\\n            if (this instanceof bound) {\\n              // 15.3.4.5.2 [[Construct]]\\n              // When the [[Construct]] internal method of a function object,\\n              // F that was created using the bind function is called with a\\n              // list of arguments ExtraArgs, the following steps are taken:\\n              // 1. Let target be the value of F's [[TargetFunction]]\\n              //   internal property.\\n              // 2. If target has no [[Construct]] internal method, a\\n              //   TypeError exception is thrown.\\n              // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\\n              //   property.\\n              // 4. Let args be a new list containing the same values as the\\n              //   list boundArgs in the same order followed by the same\\n              //   values as the list ExtraArgs in the same order.\\n              // 5. Return the result of calling the [[Construct]] internal\\n              //   method of target providing args as the arguments.\\n\\n              var result = target.apply(this, args.concat(array_slice.call(arguments)));\\n              if (Object(result) === result) {\\n                return result;\\n              }\\n              return this;\\n            } else {\\n              // 15.3.4.5.1 [[Call]]\\n              // When the [[Call]] internal method of a function object, F,\\n              // which was created using the bind function is called with a\\n              // this value and a list of arguments ExtraArgs, the following\\n              // steps are taken:\\n              // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\\n              //   property.\\n              // 2. Let boundThis be the value of F's [[BoundThis]] internal\\n              //   property.\\n              // 3. Let target be the value of F's [[TargetFunction]] internal\\n              //   property.\\n              // 4. Let args be a new list containing the same values as the\\n              //   list boundArgs in the same order followed by the same\\n              //   values as the list ExtraArgs in the same order.\\n              // 5. Return the result of calling the [[Call]] internal method\\n              //   of target providing boundThis as the this value and\\n              //   providing args as the arguments.\\n\\n              // equiv: target.call(this, ...boundArgs, ...args)\\n              return target.apply(that, args.concat(array_slice.call(arguments)));\\n            }\\n          };\\n\\n          // 15. If the [[Class]] internal property of Target is \\\"Function\\\", then\\n          //     a. Let L be the length property of Target minus the length of A.\\n          //     b. Set the length own property of F to either 0 or L, whichever is\\n          //       larger.\\n          // 16. Else set the length own property of F to 0.\\n\\n          var boundLength = Math.max(0, target.length - args.length);\\n\\n          // 17. Set the attributes of the length own property of F to the values\\n          //   specified in 15.3.5.1.\\n          var boundArgs = [];\\n          for (var i = 0; i < boundLength; i++) {\\n            boundArgs.push('$' + i);\\n          }\\n\\n          // XXX Build a dynamic function with desired amount of arguments is the only\\n          // way to set the length property of a function.\\n          // In environments where Content Security Policies enabled (Chrome extensions,\\n          // for ex.) all use of eval or Function costructor throws an exception.\\n          // However in all of these environments Function.prototype.bind exists\\n          // and so this code will never be executed.\\n          var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\\n\\n          if (target.prototype) {\\n            Empty.prototype = target.prototype;\\n            bound.prototype = new Empty();\\n            // Clean up dangling references.\\n            Empty.prototype = null;\\n          }\\n\\n          // TODO\\n          // 18. Set the [[Extensible]] internal property of F to true.\\n\\n          // TODO\\n          // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\\n          // 20. Call the [[DefineOwnProperty]] internal method of F with\\n          //   arguments \\\"caller\\\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\\n          //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\\n          //   false.\\n          // 21. Call the [[DefineOwnProperty]] internal method of F with\\n          //   arguments \\\"arguments\\\", PropertyDescriptor {[[Get]]: thrower,\\n          //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\\n          //   and false.\\n\\n          // TODO\\n          // NOTE Function objects created using Function.prototype.bind do not\\n          // have a prototype property or the [[Code]], [[FormalParameters]], and\\n          // [[Scope]] internal properties.\\n          // XXX can't delete prototype in pure-js.\\n\\n          // 22. Return F.\\n          return bound;\\n        }\\n      });\\n\\n      //\\n      // Array\\n      // =====\\n      //\\n\\n      // ES5 15.4.3.2\\n      // http://es5.github.com/#x15.4.3.2\\n      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\\n      defineProperties(Array, { isArray: isArray });\\n\\n      var boxedString = Object('a');\\n      var splitString = boxedString[0] !== 'a' || !(0 in boxedString);\\n\\n      var properlyBoxesContext = function properlyBoxed(method) {\\n        // Check node 0.6.21 bug where third parameter is not boxed\\n        var properlyBoxesNonStrict = true;\\n        var properlyBoxesStrict = true;\\n        if (method) {\\n          method.call('foo', function (_, __, context) {\\n            if (typeof context !== 'object') {\\n              properlyBoxesNonStrict = false;\\n            }\\n          });\\n\\n          method.call([1], function () {\\n            'use strict';\\n\\n            properlyBoxesStrict = typeof this === 'string';\\n          }, 'x');\\n        }\\n        return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\\n      };\\n\\n      defineProperties(ArrayPrototype, {\\n        forEach: function forEach(fun /*, thisp*/) {\\n          var object = toObject(this),\\n              self = splitString && isString(this) ? this.split('') : object,\\n              thisp = arguments[1],\\n              i = -1,\\n              length = self.length >>> 0;\\n\\n          // If no callback function or if callback is not a callable function\\n          if (!isFunction(fun)) {\\n            throw new TypeError(); // TODO message\\n          }\\n\\n          while (++i < length) {\\n            if (i in self) {\\n              // Invoke the callback function with call, passing arguments:\\n              // context, property value, property key, thisArg object\\n              // context\\n              fun.call(thisp, self[i], i, object);\\n            }\\n          }\\n        }\\n      }, !properlyBoxesContext(ArrayPrototype.forEach));\\n\\n      // ES5 15.4.4.14\\n      // http://es5.github.com/#x15.4.4.14\\n      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\\n      var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;\\n      defineProperties(ArrayPrototype, {\\n        indexOf: function indexOf(sought /*, fromIndex */) {\\n          var self = splitString && isString(this) ? this.split('') : toObject(this),\\n              length = self.length >>> 0;\\n\\n          if (!length) {\\n            return -1;\\n          }\\n\\n          var i = 0;\\n          if (arguments.length > 1) {\\n            i = toInteger(arguments[1]);\\n          }\\n\\n          // handle negative indices\\n          i = i >= 0 ? i : Math.max(0, length + i);\\n          for (; i < length; i++) {\\n            if (i in self && self[i] === sought) {\\n              return i;\\n            }\\n          }\\n          return -1;\\n        }\\n      }, hasFirefox2IndexOfBug);\\n\\n      //\\n      // String\\n      // ======\\n      //\\n\\n      // ES5 15.5.4.14\\n      // http://es5.github.com/#x15.5.4.14\\n\\n      // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\\n      // Many browsers do not split properly with regular expressions or they\\n      // do not perform the split correctly under obscure conditions.\\n      // See http://blog.stevenlevithan.com/archives/cross-browser-split\\n      // I've tested in many browsers and this seems to cover the deviant ones:\\n      //    'ab'.split(/(?:ab)*/) should be [\\\"\\\", \\\"\\\"], not [\\\"\\\"]\\n      //    '.'.split(/(.?)(.?)/) should be [\\\"\\\", \\\".\\\", \\\"\\\", \\\"\\\"], not [\\\"\\\", \\\"\\\"]\\n      //    'tesst'.split(/(s)*/) should be [\\\"t\\\", undefined, \\\"e\\\", \\\"s\\\", \\\"t\\\"], not\\n      //       [undefined, \\\"t\\\", undefined, \\\"e\\\", ...]\\n      //    ''.split(/.?/) should be [], not [\\\"\\\"]\\n      //    '.'.split(/()()/) should be [\\\".\\\"], not [\\\"\\\", \\\"\\\", \\\".\\\"]\\n\\n      var string_split = StringPrototype.split;\\n      if ('ab'.split(/(?:ab)*/).length !== 2 || '.'.split(/(.?)(.?)/).length !== 4 || 'tesst'.split(/(s)*/)[1] === 't' || 'test'.split(/(?:)/, -1).length !== 4 || ''.split(/.?/).length || '.'.split(/()()/).length > 1) {\\n        (function () {\\n          var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group\\n\\n          StringPrototype.split = function (separator, limit) {\\n            var string = this;\\n            if (separator === void 0 && limit === 0) {\\n              return [];\\n            }\\n\\n            // If `separator` is not a regex, use native split\\n            if (_toString.call(separator) !== '[object RegExp]') {\\n              return string_split.call(this, separator, limit);\\n            }\\n\\n            var output = [],\\n                flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.extended ? 'x' : '') + ( // Proposed for ES6\\n            separator.sticky ? 'y' : ''),\\n                // Firefox 3+\\n            lastLastIndex = 0,\\n\\n            // Make `global` and avoid `lastIndex` issues by working with a copy\\n            separator2,\\n                match,\\n                lastIndex,\\n                lastLength;\\n            separator = new RegExp(separator.source, flags + 'g');\\n            string += ''; // Type-convert\\n            if (!compliantExecNpcg) {\\n              // Doesn't need flags gy, but they don't hurt\\n              separator2 = new RegExp('^' + separator.source + '$(?!\\\\\\\\s)', flags);\\n            }\\n            /* Values for `limit`, per the spec:\\n             * If undefined: 4294967295 // Math.pow(2, 32) - 1\\n             * If 0, Infinity, or NaN: 0\\n             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\\n             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\\n             * If other: Type-convert, then use the above rules\\n             */\\n            limit = limit === void 0 ? -1 >>> 0 : // Math.pow(2, 32) - 1\\n            ToUint32(limit);\\n            while (match = separator.exec(string)) {\\n              // `separator.lastIndex` is not reliable cross-browser\\n              lastIndex = match.index + match[0].length;\\n              if (lastIndex > lastLastIndex) {\\n                output.push(string.slice(lastLastIndex, match.index));\\n                // Fix browsers whose `exec` methods don't consistently return `undefined` for\\n                // nonparticipating capturing groups\\n                if (!compliantExecNpcg && match.length > 1) {\\n                  match[0].replace(separator2, function () {\\n                    for (var i = 1; i < arguments.length - 2; i++) {\\n                      if (arguments[i] === void 0) {\\n                        match[i] = void 0;\\n                      }\\n                    }\\n                  });\\n                }\\n                if (match.length > 1 && match.index < string.length) {\\n                  ArrayPrototype.push.apply(output, match.slice(1));\\n                }\\n                lastLength = match[0].length;\\n                lastLastIndex = lastIndex;\\n                if (output.length >= limit) {\\n                  break;\\n                }\\n              }\\n              if (separator.lastIndex === match.index) {\\n                separator.lastIndex++; // Avoid an infinite loop\\n              }\\n            }\\n            if (lastLastIndex === string.length) {\\n              if (lastLength || !separator.test('')) {\\n                output.push('');\\n              }\\n            } else {\\n              output.push(string.slice(lastLastIndex));\\n            }\\n            return output.length > limit ? output.slice(0, limit) : output;\\n          };\\n        })();\\n\\n        // [bugfix, chrome]\\n        // If separator is undefined, then the result array contains just one String,\\n        // which is the this value (converted to a String). If limit is not undefined,\\n        // then the output array is truncated so that it contains no more than limit\\n        // elements.\\n        // \\\"0\\\".split(undefined, 0) -> []\\n      } else if ('0'.split(void 0, 0).length) {\\n        StringPrototype.split = function split(separator, limit) {\\n          if (separator === void 0 && limit === 0) {\\n            return [];\\n          }\\n          return string_split.call(this, separator, limit);\\n        };\\n      }\\n\\n      // ECMA-262, 3rd B.2.3\\n      // Not an ECMAScript standard, although ECMAScript 3rd Edition has a\\n      // non-normative section suggesting uniform semantics and it should be\\n      // normalized across all browsers\\n      // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\\n      var string_substr = StringPrototype.substr;\\n      var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';\\n      defineProperties(StringPrototype, {\\n        substr: function substr(start, length) {\\n          return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);\\n        }\\n      }, hasNegativeSubstrBug);\\n    }, {}], 16: [function (require, module, exports) {\\n      'use strict';\\n\\n      module.exports = [\\n      // streaming transports\\n      require('./transport/websocket'), require('./transport/xhr-streaming'), require('./transport/xdr-streaming'), require('./transport/eventsource'), require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))\\n\\n      // polling transports\\n      , require('./transport/htmlfile'), require('./transport/lib/iframe-wrap')(require('./transport/htmlfile')), require('./transport/xhr-polling'), require('./transport/xdr-polling'), require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling')), require('./transport/jsonp-polling')];\\n    }, { \\\"./transport/eventsource\\\": 20, \\\"./transport/htmlfile\\\": 21, \\\"./transport/jsonp-polling\\\": 23, \\\"./transport/lib/iframe-wrap\\\": 26, \\\"./transport/websocket\\\": 38, \\\"./transport/xdr-polling\\\": 39, \\\"./transport/xdr-streaming\\\": 40, \\\"./transport/xhr-polling\\\": 41, \\\"./transport/xhr-streaming\\\": 42 }], 17: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            utils = require('../../utils/event'),\\n            urlUtils = require('../../utils/url'),\\n            XHR = global.XMLHttpRequest;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:browser:xhr');\\n        }\\n\\n        function AbstractXHRObject(method, url, payload, opts) {\\n          debug(method, url);\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          setTimeout(function () {\\n            self._start(method, url, payload, opts);\\n          }, 0);\\n        }\\n\\n        inherits(AbstractXHRObject, EventEmitter);\\n\\n        AbstractXHRObject.prototype._start = function (method, url, payload, opts) {\\n          var self = this;\\n\\n          try {\\n            this.xhr = new XHR();\\n          } catch (x) {\\n            // intentionally empty\\n          }\\n\\n          if (!this.xhr) {\\n            debug('no xhr');\\n            this.emit('finish', 0, 'no xhr support');\\n            this._cleanup();\\n            return;\\n          }\\n\\n          // several browsers cache POSTs\\n          url = urlUtils.addQuery(url, 't=' + +new Date());\\n\\n          // Explorer tends to keep connection open, even after the\\n          // tab gets closed: http://bugs.jquery.com/ticket/5280\\n          this.unloadRef = utils.unloadAdd(function () {\\n            debug('unload cleanup');\\n            self._cleanup(true);\\n          });\\n          try {\\n            this.xhr.open(method, url, true);\\n            if (this.timeout && 'timeout' in this.xhr) {\\n              this.xhr.timeout = this.timeout;\\n              this.xhr.ontimeout = function () {\\n                debug('xhr timeout');\\n                self.emit('finish', 0, '');\\n                self._cleanup(false);\\n              };\\n            }\\n          } catch (e) {\\n            debug('exception', e);\\n            // IE raises an exception on wrong port.\\n            this.emit('finish', 0, '');\\n            this._cleanup(false);\\n            return;\\n          }\\n\\n          if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {\\n            debug('withCredentials');\\n            // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\\n            // \\\"This never affects same-site requests.\\\"\\n\\n            this.xhr.withCredentials = 'true';\\n          }\\n          if (opts && opts.headers) {\\n            for (var key in opts.headers) {\\n              this.xhr.setRequestHeader(key, opts.headers[key]);\\n            }\\n          }\\n\\n          this.xhr.onreadystatechange = function () {\\n            if (self.xhr) {\\n              var x = self.xhr;\\n              var text, status;\\n              debug('readyState', x.readyState);\\n              switch (x.readyState) {\\n                case 3:\\n                  // IE doesn't like peeking into responseText or status\\n                  // on Microsoft.XMLHTTP and readystate=3\\n                  try {\\n                    status = x.status;\\n                    text = x.responseText;\\n                  } catch (e) {\\n                    // intentionally empty\\n                  }\\n                  debug('status', status);\\n                  // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\n                  if (status === 1223) {\\n                    status = 204;\\n                  }\\n\\n                  // IE does return readystate == 3 for 404 answers.\\n                  if (status === 200 && text && text.length > 0) {\\n                    debug('chunk');\\n                    self.emit('chunk', status, text);\\n                  }\\n                  break;\\n                case 4:\\n                  status = x.status;\\n                  debug('status', status);\\n                  // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\n                  if (status === 1223) {\\n                    status = 204;\\n                  }\\n                  // IE returns this for a bad port\\n                  // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx\\n                  if (status === 12005 || status === 12029) {\\n                    status = 0;\\n                  }\\n\\n                  debug('finish', status, x.responseText);\\n                  self.emit('finish', status, x.responseText);\\n                  self._cleanup(false);\\n                  break;\\n              }\\n            }\\n          };\\n\\n          try {\\n            self.xhr.send(payload);\\n          } catch (e) {\\n            self.emit('finish', 0, '');\\n            self._cleanup(false);\\n          }\\n        };\\n\\n        AbstractXHRObject.prototype._cleanup = function (abort) {\\n          debug('cleanup');\\n          if (!this.xhr) {\\n            return;\\n          }\\n          this.removeAllListeners();\\n          utils.unloadDel(this.unloadRef);\\n\\n          // IE needs this field to be a function\\n          this.xhr.onreadystatechange = function () {};\\n          if (this.xhr.ontimeout) {\\n            this.xhr.ontimeout = null;\\n          }\\n\\n          if (abort) {\\n            try {\\n              this.xhr.abort();\\n            } catch (x) {\\n              // intentionally empty\\n            }\\n          }\\n          this.unloadRef = this.xhr = null;\\n        };\\n\\n        AbstractXHRObject.prototype.close = function () {\\n          debug('close');\\n          this._cleanup(true);\\n        };\\n\\n        AbstractXHRObject.enabled = !!XHR;\\n        // override XMLHttpRequest for IE6/7\\n        // obfuscate to avoid firewalls\\n        var axo = ['Active'].concat('Object').join('X');\\n        if (!AbstractXHRObject.enabled && axo in global) {\\n          debug('overriding xmlhttprequest');\\n          XHR = function () {\\n            try {\\n              return new global[axo]('Microsoft.XMLHTTP');\\n            } catch (e) {\\n              return null;\\n            }\\n          };\\n          AbstractXHRObject.enabled = !!new XHR();\\n        }\\n\\n        var cors = false;\\n        try {\\n          cors = 'withCredentials' in new XHR();\\n        } catch (ignored) {\\n          // intentionally empty\\n        }\\n\\n        AbstractXHRObject.supportsCORS = cors;\\n\\n        module.exports = AbstractXHRObject;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/event\\\": 46, \\\"../../utils/url\\\": 52, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 18: [function (require, module, exports) {\\n      (function (global) {\\n        module.exports = global.EventSource;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 19: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var Driver = global.WebSocket || global.MozWebSocket;\\n        if (Driver) {\\n          module.exports = function WebSocketBrowserDriver(url) {\\n            return new Driver(url);\\n          };\\n        } else {\\n          module.exports = undefined;\\n        }\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 20: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          AjaxBasedTransport = require('./lib/ajax-based'),\\n          EventSourceReceiver = require('./receiver/eventsource'),\\n          XHRCorsObject = require('./sender/xhr-cors'),\\n          EventSourceDriver = require('eventsource');\\n\\n      function EventSourceTransport(transUrl) {\\n        if (!EventSourceTransport.enabled()) {\\n          throw new Error('Transport created when disabled');\\n        }\\n\\n        AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);\\n      }\\n\\n      inherits(EventSourceTransport, AjaxBasedTransport);\\n\\n      EventSourceTransport.enabled = function () {\\n        return !!EventSourceDriver;\\n      };\\n\\n      EventSourceTransport.transportName = 'eventsource';\\n      EventSourceTransport.roundTrips = 2;\\n\\n      module.exports = EventSourceTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/eventsource\\\": 29, \\\"./sender/xhr-cors\\\": 35, \\\"eventsource\\\": 18, \\\"inherits\\\": 57 }], 21: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          HtmlfileReceiver = require('./receiver/htmlfile'),\\n          XHRLocalObject = require('./sender/xhr-local'),\\n          AjaxBasedTransport = require('./lib/ajax-based');\\n\\n      function HtmlFileTransport(transUrl) {\\n        if (!HtmlfileReceiver.enabled) {\\n          throw new Error('Transport created when disabled');\\n        }\\n        AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);\\n      }\\n\\n      inherits(HtmlFileTransport, AjaxBasedTransport);\\n\\n      HtmlFileTransport.enabled = function (info) {\\n        return HtmlfileReceiver.enabled && info.sameOrigin;\\n      };\\n\\n      HtmlFileTransport.transportName = 'htmlfile';\\n      HtmlFileTransport.roundTrips = 2;\\n\\n      module.exports = HtmlFileTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/htmlfile\\\": 30, \\\"./sender/xhr-local\\\": 37, \\\"inherits\\\": 57 }], 22: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        // Few cool transports do work only for same-origin. In order to make\\n        // them work cross-domain we shall use iframe, served from the\\n        // remote domain. New browsers have capabilities to communicate with\\n        // cross domain iframe using postMessage(). In IE it was implemented\\n        // from IE 8+, but of course, IE got some details wrong:\\n        //    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\\n        //    http://stevesouders.com/misc/test-postmessage.php\\n\\n        var inherits = require('inherits'),\\n            JSON3 = require('json3'),\\n            EventEmitter = require('events').EventEmitter,\\n            version = require('../version'),\\n            urlUtils = require('../utils/url'),\\n            iframeUtils = require('../utils/iframe'),\\n            eventUtils = require('../utils/event'),\\n            random = require('../utils/random');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:transport:iframe');\\n        }\\n\\n        function IframeTransport(transport, transUrl, baseUrl) {\\n          if (!IframeTransport.enabled()) {\\n            throw new Error('Transport created when disabled');\\n          }\\n          EventEmitter.call(this);\\n\\n          var self = this;\\n          this.origin = urlUtils.getOrigin(baseUrl);\\n          this.baseUrl = baseUrl;\\n          this.transUrl = transUrl;\\n          this.transport = transport;\\n          this.windowId = random.string(8);\\n\\n          var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;\\n          debug(transport, transUrl, iframeUrl);\\n\\n          this.iframeObj = iframeUtils.createIframe(iframeUrl, function (r) {\\n            debug('err callback');\\n            self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');\\n            self.close();\\n          });\\n\\n          this.onmessageCallback = this._message.bind(this);\\n          eventUtils.attachEvent('message', this.onmessageCallback);\\n        }\\n\\n        inherits(IframeTransport, EventEmitter);\\n\\n        IframeTransport.prototype.close = function () {\\n          debug('close');\\n          this.removeAllListeners();\\n          if (this.iframeObj) {\\n            eventUtils.detachEvent('message', this.onmessageCallback);\\n            try {\\n              // When the iframe is not loaded, IE raises an exception\\n              // on 'contentWindow'.\\n              this.postMessage('c');\\n            } catch (x) {\\n              // intentionally empty\\n            }\\n            this.iframeObj.cleanup();\\n            this.iframeObj = null;\\n            this.onmessageCallback = this.iframeObj = null;\\n          }\\n        };\\n\\n        IframeTransport.prototype._message = function (e) {\\n          debug('message', e.data);\\n          if (!urlUtils.isOriginEqual(e.origin, this.origin)) {\\n            debug('not same origin', e.origin, this.origin);\\n            return;\\n          }\\n\\n          var iframeMessage;\\n          try {\\n            iframeMessage = JSON3.parse(e.data);\\n          } catch (ignored) {\\n            debug('bad json', e.data);\\n            return;\\n          }\\n\\n          if (iframeMessage.windowId !== this.windowId) {\\n            debug('mismatched window id', iframeMessage.windowId, this.windowId);\\n            return;\\n          }\\n\\n          switch (iframeMessage.type) {\\n            case 's':\\n              this.iframeObj.loaded();\\n              // window global dependency\\n              this.postMessage('s', JSON3.stringify([version, this.transport, this.transUrl, this.baseUrl]));\\n              break;\\n            case 't':\\n              this.emit('message', iframeMessage.data);\\n              break;\\n            case 'c':\\n              var cdata;\\n              try {\\n                cdata = JSON3.parse(iframeMessage.data);\\n              } catch (ignored) {\\n                debug('bad json', iframeMessage.data);\\n                return;\\n              }\\n              this.emit('close', cdata[0], cdata[1]);\\n              this.close();\\n              break;\\n          }\\n        };\\n\\n        IframeTransport.prototype.postMessage = function (type, data) {\\n          debug('postMessage', type, data);\\n          this.iframeObj.post(JSON3.stringify({\\n            windowId: this.windowId,\\n            type: type,\\n            data: data || ''\\n          }), this.origin);\\n        };\\n\\n        IframeTransport.prototype.send = function (message) {\\n          debug('send', message);\\n          this.postMessage('m', message);\\n        };\\n\\n        IframeTransport.enabled = function () {\\n          return iframeUtils.iframeEnabled;\\n        };\\n\\n        IframeTransport.transportName = 'iframe';\\n        IframeTransport.roundTrips = 2;\\n\\n        module.exports = IframeTransport;\\n      }).call(this, { env: {} });\\n    }, { \\\"../utils/event\\\": 46, \\\"../utils/iframe\\\": 47, \\\"../utils/random\\\": 50, \\\"../utils/url\\\": 52, \\\"../version\\\": 53, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57, \\\"json3\\\": 58 }], 23: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        // The simplest and most robust transport, using the well-know cross\\n        // domain hack - JSONP. This transport is quite inefficient - one\\n        // message could use up to one http request. But at least it works almost\\n        // everywhere.\\n        // Known limitations:\\n        //   o you will get a spinning cursor\\n        //   o for Konqueror a dumb timer is needed to detect errors\\n\\n        var inherits = require('inherits'),\\n            SenderReceiver = require('./lib/sender-receiver'),\\n            JsonpReceiver = require('./receiver/jsonp'),\\n            jsonpSender = require('./sender/jsonp');\\n\\n        function JsonPTransport(transUrl) {\\n          if (!JsonPTransport.enabled()) {\\n            throw new Error('Transport created when disabled');\\n          }\\n          SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);\\n        }\\n\\n        inherits(JsonPTransport, SenderReceiver);\\n\\n        JsonPTransport.enabled = function () {\\n          return !!global.document;\\n        };\\n\\n        JsonPTransport.transportName = 'jsonp-polling';\\n        JsonPTransport.roundTrips = 1;\\n        JsonPTransport.needBody = true;\\n\\n        module.exports = JsonPTransport;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./lib/sender-receiver\\\": 28, \\\"./receiver/jsonp\\\": 31, \\\"./sender/jsonp\\\": 33, \\\"inherits\\\": 57 }], 24: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            urlUtils = require('../../utils/url'),\\n            SenderReceiver = require('./sender-receiver');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:ajax-based');\\n        }\\n\\n        function createAjaxSender(AjaxObject) {\\n          return function (url, payload, callback) {\\n            debug('create ajax sender', url, payload);\\n            var opt = {};\\n            if (typeof payload === 'string') {\\n              opt.headers = { 'Content-type': 'text/plain' };\\n            }\\n            var ajaxUrl = urlUtils.addPath(url, '/xhr_send');\\n            var xo = new AjaxObject('POST', ajaxUrl, payload, opt);\\n            xo.once('finish', function (status) {\\n              debug('finish', status);\\n              xo = null;\\n\\n              if (status !== 200 && status !== 204) {\\n                return callback(new Error('http status ' + status));\\n              }\\n              callback();\\n            });\\n            return function () {\\n              debug('abort');\\n              xo.close();\\n              xo = null;\\n\\n              var err = new Error('Aborted');\\n              err.code = 1000;\\n              callback(err);\\n            };\\n          };\\n        }\\n\\n        function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {\\n          SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);\\n        }\\n\\n        inherits(AjaxBasedTransport, SenderReceiver);\\n\\n        module.exports = AjaxBasedTransport;\\n      }).call(this, { env: {} });\\n    }, { \\\"../../utils/url\\\": 52, \\\"./sender-receiver\\\": 28, \\\"debug\\\": 55, \\\"inherits\\\": 57 }], 25: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:buffered-sender');\\n        }\\n\\n        function BufferedSender(url, sender) {\\n          debug(url);\\n          EventEmitter.call(this);\\n          this.sendBuffer = [];\\n          this.sender = sender;\\n          this.url = url;\\n        }\\n\\n        inherits(BufferedSender, EventEmitter);\\n\\n        BufferedSender.prototype.send = function (message) {\\n          debug('send', message);\\n          this.sendBuffer.push(message);\\n          if (!this.sendStop) {\\n            this.sendSchedule();\\n          }\\n        };\\n\\n        // For polling transports in a situation when in the message callback,\\n        // new message is being send. If the sending connection was started\\n        // before receiving one, it is possible to saturate the network and\\n        // timeout due to the lack of receiving socket. To avoid that we delay\\n        // sending messages by some small time, in order to let receiving\\n        // connection be started beforehand. This is only a halfmeasure and\\n        // does not fix the big problem, but it does make the tests go more\\n        // stable on slow networks.\\n        BufferedSender.prototype.sendScheduleWait = function () {\\n          debug('sendScheduleWait');\\n          var self = this;\\n          var tref;\\n          this.sendStop = function () {\\n            debug('sendStop');\\n            self.sendStop = null;\\n            clearTimeout(tref);\\n          };\\n          tref = setTimeout(function () {\\n            debug('timeout');\\n            self.sendStop = null;\\n            self.sendSchedule();\\n          }, 25);\\n        };\\n\\n        BufferedSender.prototype.sendSchedule = function () {\\n          debug('sendSchedule', this.sendBuffer.length);\\n          var self = this;\\n          if (this.sendBuffer.length > 0) {\\n            var payload = '[' + this.sendBuffer.join(',') + ']';\\n            this.sendStop = this.sender(this.url, payload, function (err) {\\n              self.sendStop = null;\\n              if (err) {\\n                debug('error', err);\\n                self.emit('close', err.code || 1006, 'Sending error: ' + err);\\n                self.close();\\n              } else {\\n                self.sendScheduleWait();\\n              }\\n            });\\n            this.sendBuffer = [];\\n          }\\n        };\\n\\n        BufferedSender.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          this.removeAllListeners();\\n        };\\n\\n        BufferedSender.prototype.close = function () {\\n          debug('close');\\n          this._cleanup();\\n          if (this.sendStop) {\\n            this.sendStop();\\n            this.sendStop = null;\\n          }\\n        };\\n\\n        module.exports = BufferedSender;\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 26: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            IframeTransport = require('../iframe'),\\n            objectUtils = require('../../utils/object');\\n\\n        module.exports = function (transport) {\\n\\n          function IframeWrapTransport(transUrl, baseUrl) {\\n            IframeTransport.call(this, transport.transportName, transUrl, baseUrl);\\n          }\\n\\n          inherits(IframeWrapTransport, IframeTransport);\\n\\n          IframeWrapTransport.enabled = function (url, info) {\\n            if (!global.document) {\\n              return false;\\n            }\\n\\n            var iframeInfo = objectUtils.extend({}, info);\\n            iframeInfo.sameOrigin = true;\\n            return transport.enabled(iframeInfo) && IframeTransport.enabled();\\n          };\\n\\n          IframeWrapTransport.transportName = 'iframe-' + transport.transportName;\\n          IframeWrapTransport.needBody = true;\\n          IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)\\n\\n          IframeWrapTransport.facadeTransport = transport;\\n\\n          return IframeWrapTransport;\\n        };\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/object\\\": 49, \\\"../iframe\\\": 22, \\\"inherits\\\": 57 }], 27: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:polling');\\n        }\\n\\n        function Polling(Receiver, receiveUrl, AjaxObject) {\\n          debug(receiveUrl);\\n          EventEmitter.call(this);\\n          this.Receiver = Receiver;\\n          this.receiveUrl = receiveUrl;\\n          this.AjaxObject = AjaxObject;\\n          this._scheduleReceiver();\\n        }\\n\\n        inherits(Polling, EventEmitter);\\n\\n        Polling.prototype._scheduleReceiver = function () {\\n          debug('_scheduleReceiver');\\n          var self = this;\\n          var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);\\n\\n          poll.on('message', function (msg) {\\n            debug('message', msg);\\n            self.emit('message', msg);\\n          });\\n\\n          poll.once('close', function (code, reason) {\\n            debug('close', code, reason, self.pollIsClosing);\\n            self.poll = poll = null;\\n\\n            if (!self.pollIsClosing) {\\n              if (reason === 'network') {\\n                self._scheduleReceiver();\\n              } else {\\n                self.emit('close', code || 1006, reason);\\n                self.removeAllListeners();\\n              }\\n            }\\n          });\\n        };\\n\\n        Polling.prototype.abort = function () {\\n          debug('abort');\\n          this.removeAllListeners();\\n          this.pollIsClosing = true;\\n          if (this.poll) {\\n            this.poll.abort();\\n          }\\n        };\\n\\n        module.exports = Polling;\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 28: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            urlUtils = require('../../utils/url'),\\n            BufferedSender = require('./buffered-sender'),\\n            Polling = require('./polling');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:sender-receiver');\\n        }\\n\\n        function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {\\n          var pollUrl = urlUtils.addPath(transUrl, urlSuffix);\\n          debug(pollUrl);\\n          var self = this;\\n          BufferedSender.call(this, transUrl, senderFunc);\\n\\n          this.poll = new Polling(Receiver, pollUrl, AjaxObject);\\n          this.poll.on('message', function (msg) {\\n            debug('poll message', msg);\\n            self.emit('message', msg);\\n          });\\n          this.poll.once('close', function (code, reason) {\\n            debug('poll close', code, reason);\\n            self.poll = null;\\n            self.emit('close', code, reason);\\n            self.close();\\n          });\\n        }\\n\\n        inherits(SenderReceiver, BufferedSender);\\n\\n        SenderReceiver.prototype.close = function () {\\n          BufferedSender.prototype.close.call(this);\\n          debug('close');\\n          this.removeAllListeners();\\n          if (this.poll) {\\n            this.poll.abort();\\n            this.poll = null;\\n          }\\n        };\\n\\n        module.exports = SenderReceiver;\\n      }).call(this, { env: {} });\\n    }, { \\\"../../utils/url\\\": 52, \\\"./buffered-sender\\\": 25, \\\"./polling\\\": 27, \\\"debug\\\": 55, \\\"inherits\\\": 57 }], 29: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter,\\n            EventSourceDriver = require('eventsource');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:receiver:eventsource');\\n        }\\n\\n        function EventSourceReceiver(url) {\\n          debug(url);\\n          EventEmitter.call(this);\\n\\n          var self = this;\\n          var es = this.es = new EventSourceDriver(url);\\n          es.onmessage = function (e) {\\n            debug('message', e.data);\\n            self.emit('message', decodeURI(e.data));\\n          };\\n          es.onerror = function (e) {\\n            debug('error', es.readyState, e);\\n            // ES on reconnection has readyState = 0 or 1.\\n            // on network error it's CLOSED = 2\\n            var reason = es.readyState !== 2 ? 'network' : 'permanent';\\n            self._cleanup();\\n            self._close(reason);\\n          };\\n        }\\n\\n        inherits(EventSourceReceiver, EventEmitter);\\n\\n        EventSourceReceiver.prototype.abort = function () {\\n          debug('abort');\\n          this._cleanup();\\n          this._close('user');\\n        };\\n\\n        EventSourceReceiver.prototype._cleanup = function () {\\n          debug('cleanup');\\n          var es = this.es;\\n          if (es) {\\n            es.onmessage = es.onerror = null;\\n            es.close();\\n            this.es = null;\\n          }\\n        };\\n\\n        EventSourceReceiver.prototype._close = function (reason) {\\n          debug('close', reason);\\n          var self = this;\\n          // Safari and chrome < 15 crash if we close window before\\n          // waiting for ES cleanup. See:\\n          // https://code.google.com/p/chromium/issues/detail?id=89155\\n          setTimeout(function () {\\n            self.emit('close', null, reason);\\n            self.removeAllListeners();\\n          }, 200);\\n        };\\n\\n        module.exports = EventSourceReceiver;\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 55, \\\"events\\\": 3, \\\"eventsource\\\": 18, \\\"inherits\\\": 57 }], 30: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            iframeUtils = require('../../utils/iframe'),\\n            urlUtils = require('../../utils/url'),\\n            EventEmitter = require('events').EventEmitter,\\n            random = require('../../utils/random');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:receiver:htmlfile');\\n        }\\n\\n        function HtmlfileReceiver(url) {\\n          debug(url);\\n          EventEmitter.call(this);\\n          var self = this;\\n          iframeUtils.polluteGlobalNamespace();\\n\\n          this.id = 'a' + random.string(6);\\n          url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));\\n\\n          debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);\\n          var constructFunc = HtmlfileReceiver.htmlfileEnabled ? iframeUtils.createHtmlfile : iframeUtils.createIframe;\\n\\n          global[iframeUtils.WPrefix][this.id] = {\\n            start: function () {\\n              debug('start');\\n              self.iframeObj.loaded();\\n            },\\n            message: function (data) {\\n              debug('message', data);\\n              self.emit('message', data);\\n            },\\n            stop: function () {\\n              debug('stop');\\n              self._cleanup();\\n              self._close('network');\\n            }\\n          };\\n          this.iframeObj = constructFunc(url, function () {\\n            debug('callback');\\n            self._cleanup();\\n            self._close('permanent');\\n          });\\n        }\\n\\n        inherits(HtmlfileReceiver, EventEmitter);\\n\\n        HtmlfileReceiver.prototype.abort = function () {\\n          debug('abort');\\n          this._cleanup();\\n          this._close('user');\\n        };\\n\\n        HtmlfileReceiver.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          if (this.iframeObj) {\\n            this.iframeObj.cleanup();\\n            this.iframeObj = null;\\n          }\\n          delete global[iframeUtils.WPrefix][this.id];\\n        };\\n\\n        HtmlfileReceiver.prototype._close = function (reason) {\\n          debug('_close', reason);\\n          this.emit('close', null, reason);\\n          this.removeAllListeners();\\n        };\\n\\n        HtmlfileReceiver.htmlfileEnabled = false;\\n\\n        // obfuscate to avoid firewalls\\n        var axo = ['Active'].concat('Object').join('X');\\n        if (axo in global) {\\n          try {\\n            HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');\\n          } catch (x) {\\n            // intentionally empty\\n          }\\n        }\\n\\n        HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;\\n\\n        module.exports = HtmlfileReceiver;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/iframe\\\": 47, \\\"../../utils/random\\\": 50, \\\"../../utils/url\\\": 52, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 31: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var utils = require('../../utils/iframe'),\\n            random = require('../../utils/random'),\\n            browser = require('../../utils/browser'),\\n            urlUtils = require('../../utils/url'),\\n            inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:receiver:jsonp');\\n        }\\n\\n        function JsonpReceiver(url) {\\n          debug(url);\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          utils.polluteGlobalNamespace();\\n\\n          this.id = 'a' + random.string(6);\\n          var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));\\n\\n          global[utils.WPrefix][this.id] = this._callback.bind(this);\\n          this._createScript(urlWithId);\\n\\n          // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\\n          this.timeoutId = setTimeout(function () {\\n            debug('timeout');\\n            self._abort(new Error('JSONP script loaded abnormally (timeout)'));\\n          }, JsonpReceiver.timeout);\\n        }\\n\\n        inherits(JsonpReceiver, EventEmitter);\\n\\n        JsonpReceiver.prototype.abort = function () {\\n          debug('abort');\\n          if (global[utils.WPrefix][this.id]) {\\n            var err = new Error('JSONP user aborted read');\\n            err.code = 1000;\\n            this._abort(err);\\n          }\\n        };\\n\\n        JsonpReceiver.timeout = 35000;\\n        JsonpReceiver.scriptErrorTimeout = 1000;\\n\\n        JsonpReceiver.prototype._callback = function (data) {\\n          debug('_callback', data);\\n          this._cleanup();\\n\\n          if (this.aborting) {\\n            return;\\n          }\\n\\n          if (data) {\\n            debug('message', data);\\n            this.emit('message', data);\\n          }\\n          this.emit('close', null, 'network');\\n          this.removeAllListeners();\\n        };\\n\\n        JsonpReceiver.prototype._abort = function (err) {\\n          debug('_abort', err);\\n          this._cleanup();\\n          this.aborting = true;\\n          this.emit('close', err.code, err.message);\\n          this.removeAllListeners();\\n        };\\n\\n        JsonpReceiver.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          clearTimeout(this.timeoutId);\\n          if (this.script2) {\\n            this.script2.parentNode.removeChild(this.script2);\\n            this.script2 = null;\\n          }\\n          if (this.script) {\\n            var script = this.script;\\n            // Unfortunately, you can't really abort script loading of\\n            // the script.\\n            script.parentNode.removeChild(script);\\n            script.onreadystatechange = script.onerror = script.onload = script.onclick = null;\\n            this.script = null;\\n          }\\n          delete global[utils.WPrefix][this.id];\\n        };\\n\\n        JsonpReceiver.prototype._scriptError = function () {\\n          debug('_scriptError');\\n          var self = this;\\n          if (this.errorTimer) {\\n            return;\\n          }\\n\\n          this.errorTimer = setTimeout(function () {\\n            if (!self.loadedOkay) {\\n              self._abort(new Error('JSONP script loaded abnormally (onerror)'));\\n            }\\n          }, JsonpReceiver.scriptErrorTimeout);\\n        };\\n\\n        JsonpReceiver.prototype._createScript = function (url) {\\n          debug('_createScript', url);\\n          var self = this;\\n          var script = this.script = global.document.createElement('script');\\n          var script2; // Opera synchronous load trick.\\n\\n          script.id = 'a' + random.string(8);\\n          script.src = url;\\n          script.type = 'text/javascript';\\n          script.charset = 'UTF-8';\\n          script.onerror = this._scriptError.bind(this);\\n          script.onload = function () {\\n            debug('onload');\\n            self._abort(new Error('JSONP script loaded abnormally (onload)'));\\n          };\\n\\n          // IE9 fires 'error' event after onreadystatechange or before, in random order.\\n          // Use loadedOkay to determine if actually errored\\n          script.onreadystatechange = function () {\\n            debug('onreadystatechange', script.readyState);\\n            if (/loaded|closed/.test(script.readyState)) {\\n              if (script && script.htmlFor && script.onclick) {\\n                self.loadedOkay = true;\\n                try {\\n                  // In IE, actually execute the script.\\n                  script.onclick();\\n                } catch (x) {\\n                  // intentionally empty\\n                }\\n              }\\n              if (script) {\\n                self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));\\n              }\\n            }\\n          };\\n          // IE: event/htmlFor/onclick trick.\\n          // One can't rely on proper order for onreadystatechange. In order to\\n          // make sure, set a 'htmlFor' and 'event' properties, so that\\n          // script code will be installed as 'onclick' handler for the\\n          // script object. Later, onreadystatechange, manually execute this\\n          // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\\n          // set. For reference see:\\n          //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\\n          // Also, read on that about script ordering:\\n          //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\\n          if (typeof script.async === 'undefined' && global.document.attachEvent) {\\n            // According to mozilla docs, in recent browsers script.async defaults\\n            // to 'true', so we may use it to detect a good browser:\\n            // https://developer.mozilla.org/en/HTML/Element/script\\n            if (!browser.isOpera()) {\\n              // Naively assume we're in IE\\n              try {\\n                script.htmlFor = script.id;\\n                script.event = 'onclick';\\n              } catch (x) {\\n                // intentionally empty\\n              }\\n              script.async = true;\\n            } else {\\n              // Opera, second sync script hack\\n              script2 = this.script2 = global.document.createElement('script');\\n              script2.text = \\\"try{var a = document.getElementById('\\\" + script.id + \\\"'); if(a)a.onerror();}catch(x){};\\\";\\n              script.async = script2.async = false;\\n            }\\n          }\\n          if (typeof script.async !== 'undefined') {\\n            script.async = true;\\n          }\\n\\n          var head = global.document.getElementsByTagName('head')[0];\\n          head.insertBefore(script, head.firstChild);\\n          if (script2) {\\n            head.insertBefore(script2, head.firstChild);\\n          }\\n        };\\n\\n        module.exports = JsonpReceiver;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/browser\\\": 44, \\\"../../utils/iframe\\\": 47, \\\"../../utils/random\\\": 50, \\\"../../utils/url\\\": 52, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 32: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:receiver:xhr');\\n        }\\n\\n        function XhrReceiver(url, AjaxObject) {\\n          debug(url);\\n          EventEmitter.call(this);\\n          var self = this;\\n\\n          this.bufferPosition = 0;\\n\\n          this.xo = new AjaxObject('POST', url, null);\\n          this.xo.on('chunk', this._chunkHandler.bind(this));\\n          this.xo.once('finish', function (status, text) {\\n            debug('finish', status, text);\\n            self._chunkHandler(status, text);\\n            self.xo = null;\\n            var reason = status === 200 ? 'network' : 'permanent';\\n            debug('close', reason);\\n            self.emit('close', null, reason);\\n            self._cleanup();\\n          });\\n        }\\n\\n        inherits(XhrReceiver, EventEmitter);\\n\\n        XhrReceiver.prototype._chunkHandler = function (status, text) {\\n          debug('_chunkHandler', status);\\n          if (status !== 200 || !text) {\\n            return;\\n          }\\n\\n          for (var idx = -1;; this.bufferPosition += idx + 1) {\\n            var buf = text.slice(this.bufferPosition);\\n            idx = buf.indexOf('\\\\n');\\n            if (idx === -1) {\\n              break;\\n            }\\n            var msg = buf.slice(0, idx);\\n            if (msg) {\\n              debug('message', msg);\\n              this.emit('message', msg);\\n            }\\n          }\\n        };\\n\\n        XhrReceiver.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          this.removeAllListeners();\\n        };\\n\\n        XhrReceiver.prototype.abort = function () {\\n          debug('abort');\\n          if (this.xo) {\\n            this.xo.close();\\n            debug('close');\\n            this.emit('close', null, 'user');\\n            this.xo = null;\\n          }\\n          this._cleanup();\\n        };\\n\\n        module.exports = XhrReceiver;\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 33: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var random = require('../../utils/random'),\\n            urlUtils = require('../../utils/url');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:sender:jsonp');\\n        }\\n\\n        var form, area;\\n\\n        function createIframe(id) {\\n          debug('createIframe', id);\\n          try {\\n            // ie6 dynamic iframes with target=\\\"\\\" support (thanks Chris Lambacher)\\n            return global.document.createElement('<iframe name=\\\"' + id + '\\\">');\\n          } catch (x) {\\n            var iframe = global.document.createElement('iframe');\\n            iframe.name = id;\\n            return iframe;\\n          }\\n        }\\n\\n        function createForm() {\\n          debug('createForm');\\n          form = global.document.createElement('form');\\n          form.style.display = 'none';\\n          form.style.position = 'absolute';\\n          form.method = 'POST';\\n          form.enctype = 'application/x-www-form-urlencoded';\\n          form.acceptCharset = 'UTF-8';\\n\\n          area = global.document.createElement('textarea');\\n          area.name = 'd';\\n          form.appendChild(area);\\n\\n          global.document.body.appendChild(form);\\n        }\\n\\n        module.exports = function (url, payload, callback) {\\n          debug(url, payload);\\n          if (!form) {\\n            createForm();\\n          }\\n          var id = 'a' + random.string(8);\\n          form.target = id;\\n          form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);\\n\\n          var iframe = createIframe(id);\\n          iframe.id = id;\\n          iframe.style.display = 'none';\\n          form.appendChild(iframe);\\n\\n          try {\\n            area.value = payload;\\n          } catch (e) {\\n            // seriously broken browsers get here\\n          }\\n          form.submit();\\n\\n          var completed = function (err) {\\n            debug('completed', id, err);\\n            if (!iframe.onerror) {\\n              return;\\n            }\\n            iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\\n            // Opera mini doesn't like if we GC iframe\\n            // immediately, thus this timeout.\\n            setTimeout(function () {\\n              debug('cleaning up', id);\\n              iframe.parentNode.removeChild(iframe);\\n              iframe = null;\\n            }, 500);\\n            area.value = '';\\n            // It is not possible to detect if the iframe succeeded or\\n            // failed to submit our form.\\n            callback(err);\\n          };\\n          iframe.onerror = function () {\\n            debug('onerror', id);\\n            completed();\\n          };\\n          iframe.onload = function () {\\n            debug('onload', id);\\n            completed();\\n          };\\n          iframe.onreadystatechange = function (e) {\\n            debug('onreadystatechange', id, iframe.readyState, e);\\n            if (iframe.readyState === 'complete') {\\n              completed();\\n            }\\n          };\\n          return function () {\\n            debug('aborted', id);\\n            completed(new Error('Aborted'));\\n          };\\n        };\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/random\\\": 50, \\\"../../utils/url\\\": 52, \\\"debug\\\": 55 }], 34: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            eventUtils = require('../../utils/event'),\\n            browser = require('../../utils/browser'),\\n            urlUtils = require('../../utils/url');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:sender:xdr');\\n        }\\n\\n        // References:\\n        //   http://ajaxian.com/archives/100-line-ajax-wrapper\\n        //   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\\n\\n        function XDRObject(method, url, payload) {\\n          debug(method, url);\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          setTimeout(function () {\\n            self._start(method, url, payload);\\n          }, 0);\\n        }\\n\\n        inherits(XDRObject, EventEmitter);\\n\\n        XDRObject.prototype._start = function (method, url, payload) {\\n          debug('_start');\\n          var self = this;\\n          var xdr = new global.XDomainRequest();\\n          // IE caches even POSTs\\n          url = urlUtils.addQuery(url, 't=' + +new Date());\\n\\n          xdr.onerror = function () {\\n            debug('onerror');\\n            self._error();\\n          };\\n          xdr.ontimeout = function () {\\n            debug('ontimeout');\\n            self._error();\\n          };\\n          xdr.onprogress = function () {\\n            debug('progress', xdr.responseText);\\n            self.emit('chunk', 200, xdr.responseText);\\n          };\\n          xdr.onload = function () {\\n            debug('load');\\n            self.emit('finish', 200, xdr.responseText);\\n            self._cleanup(false);\\n          };\\n          this.xdr = xdr;\\n          this.unloadRef = eventUtils.unloadAdd(function () {\\n            self._cleanup(true);\\n          });\\n          try {\\n            // Fails with AccessDenied if port number is bogus\\n            this.xdr.open(method, url);\\n            if (this.timeout) {\\n              this.xdr.timeout = this.timeout;\\n            }\\n            this.xdr.send(payload);\\n          } catch (x) {\\n            this._error();\\n          }\\n        };\\n\\n        XDRObject.prototype._error = function () {\\n          this.emit('finish', 0, '');\\n          this._cleanup(false);\\n        };\\n\\n        XDRObject.prototype._cleanup = function (abort) {\\n          debug('cleanup', abort);\\n          if (!this.xdr) {\\n            return;\\n          }\\n          this.removeAllListeners();\\n          eventUtils.unloadDel(this.unloadRef);\\n\\n          this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;\\n          if (abort) {\\n            try {\\n              this.xdr.abort();\\n            } catch (x) {\\n              // intentionally empty\\n            }\\n          }\\n          this.unloadRef = this.xdr = null;\\n        };\\n\\n        XDRObject.prototype.close = function () {\\n          debug('close');\\n          this._cleanup(true);\\n        };\\n\\n        // IE 8/9 if the request target uses the same scheme - #79\\n        XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());\\n\\n        module.exports = XDRObject;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/browser\\\": 44, \\\"../../utils/event\\\": 46, \\\"../../utils/url\\\": 52, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 35: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          XhrDriver = require('../driver/xhr');\\n\\n      function XHRCorsObject(method, url, payload, opts) {\\n        XhrDriver.call(this, method, url, payload, opts);\\n      }\\n\\n      inherits(XHRCorsObject, XhrDriver);\\n\\n      XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;\\n\\n      module.exports = XHRCorsObject;\\n    }, { \\\"../driver/xhr\\\": 17, \\\"inherits\\\": 57 }], 36: [function (require, module, exports) {\\n      'use strict';\\n\\n      var EventEmitter = require('events').EventEmitter,\\n          inherits = require('inherits');\\n\\n      function XHRFake() /* method, url, payload, opts */{\\n        var self = this;\\n        EventEmitter.call(this);\\n\\n        this.to = setTimeout(function () {\\n          self.emit('finish', 200, '{}');\\n        }, XHRFake.timeout);\\n      }\\n\\n      inherits(XHRFake, EventEmitter);\\n\\n      XHRFake.prototype.close = function () {\\n        clearTimeout(this.to);\\n      };\\n\\n      XHRFake.timeout = 2000;\\n\\n      module.exports = XHRFake;\\n    }, { \\\"events\\\": 3, \\\"inherits\\\": 57 }], 37: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          XhrDriver = require('../driver/xhr');\\n\\n      function XHRLocalObject(method, url, payload /*, opts */) {\\n        XhrDriver.call(this, method, url, payload, {\\n          noCredentials: true\\n        });\\n      }\\n\\n      inherits(XHRLocalObject, XhrDriver);\\n\\n      XHRLocalObject.enabled = XhrDriver.enabled;\\n\\n      module.exports = XHRLocalObject;\\n    }, { \\\"../driver/xhr\\\": 17, \\\"inherits\\\": 57 }], 38: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var utils = require('../utils/event'),\\n            urlUtils = require('../utils/url'),\\n            inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter,\\n            WebsocketDriver = require('./driver/websocket');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:websocket');\\n        }\\n\\n        function WebSocketTransport(transUrl, ignore, options) {\\n          if (!WebSocketTransport.enabled()) {\\n            throw new Error('Transport created when disabled');\\n          }\\n\\n          EventEmitter.call(this);\\n          debug('constructor', transUrl);\\n\\n          var self = this;\\n          var url = urlUtils.addPath(transUrl, '/websocket');\\n          if (url.slice(0, 5) === 'https') {\\n            url = 'wss' + url.slice(5);\\n          } else {\\n            url = 'ws' + url.slice(4);\\n          }\\n          this.url = url;\\n\\n          this.ws = new WebsocketDriver(this.url, [], options);\\n          this.ws.onmessage = function (e) {\\n            debug('message event', e.data);\\n            self.emit('message', e.data);\\n          };\\n          // Firefox has an interesting bug. If a websocket connection is\\n          // created after onunload, it stays alive even when user\\n          // navigates away from the page. In such situation let's lie -\\n          // let's not open the ws connection at all. See:\\n          // https://github.com/sockjs/sockjs-client/issues/28\\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\\n          this.unloadRef = utils.unloadAdd(function () {\\n            debug('unload');\\n            self.ws.close();\\n          });\\n          this.ws.onclose = function (e) {\\n            debug('close event', e.code, e.reason);\\n            self.emit('close', e.code, e.reason);\\n            self._cleanup();\\n          };\\n          this.ws.onerror = function (e) {\\n            debug('error event', e);\\n            self.emit('close', 1006, 'WebSocket connection broken');\\n            self._cleanup();\\n          };\\n        }\\n\\n        inherits(WebSocketTransport, EventEmitter);\\n\\n        WebSocketTransport.prototype.send = function (data) {\\n          var msg = '[' + data + ']';\\n          debug('send', msg);\\n          this.ws.send(msg);\\n        };\\n\\n        WebSocketTransport.prototype.close = function () {\\n          debug('close');\\n          var ws = this.ws;\\n          this._cleanup();\\n          if (ws) {\\n            ws.close();\\n          }\\n        };\\n\\n        WebSocketTransport.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          var ws = this.ws;\\n          if (ws) {\\n            ws.onmessage = ws.onclose = ws.onerror = null;\\n          }\\n          utils.unloadDel(this.unloadRef);\\n          this.unloadRef = this.ws = null;\\n          this.removeAllListeners();\\n        };\\n\\n        WebSocketTransport.enabled = function () {\\n          debug('enabled');\\n          return !!WebsocketDriver;\\n        };\\n        WebSocketTransport.transportName = 'websocket';\\n\\n        // In theory, ws should require 1 round trip. But in chrome, this is\\n        // not very stable over SSL. Most likely a ws connection requires a\\n        // separate SSL connection, in which case 2 round trips are an\\n        // absolute minumum.\\n        WebSocketTransport.roundTrips = 2;\\n\\n        module.exports = WebSocketTransport;\\n      }).call(this, { env: {} });\\n    }, { \\\"../utils/event\\\": 46, \\\"../utils/url\\\": 52, \\\"./driver/websocket\\\": 19, \\\"debug\\\": 55, \\\"events\\\": 3, \\\"inherits\\\": 57 }], 39: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          AjaxBasedTransport = require('./lib/ajax-based'),\\n          XdrStreamingTransport = require('./xdr-streaming'),\\n          XhrReceiver = require('./receiver/xhr'),\\n          XDRObject = require('./sender/xdr');\\n\\n      function XdrPollingTransport(transUrl) {\\n        if (!XDRObject.enabled) {\\n          throw new Error('Transport created when disabled');\\n        }\\n        AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);\\n      }\\n\\n      inherits(XdrPollingTransport, AjaxBasedTransport);\\n\\n      XdrPollingTransport.enabled = XdrStreamingTransport.enabled;\\n      XdrPollingTransport.transportName = 'xdr-polling';\\n      XdrPollingTransport.roundTrips = 2; // preflight, ajax\\n\\n      module.exports = XdrPollingTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/xhr\\\": 32, \\\"./sender/xdr\\\": 34, \\\"./xdr-streaming\\\": 40, \\\"inherits\\\": 57 }], 40: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          AjaxBasedTransport = require('./lib/ajax-based'),\\n          XhrReceiver = require('./receiver/xhr'),\\n          XDRObject = require('./sender/xdr');\\n\\n      // According to:\\n      //   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\\n      //   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\\n\\n      function XdrStreamingTransport(transUrl) {\\n        if (!XDRObject.enabled) {\\n          throw new Error('Transport created when disabled');\\n        }\\n        AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\\n      }\\n\\n      inherits(XdrStreamingTransport, AjaxBasedTransport);\\n\\n      XdrStreamingTransport.enabled = function (info) {\\n        if (info.cookie_needed || info.nullOrigin) {\\n          return false;\\n        }\\n        return XDRObject.enabled && info.sameScheme;\\n      };\\n\\n      XdrStreamingTransport.transportName = 'xdr-streaming';\\n      XdrStreamingTransport.roundTrips = 2; // preflight, ajax\\n\\n      module.exports = XdrStreamingTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/xhr\\\": 32, \\\"./sender/xdr\\\": 34, \\\"inherits\\\": 57 }], 41: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          AjaxBasedTransport = require('./lib/ajax-based'),\\n          XhrReceiver = require('./receiver/xhr'),\\n          XHRCorsObject = require('./sender/xhr-cors'),\\n          XHRLocalObject = require('./sender/xhr-local');\\n\\n      function XhrPollingTransport(transUrl) {\\n        if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\\n          throw new Error('Transport created when disabled');\\n        }\\n        AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);\\n      }\\n\\n      inherits(XhrPollingTransport, AjaxBasedTransport);\\n\\n      XhrPollingTransport.enabled = function (info) {\\n        if (info.nullOrigin) {\\n          return false;\\n        }\\n\\n        if (XHRLocalObject.enabled && info.sameOrigin) {\\n          return true;\\n        }\\n        return XHRCorsObject.enabled;\\n      };\\n\\n      XhrPollingTransport.transportName = 'xhr-polling';\\n      XhrPollingTransport.roundTrips = 2; // preflight, ajax\\n\\n      module.exports = XhrPollingTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/xhr\\\": 32, \\\"./sender/xhr-cors\\\": 35, \\\"./sender/xhr-local\\\": 37, \\\"inherits\\\": 57 }], 42: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            AjaxBasedTransport = require('./lib/ajax-based'),\\n            XhrReceiver = require('./receiver/xhr'),\\n            XHRCorsObject = require('./sender/xhr-cors'),\\n            XHRLocalObject = require('./sender/xhr-local'),\\n            browser = require('../utils/browser');\\n\\n        function XhrStreamingTransport(transUrl) {\\n          if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\\n            throw new Error('Transport created when disabled');\\n          }\\n          AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);\\n        }\\n\\n        inherits(XhrStreamingTransport, AjaxBasedTransport);\\n\\n        XhrStreamingTransport.enabled = function (info) {\\n          if (info.nullOrigin) {\\n            return false;\\n          }\\n          // Opera doesn't support xhr-streaming #60\\n          // But it might be able to #92\\n          if (browser.isOpera()) {\\n            return false;\\n          }\\n\\n          return XHRCorsObject.enabled;\\n        };\\n\\n        XhrStreamingTransport.transportName = 'xhr-streaming';\\n        XhrStreamingTransport.roundTrips = 2; // preflight, ajax\\n\\n        // Safari gets confused when a streaming ajax request is started\\n        // before onload. This causes the load indicator to spin indefinetely.\\n        // Only require body when used in a browser\\n        XhrStreamingTransport.needBody = !!global.document;\\n\\n        module.exports = XhrStreamingTransport;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../utils/browser\\\": 44, \\\"./lib/ajax-based\\\": 24, \\\"./receiver/xhr\\\": 32, \\\"./sender/xhr-cors\\\": 35, \\\"./sender/xhr-local\\\": 37, \\\"inherits\\\": 57 }], 43: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        if (global.crypto && global.crypto.getRandomValues) {\\n          module.exports.randomBytes = function (length) {\\n            var bytes = new Uint8Array(length);\\n            global.crypto.getRandomValues(bytes);\\n            return bytes;\\n          };\\n        } else {\\n          module.exports.randomBytes = function (length) {\\n            var bytes = new Array(length);\\n            for (var i = 0; i < length; i++) {\\n              bytes[i] = Math.floor(Math.random() * 256);\\n            }\\n            return bytes;\\n          };\\n        }\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 44: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        module.exports = {\\n          isOpera: function () {\\n            return global.navigator && /opera/i.test(global.navigator.userAgent);\\n          },\\n\\n          isKonqueror: function () {\\n            return global.navigator && /konqueror/i.test(global.navigator.userAgent);\\n          }\\n\\n          // #187 wrap document.domain in try/catch because of WP8 from file:///\\n          , hasDomain: function () {\\n            // non-browser client always has a domain\\n            if (!global.document) {\\n              return true;\\n            }\\n\\n            try {\\n              return !!global.document.domain;\\n            } catch (e) {\\n              return false;\\n            }\\n          }\\n        };\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 45: [function (require, module, exports) {\\n      'use strict';\\n\\n      var JSON3 = require('json3');\\n\\n      // Some extra characters that Chrome gets wrong, and substitutes with\\n      // something else on the wire.\\n      // eslint-disable-next-line no-control-regex\\n      var extraEscapable = /[\\\\x00-\\\\x1f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff\\\\u0300-\\\\u0333\\\\u033d-\\\\u0346\\\\u034a-\\\\u034c\\\\u0350-\\\\u0352\\\\u0357-\\\\u0358\\\\u035c-\\\\u0362\\\\u0374\\\\u037e\\\\u0387\\\\u0591-\\\\u05af\\\\u05c4\\\\u0610-\\\\u0617\\\\u0653-\\\\u0654\\\\u0657-\\\\u065b\\\\u065d-\\\\u065e\\\\u06df-\\\\u06e2\\\\u06eb-\\\\u06ec\\\\u0730\\\\u0732-\\\\u0733\\\\u0735-\\\\u0736\\\\u073a\\\\u073d\\\\u073f-\\\\u0741\\\\u0743\\\\u0745\\\\u0747\\\\u07eb-\\\\u07f1\\\\u0951\\\\u0958-\\\\u095f\\\\u09dc-\\\\u09dd\\\\u09df\\\\u0a33\\\\u0a36\\\\u0a59-\\\\u0a5b\\\\u0a5e\\\\u0b5c-\\\\u0b5d\\\\u0e38-\\\\u0e39\\\\u0f43\\\\u0f4d\\\\u0f52\\\\u0f57\\\\u0f5c\\\\u0f69\\\\u0f72-\\\\u0f76\\\\u0f78\\\\u0f80-\\\\u0f83\\\\u0f93\\\\u0f9d\\\\u0fa2\\\\u0fa7\\\\u0fac\\\\u0fb9\\\\u1939-\\\\u193a\\\\u1a17\\\\u1b6b\\\\u1cda-\\\\u1cdb\\\\u1dc0-\\\\u1dcf\\\\u1dfc\\\\u1dfe\\\\u1f71\\\\u1f73\\\\u1f75\\\\u1f77\\\\u1f79\\\\u1f7b\\\\u1f7d\\\\u1fbb\\\\u1fbe\\\\u1fc9\\\\u1fcb\\\\u1fd3\\\\u1fdb\\\\u1fe3\\\\u1feb\\\\u1fee-\\\\u1fef\\\\u1ff9\\\\u1ffb\\\\u1ffd\\\\u2000-\\\\u2001\\\\u20d0-\\\\u20d1\\\\u20d4-\\\\u20d7\\\\u20e7-\\\\u20e9\\\\u2126\\\\u212a-\\\\u212b\\\\u2329-\\\\u232a\\\\u2adc\\\\u302b-\\\\u302c\\\\uaab2-\\\\uaab3\\\\uf900-\\\\ufa0d\\\\ufa10\\\\ufa12\\\\ufa15-\\\\ufa1e\\\\ufa20\\\\ufa22\\\\ufa25-\\\\ufa26\\\\ufa2a-\\\\ufa2d\\\\ufa30-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb1d\\\\ufb1f\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40-\\\\ufb41\\\\ufb43-\\\\ufb44\\\\ufb46-\\\\ufb4e\\\\ufff0-\\\\uffff]/g,\\n          extraLookup;\\n\\n      // This may be quite slow, so let's delay until user actually uses bad\\n      // characters.\\n      var unrollLookup = function (escapable) {\\n        var i;\\n        var unrolled = {};\\n        var c = [];\\n        for (i = 0; i < 65536; i++) {\\n          c.push(String.fromCharCode(i));\\n        }\\n        escapable.lastIndex = 0;\\n        c.join('').replace(escapable, function (a) {\\n          unrolled[a] = '\\\\\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\\n          return '';\\n        });\\n        escapable.lastIndex = 0;\\n        return unrolled;\\n      };\\n\\n      // Quote string, also taking care of unicode characters that browsers\\n      // often break. Especially, take care of unicode surrogates:\\n      // http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\\n      module.exports = {\\n        quote: function (string) {\\n          var quoted = JSON3.stringify(string);\\n\\n          // In most cases this should be very fast and good enough.\\n          extraEscapable.lastIndex = 0;\\n          if (!extraEscapable.test(quoted)) {\\n            return quoted;\\n          }\\n\\n          if (!extraLookup) {\\n            extraLookup = unrollLookup(extraEscapable);\\n          }\\n\\n          return quoted.replace(extraEscapable, function (a) {\\n            return extraLookup[a];\\n          });\\n        }\\n      };\\n    }, { \\\"json3\\\": 58 }], 46: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var random = require('./random');\\n\\n        var onUnload = {},\\n            afterUnload = false\\n        // detect google chrome packaged apps because they don't allow the 'unload' event\\n        ,\\n            isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime;\\n\\n        module.exports = {\\n          attachEvent: function (event, listener) {\\n            if (typeof global.addEventListener !== 'undefined') {\\n              global.addEventListener(event, listener, false);\\n            } else if (global.document && global.attachEvent) {\\n              // IE quirks.\\n              // According to: http://stevesouders.com/misc/test-postmessage.php\\n              // the message gets delivered only to 'document', not 'window'.\\n              global.document.attachEvent('on' + event, listener);\\n              // I get 'window' for ie8.\\n              global.attachEvent('on' + event, listener);\\n            }\\n          },\\n\\n          detachEvent: function (event, listener) {\\n            if (typeof global.addEventListener !== 'undefined') {\\n              global.removeEventListener(event, listener, false);\\n            } else if (global.document && global.detachEvent) {\\n              global.document.detachEvent('on' + event, listener);\\n              global.detachEvent('on' + event, listener);\\n            }\\n          },\\n\\n          unloadAdd: function (listener) {\\n            if (isChromePackagedApp) {\\n              return null;\\n            }\\n\\n            var ref = random.string(8);\\n            onUnload[ref] = listener;\\n            if (afterUnload) {\\n              setTimeout(this.triggerUnloadCallbacks, 0);\\n            }\\n            return ref;\\n          },\\n\\n          unloadDel: function (ref) {\\n            if (ref in onUnload) {\\n              delete onUnload[ref];\\n            }\\n          },\\n\\n          triggerUnloadCallbacks: function () {\\n            for (var ref in onUnload) {\\n              onUnload[ref]();\\n              delete onUnload[ref];\\n            }\\n          }\\n        };\\n\\n        var unloadTriggered = function () {\\n          if (afterUnload) {\\n            return;\\n          }\\n          afterUnload = true;\\n          module.exports.triggerUnloadCallbacks();\\n        };\\n\\n        // 'unload' alone is not reliable in opera within an iframe, but we\\n        // can't use `beforeunload` as IE fires it on javascript: links.\\n        if (!isChromePackagedApp) {\\n          module.exports.attachEvent('unload', unloadTriggered);\\n        }\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./random\\\": 50 }], 47: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var eventUtils = require('./event'),\\n            JSON3 = require('json3'),\\n            browser = require('./browser');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:utils:iframe');\\n        }\\n\\n        module.exports = {\\n          WPrefix: '_jp',\\n          currentWindowId: null,\\n\\n          polluteGlobalNamespace: function () {\\n            if (!(module.exports.WPrefix in global)) {\\n              global[module.exports.WPrefix] = {};\\n            }\\n          },\\n\\n          postMessage: function (type, data) {\\n            if (global.parent !== global) {\\n              global.parent.postMessage(JSON3.stringify({\\n                windowId: module.exports.currentWindowId,\\n                type: type,\\n                data: data || ''\\n              }), '*');\\n            } else {\\n              debug('Cannot postMessage, no parent window.', type, data);\\n            }\\n          },\\n\\n          createIframe: function (iframeUrl, errorCallback) {\\n            var iframe = global.document.createElement('iframe');\\n            var tref, unloadRef;\\n            var unattach = function () {\\n              debug('unattach');\\n              clearTimeout(tref);\\n              // Explorer had problems with that.\\n              try {\\n                iframe.onload = null;\\n              } catch (x) {\\n                // intentionally empty\\n              }\\n              iframe.onerror = null;\\n            };\\n            var cleanup = function () {\\n              debug('cleanup');\\n              if (iframe) {\\n                unattach();\\n                // This timeout makes chrome fire onbeforeunload event\\n                // within iframe. Without the timeout it goes straight to\\n                // onunload.\\n                setTimeout(function () {\\n                  if (iframe) {\\n                    iframe.parentNode.removeChild(iframe);\\n                  }\\n                  iframe = null;\\n                }, 0);\\n                eventUtils.unloadDel(unloadRef);\\n              }\\n            };\\n            var onerror = function (err) {\\n              debug('onerror', err);\\n              if (iframe) {\\n                cleanup();\\n                errorCallback(err);\\n              }\\n            };\\n            var post = function (msg, origin) {\\n              debug('post', msg, origin);\\n              try {\\n                // When the iframe is not loaded, IE raises an exception\\n                // on 'contentWindow'.\\n                setTimeout(function () {\\n                  if (iframe && iframe.contentWindow) {\\n                    iframe.contentWindow.postMessage(msg, origin);\\n                  }\\n                }, 0);\\n              } catch (x) {\\n                // intentionally empty\\n              }\\n            };\\n\\n            iframe.src = iframeUrl;\\n            iframe.style.display = 'none';\\n            iframe.style.position = 'absolute';\\n            iframe.onerror = function () {\\n              onerror('onerror');\\n            };\\n            iframe.onload = function () {\\n              debug('onload');\\n              // `onload` is triggered before scripts on the iframe are\\n              // executed. Give it few seconds to actually load stuff.\\n              clearTimeout(tref);\\n              tref = setTimeout(function () {\\n                onerror('onload timeout');\\n              }, 2000);\\n            };\\n            global.document.body.appendChild(iframe);\\n            tref = setTimeout(function () {\\n              onerror('timeout');\\n            }, 15000);\\n            unloadRef = eventUtils.unloadAdd(cleanup);\\n            return {\\n              post: post,\\n              cleanup: cleanup,\\n              loaded: unattach\\n            };\\n          }\\n\\n          /* eslint no-undef: \\\"off\\\", new-cap: \\\"off\\\" */\\n          , createHtmlfile: function (iframeUrl, errorCallback) {\\n            var axo = ['Active'].concat('Object').join('X');\\n            var doc = new global[axo]('htmlfile');\\n            var tref, unloadRef;\\n            var iframe;\\n            var unattach = function () {\\n              clearTimeout(tref);\\n              iframe.onerror = null;\\n            };\\n            var cleanup = function () {\\n              if (doc) {\\n                unattach();\\n                eventUtils.unloadDel(unloadRef);\\n                iframe.parentNode.removeChild(iframe);\\n                iframe = doc = null;\\n                CollectGarbage();\\n              }\\n            };\\n            var onerror = function (r) {\\n              debug('onerror', r);\\n              if (doc) {\\n                cleanup();\\n                errorCallback(r);\\n              }\\n            };\\n            var post = function (msg, origin) {\\n              try {\\n                // When the iframe is not loaded, IE raises an exception\\n                // on 'contentWindow'.\\n                setTimeout(function () {\\n                  if (iframe && iframe.contentWindow) {\\n                    iframe.contentWindow.postMessage(msg, origin);\\n                  }\\n                }, 0);\\n              } catch (x) {\\n                // intentionally empty\\n              }\\n            };\\n\\n            doc.open();\\n            doc.write('<html><s' + 'cript>' + 'document.domain=\\\"' + global.document.domain + '\\\";' + '</s' + 'cript></html>');\\n            doc.close();\\n            doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];\\n            var c = doc.createElement('div');\\n            doc.body.appendChild(c);\\n            iframe = doc.createElement('iframe');\\n            c.appendChild(iframe);\\n            iframe.src = iframeUrl;\\n            iframe.onerror = function () {\\n              onerror('onerror');\\n            };\\n            tref = setTimeout(function () {\\n              onerror('timeout');\\n            }, 15000);\\n            unloadRef = eventUtils.unloadAdd(cleanup);\\n            return {\\n              post: post,\\n              cleanup: cleanup,\\n              loaded: unattach\\n            };\\n          }\\n        };\\n\\n        module.exports.iframeEnabled = false;\\n        if (global.document) {\\n          // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\\n          // huge delay, or not at all.\\n          module.exports.iframeEnabled = (typeof global.postMessage === 'function' || typeof global.postMessage === 'object') && !browser.isKonqueror();\\n        }\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./browser\\\": 44, \\\"./event\\\": 46, \\\"debug\\\": 55, \\\"json3\\\": 58 }], 48: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var logObject = {};\\n        ['log', 'debug', 'warn'].forEach(function (level) {\\n          var levelExists;\\n\\n          try {\\n            levelExists = global.console && global.console[level] && global.console[level].apply;\\n          } catch (e) {\\n            // do nothing\\n          }\\n\\n          logObject[level] = levelExists ? function () {\\n            return global.console[level].apply(global.console, arguments);\\n          } : level === 'log' ? function () {} : logObject.log;\\n        });\\n\\n        module.exports = logObject;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 49: [function (require, module, exports) {\\n      'use strict';\\n\\n      module.exports = {\\n        isObject: function (obj) {\\n          var type = typeof obj;\\n          return type === 'function' || type === 'object' && !!obj;\\n        },\\n\\n        extend: function (obj) {\\n          if (!this.isObject(obj)) {\\n            return obj;\\n          }\\n          var source, prop;\\n          for (var i = 1, length = arguments.length; i < length; i++) {\\n            source = arguments[i];\\n            for (prop in source) {\\n              if (Object.prototype.hasOwnProperty.call(source, prop)) {\\n                obj[prop] = source[prop];\\n              }\\n            }\\n          }\\n          return obj;\\n        }\\n      };\\n    }, {}], 50: [function (require, module, exports) {\\n      'use strict';\\n\\n      /* global crypto:true */\\n\\n      var crypto = require('crypto');\\n\\n      // This string has length 32, a power of 2, so the modulus doesn't introduce a\\n      // bias.\\n      var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';\\n      module.exports = {\\n        string: function (length) {\\n          var max = _randomStringChars.length;\\n          var bytes = crypto.randomBytes(length);\\n          var ret = [];\\n          for (var i = 0; i < length; i++) {\\n            ret.push(_randomStringChars.substr(bytes[i] % max, 1));\\n          }\\n          return ret.join('');\\n        },\\n\\n        number: function (max) {\\n          return Math.floor(Math.random() * max);\\n        },\\n\\n        numberString: function (max) {\\n          var t = ('' + (max - 1)).length;\\n          var p = new Array(t + 1).join('0');\\n          return (p + this.number(max)).slice(-t);\\n        }\\n      };\\n    }, { \\\"crypto\\\": 43 }], 51: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:utils:transport');\\n        }\\n\\n        module.exports = function (availableTransports) {\\n          return {\\n            filterToEnabled: function (transportsWhitelist, info) {\\n              var transports = {\\n                main: [],\\n                facade: []\\n              };\\n              if (!transportsWhitelist) {\\n                transportsWhitelist = [];\\n              } else if (typeof transportsWhitelist === 'string') {\\n                transportsWhitelist = [transportsWhitelist];\\n              }\\n\\n              availableTransports.forEach(function (trans) {\\n                if (!trans) {\\n                  return;\\n                }\\n\\n                if (trans.transportName === 'websocket' && info.websocket === false) {\\n                  debug('disabled from server', 'websocket');\\n                  return;\\n                }\\n\\n                if (transportsWhitelist.length && transportsWhitelist.indexOf(trans.transportName) === -1) {\\n                  debug('not in whitelist', trans.transportName);\\n                  return;\\n                }\\n\\n                if (trans.enabled(info)) {\\n                  debug('enabled', trans.transportName);\\n                  transports.main.push(trans);\\n                  if (trans.facadeTransport) {\\n                    transports.facade.push(trans.facadeTransport);\\n                  }\\n                } else {\\n                  debug('disabled', trans.transportName);\\n                }\\n              });\\n              return transports;\\n            }\\n          };\\n        };\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 55 }], 52: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var URL = require('url-parse');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:utils:url');\\n        }\\n\\n        module.exports = {\\n          getOrigin: function (url) {\\n            if (!url) {\\n              return null;\\n            }\\n\\n            var p = new URL(url);\\n            if (p.protocol === 'file:') {\\n              return null;\\n            }\\n\\n            var port = p.port;\\n            if (!port) {\\n              port = p.protocol === 'https:' ? '443' : '80';\\n            }\\n\\n            return p.protocol + '//' + p.hostname + ':' + port;\\n          },\\n\\n          isOriginEqual: function (a, b) {\\n            var res = this.getOrigin(a) === this.getOrigin(b);\\n            debug('same', a, b, res);\\n            return res;\\n          },\\n\\n          isSchemeEqual: function (a, b) {\\n            return a.split(':')[0] === b.split(':')[0];\\n          },\\n\\n          addPath: function (url, path) {\\n            var qs = url.split('?');\\n            return qs[0] + path + (qs[1] ? '?' + qs[1] : '');\\n          },\\n\\n          addQuery: function (url, q) {\\n            return url + (url.indexOf('?') === -1 ? '?' + q : '&' + q);\\n          }\\n        };\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 55, \\\"url-parse\\\": 61 }], 53: [function (require, module, exports) {\\n      module.exports = '1.1.4';\\n    }, {}], 54: [function (require, module, exports) {\\n      /**\\n       * Helpers.\\n       */\\n\\n      var s = 1000;\\n      var m = s * 60;\\n      var h = m * 60;\\n      var d = h * 24;\\n      var y = d * 365.25;\\n\\n      /**\\n       * Parse or format the given `val`.\\n       *\\n       * Options:\\n       *\\n       *  - `long` verbose formatting [false]\\n       *\\n       * @param {String|Number} val\\n       * @param {Object} [options]\\n       * @throws {Error} throw an error if val is not a non-empty string or a number\\n       * @return {String|Number}\\n       * @api public\\n       */\\n\\n      module.exports = function (val, options) {\\n        options = options || {};\\n        var type = typeof val;\\n        if (type === 'string' && val.length > 0) {\\n          return parse(val);\\n        } else if (type === 'number' && isNaN(val) === false) {\\n          return options.long ? fmtLong(val) : fmtShort(val);\\n        }\\n        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\\n      };\\n\\n      /**\\n       * Parse the given `str` and return milliseconds.\\n       *\\n       * @param {String} str\\n       * @return {Number}\\n       * @api private\\n       */\\n\\n      function parse(str) {\\n        str = String(str);\\n        if (str.length > 10000) {\\n          return;\\n        }\\n        var match = /^((?:\\\\d+)?\\\\.?\\\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\\n        if (!match) {\\n          return;\\n        }\\n        var n = parseFloat(match[1]);\\n        var type = (match[2] || 'ms').toLowerCase();\\n        switch (type) {\\n          case 'years':\\n          case 'year':\\n          case 'yrs':\\n          case 'yr':\\n          case 'y':\\n            return n * y;\\n          case 'days':\\n          case 'day':\\n          case 'd':\\n            return n * d;\\n          case 'hours':\\n          case 'hour':\\n          case 'hrs':\\n          case 'hr':\\n          case 'h':\\n            return n * h;\\n          case 'minutes':\\n          case 'minute':\\n          case 'mins':\\n          case 'min':\\n          case 'm':\\n            return n * m;\\n          case 'seconds':\\n          case 'second':\\n          case 'secs':\\n          case 'sec':\\n          case 's':\\n            return n * s;\\n          case 'milliseconds':\\n          case 'millisecond':\\n          case 'msecs':\\n          case 'msec':\\n          case 'ms':\\n            return n;\\n          default:\\n            return undefined;\\n        }\\n      }\\n\\n      /**\\n       * Short format for `ms`.\\n       *\\n       * @param {Number} ms\\n       * @return {String}\\n       * @api private\\n       */\\n\\n      function fmtShort(ms) {\\n        if (ms >= d) {\\n          return Math.round(ms / d) + 'd';\\n        }\\n        if (ms >= h) {\\n          return Math.round(ms / h) + 'h';\\n        }\\n        if (ms >= m) {\\n          return Math.round(ms / m) + 'm';\\n        }\\n        if (ms >= s) {\\n          return Math.round(ms / s) + 's';\\n        }\\n        return ms + 'ms';\\n      }\\n\\n      /**\\n       * Long format for `ms`.\\n       *\\n       * @param {Number} ms\\n       * @return {String}\\n       * @api private\\n       */\\n\\n      function fmtLong(ms) {\\n        return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\\n      }\\n\\n      /**\\n       * Pluralization helper.\\n       */\\n\\n      function plural(ms, n, name) {\\n        if (ms < n) {\\n          return;\\n        }\\n        if (ms < n * 1.5) {\\n          return Math.floor(ms / n) + ' ' + name;\\n        }\\n        return Math.ceil(ms / n) + ' ' + name + 's';\\n      }\\n    }, {}], 55: [function (require, module, exports) {\\n      (function (process) {\\n        /**\\n         * This is the web browser implementation of `debug()`.\\n         *\\n         * Expose `debug()` as the module.\\n         */\\n\\n        exports = module.exports = require('./debug');\\n        exports.log = log;\\n        exports.formatArgs = formatArgs;\\n        exports.save = save;\\n        exports.load = load;\\n        exports.useColors = useColors;\\n        exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\\n\\n        /**\\n         * Colors.\\n         */\\n\\n        exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\\n\\n        /**\\n         * Currently only WebKit-based Web Inspectors, Firefox >= v31,\\n         * and the Firebug extension (any Firefox version) are known\\n         * to support \\\"%c\\\" CSS customizations.\\n         *\\n         * TODO: add a `localStorage` variable to explicitly enable/disable colors\\n         */\\n\\n        function useColors() {\\n          // NB: In an Electron preload script, document will be defined but not fully\\n          // initialized. Since we know we're in Chrome, we'll just detect this case\\n          // explicitly\\n          if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\\n            return true;\\n          }\\n\\n          // is webkit? http://stackoverflow.com/a/16459606/376773\\n          // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\\n          return typeof document !== 'undefined' && document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\\n          // is firebug? http://stackoverflow.com/a/398120/376773\\n          typeof window !== 'undefined' && window && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\\n          // is firefox >= v31?\\n          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\\n          typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\\\/(\\\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\\n          // double check webkit in userAgent just in case we are in a worker\\n          typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\\\/(\\\\d+)/);\\n        }\\n\\n        /**\\n         * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\\n         */\\n\\n        exports.formatters.j = function (v) {\\n          try {\\n            return JSON.stringify(v);\\n          } catch (err) {\\n            return '[UnexpectedJSONParseError]: ' + err.message;\\n          }\\n        };\\n\\n        /**\\n         * Colorize log arguments if enabled.\\n         *\\n         * @api public\\n         */\\n\\n        function formatArgs(args) {\\n          var useColors = this.useColors;\\n\\n          args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\\n\\n          if (!useColors) return;\\n\\n          var c = 'color: ' + this.color;\\n          args.splice(1, 0, c, 'color: inherit');\\n\\n          // the final \\\"%c\\\" is somewhat tricky, because there could be other\\n          // arguments passed either before or after the %c, so we need to\\n          // figure out the correct index to insert the CSS into\\n          var index = 0;\\n          var lastC = 0;\\n          args[0].replace(/%[a-zA-Z%]/g, function (match) {\\n            if ('%%' === match) return;\\n            index++;\\n            if ('%c' === match) {\\n              // we only are interested in the *last* %c\\n              // (the user may have provided their own)\\n              lastC = index;\\n            }\\n          });\\n\\n          args.splice(lastC, 0, c);\\n        }\\n\\n        /**\\n         * Invokes `console.log()` when available.\\n         * No-op when `console.log` is not a \\\"function\\\".\\n         *\\n         * @api public\\n         */\\n\\n        function log() {\\n          // this hackery is required for IE8/9, where\\n          // the `console.log` function doesn't have 'apply'\\n          return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\\n        }\\n\\n        /**\\n         * Save `namespaces`.\\n         *\\n         * @param {String} namespaces\\n         * @api private\\n         */\\n\\n        function save(namespaces) {\\n          try {\\n            if (null == namespaces) {\\n              exports.storage.removeItem('debug');\\n            } else {\\n              exports.storage.debug = namespaces;\\n            }\\n          } catch (e) {}\\n        }\\n\\n        /**\\n         * Load `namespaces`.\\n         *\\n         * @return {String} returns the previously persisted debug modes\\n         * @api private\\n         */\\n\\n        function load() {\\n          var r;\\n          try {\\n            r = exports.storage.debug;\\n          } catch (e) {}\\n\\n          // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\\n          if (!r && typeof process !== 'undefined' && 'env' in process) {\\n            r = process.env.DEBUG;\\n          }\\n\\n          return r;\\n        }\\n\\n        /**\\n         * Enable namespaces listed in `localStorage.debug` initially.\\n         */\\n\\n        exports.enable(load());\\n\\n        /**\\n         * Localstorage attempts to return the localstorage.\\n         *\\n         * This is necessary because safari throws\\n         * when a user disables cookies/localstorage\\n         * and you attempt to access it.\\n         *\\n         * @return {LocalStorage}\\n         * @api private\\n         */\\n\\n        function localstorage() {\\n          try {\\n            return window.localStorage;\\n          } catch (e) {}\\n        }\\n      }).call(this, { env: {} });\\n    }, { \\\"./debug\\\": 56 }], 56: [function (require, module, exports) {\\n\\n      /**\\n       * This is the common logic for both the Node.js and web browser\\n       * implementations of `debug()`.\\n       *\\n       * Expose `debug()` as the module.\\n       */\\n\\n      exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\\n      exports.coerce = coerce;\\n      exports.disable = disable;\\n      exports.enable = enable;\\n      exports.enabled = enabled;\\n      exports.humanize = require('ms');\\n\\n      /**\\n       * The currently active debug mode names, and names to skip.\\n       */\\n\\n      exports.names = [];\\n      exports.skips = [];\\n\\n      /**\\n       * Map of special \\\"%n\\\" handling functions, for the debug \\\"format\\\" argument.\\n       *\\n       * Valid key names are a single, lower or upper-case letter, i.e. \\\"n\\\" and \\\"N\\\".\\n       */\\n\\n      exports.formatters = {};\\n\\n      /**\\n       * Previous log timestamp.\\n       */\\n\\n      var prevTime;\\n\\n      /**\\n       * Select a color.\\n       * @param {String} namespace\\n       * @return {Number}\\n       * @api private\\n       */\\n\\n      function selectColor(namespace) {\\n        var hash = 0,\\n            i;\\n\\n        for (i in namespace) {\\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\\n          hash |= 0; // Convert to 32bit integer\\n        }\\n\\n        return exports.colors[Math.abs(hash) % exports.colors.length];\\n      }\\n\\n      /**\\n       * Create a debugger with the given `namespace`.\\n       *\\n       * @param {String} namespace\\n       * @return {Function}\\n       * @api public\\n       */\\n\\n      function createDebug(namespace) {\\n\\n        function debug() {\\n          // disabled?\\n          if (!debug.enabled) return;\\n\\n          var self = debug;\\n\\n          // set `diff` timestamp\\n          var curr = +new Date();\\n          var ms = curr - (prevTime || curr);\\n          self.diff = ms;\\n          self.prev = prevTime;\\n          self.curr = curr;\\n          prevTime = curr;\\n\\n          // turn the `arguments` into a proper Array\\n          var args = new Array(arguments.length);\\n          for (var i = 0; i < args.length; i++) {\\n            args[i] = arguments[i];\\n          }\\n\\n          args[0] = exports.coerce(args[0]);\\n\\n          if ('string' !== typeof args[0]) {\\n            // anything else let's inspect with %O\\n            args.unshift('%O');\\n          }\\n\\n          // apply any `formatters` transformations\\n          var index = 0;\\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\\n            // if we encounter an escaped % then don't increase the array index\\n            if (match === '%%') return match;\\n            index++;\\n            var formatter = exports.formatters[format];\\n            if ('function' === typeof formatter) {\\n              var val = args[index];\\n              match = formatter.call(self, val);\\n\\n              // now we need to remove `args[index]` since it's inlined in the `format`\\n              args.splice(index, 1);\\n              index--;\\n            }\\n            return match;\\n          });\\n\\n          // apply env-specific formatting (colors, etc.)\\n          exports.formatArgs.call(self, args);\\n\\n          var logFn = debug.log || exports.log || console.log.bind(console);\\n          logFn.apply(self, args);\\n        }\\n\\n        debug.namespace = namespace;\\n        debug.enabled = exports.enabled(namespace);\\n        debug.useColors = exports.useColors();\\n        debug.color = selectColor(namespace);\\n\\n        // env-specific initialization logic for debug instances\\n        if ('function' === typeof exports.init) {\\n          exports.init(debug);\\n        }\\n\\n        return debug;\\n      }\\n\\n      /**\\n       * Enables a debug mode by namespaces. This can include modes\\n       * separated by a colon and wildcards.\\n       *\\n       * @param {String} namespaces\\n       * @api public\\n       */\\n\\n      function enable(namespaces) {\\n        exports.save(namespaces);\\n\\n        exports.names = [];\\n        exports.skips = [];\\n\\n        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\\\s,]+/);\\n        var len = split.length;\\n\\n        for (var i = 0; i < len; i++) {\\n          if (!split[i]) continue; // ignore empty strings\\n          namespaces = split[i].replace(/\\\\*/g, '.*?');\\n          if (namespaces[0] === '-') {\\n            exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\\n          } else {\\n            exports.names.push(new RegExp('^' + namespaces + '$'));\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Disable debug output.\\n       *\\n       * @api public\\n       */\\n\\n      function disable() {\\n        exports.enable('');\\n      }\\n\\n      /**\\n       * Returns true if the given mode name is enabled, false otherwise.\\n       *\\n       * @param {String} name\\n       * @return {Boolean}\\n       * @api public\\n       */\\n\\n      function enabled(name) {\\n        var i, len;\\n        for (i = 0, len = exports.skips.length; i < len; i++) {\\n          if (exports.skips[i].test(name)) {\\n            return false;\\n          }\\n        }\\n        for (i = 0, len = exports.names.length; i < len; i++) {\\n          if (exports.names[i].test(name)) {\\n            return true;\\n          }\\n        }\\n        return false;\\n      }\\n\\n      /**\\n       * Coerce `val`.\\n       *\\n       * @param {Mixed} val\\n       * @return {Mixed}\\n       * @api private\\n       */\\n\\n      function coerce(val) {\\n        if (val instanceof Error) return val.stack || val.message;\\n        return val;\\n      }\\n    }, { \\\"ms\\\": 54 }], 57: [function (require, module, exports) {\\n      if (typeof Object.create === 'function') {\\n        // implementation from standard node.js 'util' module\\n        module.exports = function inherits(ctor, superCtor) {\\n          ctor.super_ = superCtor;\\n          ctor.prototype = Object.create(superCtor.prototype, {\\n            constructor: {\\n              value: ctor,\\n              enumerable: false,\\n              writable: true,\\n              configurable: true\\n            }\\n          });\\n        };\\n      } else {\\n        // old school shim for old browsers\\n        module.exports = function inherits(ctor, superCtor) {\\n          ctor.super_ = superCtor;\\n          var TempCtor = function () {};\\n          TempCtor.prototype = superCtor.prototype;\\n          ctor.prototype = new TempCtor();\\n          ctor.prototype.constructor = ctor;\\n        };\\n      }\\n    }, {}], 58: [function (require, module, exports) {\\n      (function (global) {\\n        /*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\\n        ;(function () {\\n          // Detect the `define` function exposed by asynchronous module loaders. The\\n          // strict `define` check is necessary for compatibility with `r.js`.\\n          var isLoader = typeof define === \\\"function\\\" && define.amd;\\n\\n          // A set of types used to distinguish objects from primitives.\\n          var objectTypes = {\\n            \\\"function\\\": true,\\n            \\\"object\\\": true\\n          };\\n\\n          // Detect the `exports` object exposed by CommonJS implementations.\\n          var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\\n\\n          // Use the `global` object exposed by Node (including Browserify via\\n          // `insert-module-globals`), Narwhal, and Ringo as the default context,\\n          // and the `window` object in browsers. Rhino exports a `global` function\\n          // instead.\\n          var root = objectTypes[typeof window] && window || this,\\n              freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \\\"object\\\" && global;\\n\\n          if (freeGlobal && (freeGlobal[\\\"global\\\"] === freeGlobal || freeGlobal[\\\"window\\\"] === freeGlobal || freeGlobal[\\\"self\\\"] === freeGlobal)) {\\n            root = freeGlobal;\\n          }\\n\\n          // Public: Initializes JSON 3 using the given `context` object, attaching the\\n          // `stringify` and `parse` functions to the specified `exports` object.\\n          function runInContext(context, exports) {\\n            context || (context = root[\\\"Object\\\"]());\\n            exports || (exports = root[\\\"Object\\\"]());\\n\\n            // Native constructor aliases.\\n            var Number = context[\\\"Number\\\"] || root[\\\"Number\\\"],\\n                String = context[\\\"String\\\"] || root[\\\"String\\\"],\\n                Object = context[\\\"Object\\\"] || root[\\\"Object\\\"],\\n                Date = context[\\\"Date\\\"] || root[\\\"Date\\\"],\\n                SyntaxError = context[\\\"SyntaxError\\\"] || root[\\\"SyntaxError\\\"],\\n                TypeError = context[\\\"TypeError\\\"] || root[\\\"TypeError\\\"],\\n                Math = context[\\\"Math\\\"] || root[\\\"Math\\\"],\\n                nativeJSON = context[\\\"JSON\\\"] || root[\\\"JSON\\\"];\\n\\n            // Delegate to the native `stringify` and `parse` implementations.\\n            if (typeof nativeJSON == \\\"object\\\" && nativeJSON) {\\n              exports.stringify = nativeJSON.stringify;\\n              exports.parse = nativeJSON.parse;\\n            }\\n\\n            // Convenience aliases.\\n            var objectProto = Object.prototype,\\n                getClass = objectProto.toString,\\n                isProperty,\\n                forEach,\\n                undef;\\n\\n            // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\\n            var isExtended = new Date(-3509827334573292);\\n            try {\\n              // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\\n              // results for certain dates in Opera >= 10.53.\\n              isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\\n              // Safari < 2.0.2 stores the internal millisecond time value correctly,\\n              // but clips the values returned by the date methods to the range of\\n              // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\\n              isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\\n            } catch (exception) {}\\n\\n            // Internal: Determines whether the native `JSON.stringify` and `parse`\\n            // implementations are spec-compliant. Based on work by Ken Snyder.\\n            function has(name) {\\n              if (has[name] !== undef) {\\n                // Return cached feature test result.\\n                return has[name];\\n              }\\n              var isSupported;\\n              if (name == \\\"bug-string-char-index\\\") {\\n                // IE <= 7 doesn't support accessing string characters using square\\n                // bracket notation. IE 8 only supports this for primitives.\\n                isSupported = \\\"a\\\"[0] != \\\"a\\\";\\n              } else if (name == \\\"json\\\") {\\n                // Indicates whether both `JSON.stringify` and `JSON.parse` are\\n                // supported.\\n                isSupported = has(\\\"json-stringify\\\") && has(\\\"json-parse\\\");\\n              } else {\\n                var value,\\n                    serialized = '{\\\"a\\\":[1,true,false,null,\\\"\\\\\\\\u0000\\\\\\\\b\\\\\\\\n\\\\\\\\f\\\\\\\\r\\\\\\\\t\\\"]}';\\n                // Test `JSON.stringify`.\\n                if (name == \\\"json-stringify\\\") {\\n                  var stringify = exports.stringify,\\n                      stringifySupported = typeof stringify == \\\"function\\\" && isExtended;\\n                  if (stringifySupported) {\\n                    // A test function object with a custom `toJSON` method.\\n                    (value = function () {\\n                      return 1;\\n                    }).toJSON = value;\\n                    try {\\n                      stringifySupported =\\n                      // Firefox 3.1b1 and b2 serialize string, number, and boolean\\n                      // primitives as object literals.\\n                      stringify(0) === \\\"0\\\" &&\\n                      // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\\n                      // literals.\\n                      stringify(new Number()) === \\\"0\\\" && stringify(new String()) == '\\\"\\\"' &&\\n                      // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\\n                      // does not define a canonical JSON representation (this applies to\\n                      // objects with `toJSON` properties as well, *unless* they are nested\\n                      // within an object or array).\\n                      stringify(getClass) === undef &&\\n                      // IE 8 serializes `undefined` as `\\\"undefined\\\"`. Safari <= 5.1.7 and\\n                      // FF 3.1b3 pass this test.\\n                      stringify(undef) === undef &&\\n                      // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\\n                      // respectively, if the value is omitted entirely.\\n                      stringify() === undef &&\\n                      // FF 3.1b1, 2 throw an error if the given value is not a number,\\n                      // string, array, object, Boolean, or `null` literal. This applies to\\n                      // objects with custom `toJSON` methods as well, unless they are nested\\n                      // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\\n                      // methods entirely.\\n                      stringify(value) === \\\"1\\\" && stringify([value]) == \\\"[1]\\\" &&\\n                      // Prototype <= 1.6.1 serializes `[undefined]` as `\\\"[]\\\"` instead of\\n                      // `\\\"[null]\\\"`.\\n                      stringify([undef]) == \\\"[null]\\\" &&\\n                      // YUI 3.0.0b1 fails to serialize `null` literals.\\n                      stringify(null) == \\\"null\\\" &&\\n                      // FF 3.1b1, 2 halts serialization if an array contains a function:\\n                      // `[1, true, getClass, 1]` serializes as \\\"[1,true,],\\\". FF 3.1b3\\n                      // elides non-JSON values from objects and arrays, unless they\\n                      // define custom `toJSON` methods.\\n                      stringify([undef, getClass, null]) == \\\"[null,null,null]\\\" &&\\n                      // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\\n                      // where character escape codes are expected (e.g., `\\\\b` => `\\\\u0008`).\\n                      stringify({ \\\"a\\\": [value, true, false, null, \\\"\\\\x00\\\\b\\\\n\\\\f\\\\r\\\\t\\\"] }) == serialized &&\\n                      // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\\n                      stringify(null, value) === \\\"1\\\" && stringify([1, 2], null, 1) == \\\"[\\\\n 1,\\\\n 2\\\\n]\\\" &&\\n                      // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\\n                      // serialize extended years.\\n                      stringify(new Date(-8.64e15)) == '\\\"-271821-04-20T00:00:00.000Z\\\"' &&\\n                      // The milliseconds are optional in ES 5, but required in 5.1.\\n                      stringify(new Date(8.64e15)) == '\\\"+275760-09-13T00:00:00.000Z\\\"' &&\\n                      // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\\n                      // four-digit years instead of six-digit years. Credits: @Yaffle.\\n                      stringify(new Date(-621987552e5)) == '\\\"-000001-01-01T00:00:00.000Z\\\"' &&\\n                      // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\\n                      // values less than 1000. Credits: @Yaffle.\\n                      stringify(new Date(-1)) == '\\\"1969-12-31T23:59:59.999Z\\\"';\\n                    } catch (exception) {\\n                      stringifySupported = false;\\n                    }\\n                  }\\n                  isSupported = stringifySupported;\\n                }\\n                // Test `JSON.parse`.\\n                if (name == \\\"json-parse\\\") {\\n                  var parse = exports.parse;\\n                  if (typeof parse == \\\"function\\\") {\\n                    try {\\n                      // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\\n                      // Conforming implementations should also coerce the initial argument to\\n                      // a string prior to parsing.\\n                      if (parse(\\\"0\\\") === 0 && !parse(false)) {\\n                        // Simple parsing test.\\n                        value = parse(serialized);\\n                        var parseSupported = value[\\\"a\\\"].length == 5 && value[\\\"a\\\"][0] === 1;\\n                        if (parseSupported) {\\n                          try {\\n                            // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\\n                            parseSupported = !parse('\\\"\\\\t\\\"');\\n                          } catch (exception) {}\\n                          if (parseSupported) {\\n                            try {\\n                              // FF 4.0 and 4.0.1 allow leading `+` signs and leading\\n                              // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\\n                              // certain octal literals.\\n                              parseSupported = parse(\\\"01\\\") !== 1;\\n                            } catch (exception) {}\\n                          }\\n                          if (parseSupported) {\\n                            try {\\n                              // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\\n                              // points. These environments, along with FF 3.1b1 and 2,\\n                              // also allow trailing commas in JSON objects and arrays.\\n                              parseSupported = parse(\\\"1.\\\") !== 1;\\n                            } catch (exception) {}\\n                          }\\n                        }\\n                      }\\n                    } catch (exception) {\\n                      parseSupported = false;\\n                    }\\n                  }\\n                  isSupported = parseSupported;\\n                }\\n              }\\n              return has[name] = !!isSupported;\\n            }\\n\\n            if (!has(\\\"json\\\")) {\\n              // Common `[[Class]]` name aliases.\\n              var functionClass = \\\"[object Function]\\\",\\n                  dateClass = \\\"[object Date]\\\",\\n                  numberClass = \\\"[object Number]\\\",\\n                  stringClass = \\\"[object String]\\\",\\n                  arrayClass = \\\"[object Array]\\\",\\n                  booleanClass = \\\"[object Boolean]\\\";\\n\\n              // Detect incomplete support for accessing string characters by index.\\n              var charIndexBuggy = has(\\\"bug-string-char-index\\\");\\n\\n              // Define additional utility methods if the `Date` methods are buggy.\\n              if (!isExtended) {\\n                var floor = Math.floor;\\n                // A mapping between the months of the year and the number of days between\\n                // January 1st and the first of the respective month.\\n                var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\\n                // Internal: Calculates the number of days between the Unix epoch and the\\n                // first day of the given month.\\n                var getDay = function (year, month) {\\n                  return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\\n                };\\n              }\\n\\n              // Internal: Determines if a property is a direct property of the given\\n              // object. Delegates to the native `Object#hasOwnProperty` method.\\n              if (!(isProperty = objectProto.hasOwnProperty)) {\\n                isProperty = function (property) {\\n                  var members = {},\\n                      constructor;\\n                  if ((members.__proto__ = null, members.__proto__ = {\\n                    // The *proto* property cannot be set multiple times in recent\\n                    // versions of Firefox and SeaMonkey.\\n                    \\\"toString\\\": 1\\n                  }, members).toString != getClass) {\\n                    // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\\n                    // supports the mutable *proto* property.\\n                    isProperty = function (property) {\\n                      // Capture and break the object's prototype chain (see section 8.6.2\\n                      // of the ES 5.1 spec). The parenthesized expression prevents an\\n                      // unsafe transformation by the Closure Compiler.\\n                      var original = this.__proto__,\\n                          result = property in (this.__proto__ = null, this);\\n                      // Restore the original prototype chain.\\n                      this.__proto__ = original;\\n                      return result;\\n                    };\\n                  } else {\\n                    // Capture a reference to the top-level `Object` constructor.\\n                    constructor = members.constructor;\\n                    // Use the `constructor` property to simulate `Object#hasOwnProperty` in\\n                    // other environments.\\n                    isProperty = function (property) {\\n                      var parent = (this.constructor || constructor).prototype;\\n                      return property in this && !(property in parent && this[property] === parent[property]);\\n                    };\\n                  }\\n                  members = null;\\n                  return isProperty.call(this, property);\\n                };\\n              }\\n\\n              // Internal: Normalizes the `for...in` iteration algorithm across\\n              // environments. Each enumerated key is yielded to a `callback` function.\\n              forEach = function (object, callback) {\\n                var size = 0,\\n                    Properties,\\n                    members,\\n                    property;\\n\\n                // Tests for bugs in the current environment's `for...in` algorithm. The\\n                // `valueOf` property inherits the non-enumerable flag from\\n                // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\\n                (Properties = function () {\\n                  this.valueOf = 0;\\n                }).prototype.valueOf = 0;\\n\\n                // Iterate over a new instance of the `Properties` class.\\n                members = new Properties();\\n                for (property in members) {\\n                  // Ignore all properties inherited from `Object.prototype`.\\n                  if (isProperty.call(members, property)) {\\n                    size++;\\n                  }\\n                }\\n                Properties = members = null;\\n\\n                // Normalize the iteration algorithm.\\n                if (!size) {\\n                  // A list of non-enumerable properties inherited from `Object.prototype`.\\n                  members = [\\\"valueOf\\\", \\\"toString\\\", \\\"toLocaleString\\\", \\\"propertyIsEnumerable\\\", \\\"isPrototypeOf\\\", \\\"hasOwnProperty\\\", \\\"constructor\\\"];\\n                  // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\\n                  // properties.\\n                  forEach = function (object, callback) {\\n                    var isFunction = getClass.call(object) == functionClass,\\n                        property,\\n                        length;\\n                    var hasProperty = !isFunction && typeof object.constructor != \\\"function\\\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\\n                    for (property in object) {\\n                      // Gecko <= 1.0 enumerates the `prototype` property of functions under\\n                      // certain conditions; IE does not.\\n                      if (!(isFunction && property == \\\"prototype\\\") && hasProperty.call(object, property)) {\\n                        callback(property);\\n                      }\\n                    }\\n                    // Manually invoke the callback for each non-enumerable property.\\n                    for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\\n                  };\\n                } else if (size == 2) {\\n                  // Safari <= 2.0.4 enumerates shadowed properties twice.\\n                  forEach = function (object, callback) {\\n                    // Create a set of iterated properties.\\n                    var members = {},\\n                        isFunction = getClass.call(object) == functionClass,\\n                        property;\\n                    for (property in object) {\\n                      // Store each property name to prevent double enumeration. The\\n                      // `prototype` property of functions is not enumerated due to cross-\\n                      // environment inconsistencies.\\n                      if (!(isFunction && property == \\\"prototype\\\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\\n                        callback(property);\\n                      }\\n                    }\\n                  };\\n                } else {\\n                  // No bugs detected; use the standard `for...in` algorithm.\\n                  forEach = function (object, callback) {\\n                    var isFunction = getClass.call(object) == functionClass,\\n                        property,\\n                        isConstructor;\\n                    for (property in object) {\\n                      if (!(isFunction && property == \\\"prototype\\\") && isProperty.call(object, property) && !(isConstructor = property === \\\"constructor\\\")) {\\n                        callback(property);\\n                      }\\n                    }\\n                    // Manually invoke the callback for the `constructor` property due to\\n                    // cross-environment inconsistencies.\\n                    if (isConstructor || isProperty.call(object, property = \\\"constructor\\\")) {\\n                      callback(property);\\n                    }\\n                  };\\n                }\\n                return forEach(object, callback);\\n              };\\n\\n              // Public: Serializes a JavaScript `value` as a JSON string. The optional\\n              // `filter` argument may specify either a function that alters how object and\\n              // array members are serialized, or an array of strings and numbers that\\n              // indicates which properties should be serialized. The optional `width`\\n              // argument may be either a string or number that specifies the indentation\\n              // level of the output.\\n              if (!has(\\\"json-stringify\\\")) {\\n                // Internal: A map of control characters and their escaped equivalents.\\n                var Escapes = {\\n                  92: \\\"\\\\\\\\\\\\\\\\\\\",\\n                  34: '\\\\\\\\\\\"',\\n                  8: \\\"\\\\\\\\b\\\",\\n                  12: \\\"\\\\\\\\f\\\",\\n                  10: \\\"\\\\\\\\n\\\",\\n                  13: \\\"\\\\\\\\r\\\",\\n                  9: \\\"\\\\\\\\t\\\"\\n                };\\n\\n                // Internal: Converts `value` into a zero-padded string such that its\\n                // length is at least equal to `width`. The `width` must be <= 6.\\n                var leadingZeroes = \\\"000000\\\";\\n                var toPaddedString = function (width, value) {\\n                  // The `|| 0` expression is necessary to work around a bug in\\n                  // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \\\"0\\\"`.\\n                  return (leadingZeroes + (value || 0)).slice(-width);\\n                };\\n\\n                // Internal: Double-quotes a string `value`, replacing all ASCII control\\n                // characters (characters with code unit values between 0 and 31) with\\n                // their escaped equivalents. This is an implementation of the\\n                // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\\n                var unicodePrefix = \\\"\\\\\\\\u00\\\";\\n                var quote = function (value) {\\n                  var result = '\\\"',\\n                      index = 0,\\n                      length = value.length,\\n                      useCharIndex = !charIndexBuggy || length > 10;\\n                  var symbols = useCharIndex && (charIndexBuggy ? value.split(\\\"\\\") : value);\\n                  for (; index < length; index++) {\\n                    var charCode = value.charCodeAt(index);\\n                    // If the character is a control character, append its Unicode or\\n                    // shorthand escape sequence; otherwise, append the character as-is.\\n                    switch (charCode) {\\n                      case 8:case 9:case 10:case 12:case 13:case 34:case 92:\\n                        result += Escapes[charCode];\\n                        break;\\n                      default:\\n                        if (charCode < 32) {\\n                          result += unicodePrefix + toPaddedString(2, charCode.toString(16));\\n                          break;\\n                        }\\n                        result += useCharIndex ? symbols[index] : value.charAt(index);\\n                    }\\n                  }\\n                  return result + '\\\"';\\n                };\\n\\n                // Internal: Recursively serializes an object. Implements the\\n                // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\\n                var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\\n                  var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\\n                  try {\\n                    // Necessary for host object support.\\n                    value = object[property];\\n                  } catch (exception) {}\\n                  if (typeof value == \\\"object\\\" && value) {\\n                    className = getClass.call(value);\\n                    if (className == dateClass && !isProperty.call(value, \\\"toJSON\\\")) {\\n                      if (value > -1 / 0 && value < 1 / 0) {\\n                        // Dates are serialized according to the `Date#toJSON` method\\n                        // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\\n                        // for the ISO 8601 date time string format.\\n                        if (getDay) {\\n                          // Manually compute the year, month, date, hours, minutes,\\n                          // seconds, and milliseconds if the `getUTC*` methods are\\n                          // buggy. Adapted from @Yaffle's `date-shim` project.\\n                          date = floor(value / 864e5);\\n                          for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\\n                          for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\\n                          date = 1 + date - getDay(year, month);\\n                          // The `time` value specifies the time within the day (see ES\\n                          // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\\n                          // to compute `A modulo B`, as the `%` operator does not\\n                          // correspond to the `modulo` operation for negative numbers.\\n                          time = (value % 864e5 + 864e5) % 864e5;\\n                          // The hours, minutes, seconds, and milliseconds are obtained by\\n                          // decomposing the time within the day. See section 15.9.1.10.\\n                          hours = floor(time / 36e5) % 24;\\n                          minutes = floor(time / 6e4) % 60;\\n                          seconds = floor(time / 1e3) % 60;\\n                          milliseconds = time % 1e3;\\n                        } else {\\n                          year = value.getUTCFullYear();\\n                          month = value.getUTCMonth();\\n                          date = value.getUTCDate();\\n                          hours = value.getUTCHours();\\n                          minutes = value.getUTCMinutes();\\n                          seconds = value.getUTCSeconds();\\n                          milliseconds = value.getUTCMilliseconds();\\n                        }\\n                        // Serialize extended years correctly.\\n                        value = (year <= 0 || year >= 1e4 ? (year < 0 ? \\\"-\\\" : \\\"+\\\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + \\\"-\\\" + toPaddedString(2, month + 1) + \\\"-\\\" + toPaddedString(2, date) +\\n                        // Months, dates, hours, minutes, and seconds should have two\\n                        // digits; milliseconds should have three.\\n                        \\\"T\\\" + toPaddedString(2, hours) + \\\":\\\" + toPaddedString(2, minutes) + \\\":\\\" + toPaddedString(2, seconds) +\\n                        // Milliseconds are optional in ES 5.0, but required in 5.1.\\n                        \\\".\\\" + toPaddedString(3, milliseconds) + \\\"Z\\\";\\n                      } else {\\n                        value = null;\\n                      }\\n                    } else if (typeof value.toJSON == \\\"function\\\" && (className != numberClass && className != stringClass && className != arrayClass || isProperty.call(value, \\\"toJSON\\\"))) {\\n                      // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\\n                      // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\\n                      // ignores all `toJSON` methods on these objects unless they are\\n                      // defined directly on an instance.\\n                      value = value.toJSON(property);\\n                    }\\n                  }\\n                  if (callback) {\\n                    // If a replacement function was provided, call it to obtain the value\\n                    // for serialization.\\n                    value = callback.call(object, property, value);\\n                  }\\n                  if (value === null) {\\n                    return \\\"null\\\";\\n                  }\\n                  className = getClass.call(value);\\n                  if (className == booleanClass) {\\n                    // Booleans are represented literally.\\n                    return \\\"\\\" + value;\\n                  } else if (className == numberClass) {\\n                    // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\\n                    // `\\\"null\\\"`.\\n                    return value > -1 / 0 && value < 1 / 0 ? \\\"\\\" + value : \\\"null\\\";\\n                  } else if (className == stringClass) {\\n                    // Strings are double-quoted and escaped.\\n                    return quote(\\\"\\\" + value);\\n                  }\\n                  // Recursively serialize objects and arrays.\\n                  if (typeof value == \\\"object\\\") {\\n                    // Check for cyclic structures. This is a linear search; performance\\n                    // is inversely proportional to the number of unique nested objects.\\n                    for (length = stack.length; length--;) {\\n                      if (stack[length] === value) {\\n                        // Cyclic structures cannot be serialized by `JSON.stringify`.\\n                        throw TypeError();\\n                      }\\n                    }\\n                    // Add the object to the stack of traversed objects.\\n                    stack.push(value);\\n                    results = [];\\n                    // Save the current indentation level and indent one additional level.\\n                    prefix = indentation;\\n                    indentation += whitespace;\\n                    if (className == arrayClass) {\\n                      // Recursively serialize array elements.\\n                      for (index = 0, length = value.length; index < length; index++) {\\n                        element = serialize(index, value, callback, properties, whitespace, indentation, stack);\\n                        results.push(element === undef ? \\\"null\\\" : element);\\n                      }\\n                      result = results.length ? whitespace ? \\\"[\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"]\\\" : \\\"[\\\" + results.join(\\\",\\\") + \\\"]\\\" : \\\"[]\\\";\\n                    } else {\\n                      // Recursively serialize object members. Members are selected from\\n                      // either a user-specified list of property names, or the object\\n                      // itself.\\n                      forEach(properties || value, function (property) {\\n                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\\n                        if (element !== undef) {\\n                          // According to ES 5.1 section 15.12.3: \\\"If `gap` {whitespace}\\n                          // is not the empty string, let `member` {quote(property) + \\\":\\\"}\\n                          // be the concatenation of `member` and the `space` character.\\\"\\n                          // The \\\"`space` character\\\" refers to the literal space\\n                          // character, not the `space` {width} argument provided to\\n                          // `JSON.stringify`.\\n                          results.push(quote(property) + \\\":\\\" + (whitespace ? \\\" \\\" : \\\"\\\") + element);\\n                        }\\n                      });\\n                      result = results.length ? whitespace ? \\\"{\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"}\\\" : \\\"{\\\" + results.join(\\\",\\\") + \\\"}\\\" : \\\"{}\\\";\\n                    }\\n                    // Remove the object from the traversed object stack.\\n                    stack.pop();\\n                    return result;\\n                  }\\n                };\\n\\n                // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\\n                exports.stringify = function (source, filter, width) {\\n                  var whitespace, callback, properties, className;\\n                  if (objectTypes[typeof filter] && filter) {\\n                    if ((className = getClass.call(filter)) == functionClass) {\\n                      callback = filter;\\n                    } else if (className == arrayClass) {\\n                      // Convert the property names array into a makeshift set.\\n                      properties = {};\\n                      for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1));\\n                    }\\n                  }\\n                  if (width) {\\n                    if ((className = getClass.call(width)) == numberClass) {\\n                      // Convert the `width` to an integer and create a string containing\\n                      // `width` number of space characters.\\n                      if ((width -= width % 1) > 0) {\\n                        for (whitespace = \\\"\\\", width > 10 && (width = 10); whitespace.length < width; whitespace += \\\" \\\");\\n                      }\\n                    } else if (className == stringClass) {\\n                      whitespace = width.length <= 10 ? width : width.slice(0, 10);\\n                    }\\n                  }\\n                  // Opera <= 7.54u2 discards the values associated with empty string keys\\n                  // (`\\\"\\\"`) only if they are used directly within an object member list\\n                  // (e.g., `!(\\\"\\\" in { \\\"\\\": 1})`).\\n                  return serialize(\\\"\\\", (value = {}, value[\\\"\\\"] = source, value), callback, properties, whitespace, \\\"\\\", []);\\n                };\\n              }\\n\\n              // Public: Parses a JSON source string.\\n              if (!has(\\\"json-parse\\\")) {\\n                var fromCharCode = String.fromCharCode;\\n\\n                // Internal: A map of escaped control characters and their unescaped\\n                // equivalents.\\n                var Unescapes = {\\n                  92: \\\"\\\\\\\\\\\",\\n                  34: '\\\"',\\n                  47: \\\"/\\\",\\n                  98: \\\"\\\\b\\\",\\n                  116: \\\"\\\\t\\\",\\n                  110: \\\"\\\\n\\\",\\n                  102: \\\"\\\\f\\\",\\n                  114: \\\"\\\\r\\\"\\n                };\\n\\n                // Internal: Stores the parser state.\\n                var Index, Source;\\n\\n                // Internal: Resets the parser state and throws a `SyntaxError`.\\n                var abort = function () {\\n                  Index = Source = null;\\n                  throw SyntaxError();\\n                };\\n\\n                // Internal: Returns the next token, or `\\\"$\\\"` if the parser has reached\\n                // the end of the source string. A token may be a string, number, `null`\\n                // literal, or Boolean literal.\\n                var lex = function () {\\n                  var source = Source,\\n                      length = source.length,\\n                      value,\\n                      begin,\\n                      position,\\n                      isSigned,\\n                      charCode;\\n                  while (Index < length) {\\n                    charCode = source.charCodeAt(Index);\\n                    switch (charCode) {\\n                      case 9:case 10:case 13:case 32:\\n                        // Skip whitespace tokens, including tabs, carriage returns, line\\n                        // feeds, and space characters.\\n                        Index++;\\n                        break;\\n                      case 123:case 125:case 91:case 93:case 58:case 44:\\n                        // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\\n                        // the current position.\\n                        value = charIndexBuggy ? source.charAt(Index) : source[Index];\\n                        Index++;\\n                        return value;\\n                      case 34:\\n                        // `\\\"` delimits a JSON string; advance to the next character and\\n                        // begin parsing the string. String tokens are prefixed with the\\n                        // sentinel `@` character to distinguish them from punctuators and\\n                        // end-of-string tokens.\\n                        for (value = \\\"@\\\", Index++; Index < length;) {\\n                          charCode = source.charCodeAt(Index);\\n                          if (charCode < 32) {\\n                            // Unescaped ASCII control characters (those with a code unit\\n                            // less than the space character) are not permitted.\\n                            abort();\\n                          } else if (charCode == 92) {\\n                            // A reverse solidus (`\\\\`) marks the beginning of an escaped\\n                            // control character (including `\\\"`, `\\\\`, and `/`) or Unicode\\n                            // escape sequence.\\n                            charCode = source.charCodeAt(++Index);\\n                            switch (charCode) {\\n                              case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:\\n                                // Revive escaped control characters.\\n                                value += Unescapes[charCode];\\n                                Index++;\\n                                break;\\n                              case 117:\\n                                // `\\\\u` marks the beginning of a Unicode escape sequence.\\n                                // Advance to the first character and validate the\\n                                // four-digit code point.\\n                                begin = ++Index;\\n                                for (position = Index + 4; Index < position; Index++) {\\n                                  charCode = source.charCodeAt(Index);\\n                                  // A valid sequence comprises four hexdigits (case-\\n                                  // insensitive) that form a single hexadecimal value.\\n                                  if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\\n                                    // Invalid Unicode escape sequence.\\n                                    abort();\\n                                  }\\n                                }\\n                                // Revive the escaped character.\\n                                value += fromCharCode(\\\"0x\\\" + source.slice(begin, Index));\\n                                break;\\n                              default:\\n                                // Invalid escape sequence.\\n                                abort();\\n                            }\\n                          } else {\\n                            if (charCode == 34) {\\n                              // An unescaped double-quote character marks the end of the\\n                              // string.\\n                              break;\\n                            }\\n                            charCode = source.charCodeAt(Index);\\n                            begin = Index;\\n                            // Optimize for the common case where a string is valid.\\n                            while (charCode >= 32 && charCode != 92 && charCode != 34) {\\n                              charCode = source.charCodeAt(++Index);\\n                            }\\n                            // Append the string as-is.\\n                            value += source.slice(begin, Index);\\n                          }\\n                        }\\n                        if (source.charCodeAt(Index) == 34) {\\n                          // Advance to the next character and return the revived string.\\n                          Index++;\\n                          return value;\\n                        }\\n                        // Unterminated string.\\n                        abort();\\n                      default:\\n                        // Parse numbers and literals.\\n                        begin = Index;\\n                        // Advance past the negative sign, if one is specified.\\n                        if (charCode == 45) {\\n                          isSigned = true;\\n                          charCode = source.charCodeAt(++Index);\\n                        }\\n                        // Parse an integer or floating-point value.\\n                        if (charCode >= 48 && charCode <= 57) {\\n                          // Leading zeroes are interpreted as octal literals.\\n                          if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {\\n                            // Illegal octal literal.\\n                            abort();\\n                          }\\n                          isSigned = false;\\n                          // Parse the integer component.\\n                          for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++);\\n                          // Floats cannot contain a leading decimal point; however, this\\n                          // case is already accounted for by the parser.\\n                          if (source.charCodeAt(Index) == 46) {\\n                            position = ++Index;\\n                            // Parse the decimal component.\\n                            for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++);\\n                            if (position == Index) {\\n                              // Illegal trailing decimal.\\n                              abort();\\n                            }\\n                            Index = position;\\n                          }\\n                          // Parse exponents. The `e` denoting the exponent is\\n                          // case-insensitive.\\n                          charCode = source.charCodeAt(Index);\\n                          if (charCode == 101 || charCode == 69) {\\n                            charCode = source.charCodeAt(++Index);\\n                            // Skip past the sign following the exponent, if one is\\n                            // specified.\\n                            if (charCode == 43 || charCode == 45) {\\n                              Index++;\\n                            }\\n                            // Parse the exponential component.\\n                            for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++);\\n                            if (position == Index) {\\n                              // Illegal empty exponent.\\n                              abort();\\n                            }\\n                            Index = position;\\n                          }\\n                          // Coerce the parsed value to a JavaScript number.\\n                          return +source.slice(begin, Index);\\n                        }\\n                        // A negative sign may only precede numbers.\\n                        if (isSigned) {\\n                          abort();\\n                        }\\n                        // `true`, `false`, and `null` literals.\\n                        if (source.slice(Index, Index + 4) == \\\"true\\\") {\\n                          Index += 4;\\n                          return true;\\n                        } else if (source.slice(Index, Index + 5) == \\\"false\\\") {\\n                          Index += 5;\\n                          return false;\\n                        } else if (source.slice(Index, Index + 4) == \\\"null\\\") {\\n                          Index += 4;\\n                          return null;\\n                        }\\n                        // Unrecognized token.\\n                        abort();\\n                    }\\n                  }\\n                  // Return the sentinel `$` character if the parser has reached the end\\n                  // of the source string.\\n                  return \\\"$\\\";\\n                };\\n\\n                // Internal: Parses a JSON `value` token.\\n                var get = function (value) {\\n                  var results, hasMembers;\\n                  if (value == \\\"$\\\") {\\n                    // Unexpected end of input.\\n                    abort();\\n                  }\\n                  if (typeof value == \\\"string\\\") {\\n                    if ((charIndexBuggy ? value.charAt(0) : value[0]) == \\\"@\\\") {\\n                      // Remove the sentinel `@` character.\\n                      return value.slice(1);\\n                    }\\n                    // Parse object and array literals.\\n                    if (value == \\\"[\\\") {\\n                      // Parses a JSON array, returning a new JavaScript array.\\n                      results = [];\\n                      for (;; hasMembers || (hasMembers = true)) {\\n                        value = lex();\\n                        // A closing square bracket marks the end of the array literal.\\n                        if (value == \\\"]\\\") {\\n                          break;\\n                        }\\n                        // If the array literal contains elements, the current token\\n                        // should be a comma separating the previous element from the\\n                        // next.\\n                        if (hasMembers) {\\n                          if (value == \\\",\\\") {\\n                            value = lex();\\n                            if (value == \\\"]\\\") {\\n                              // Unexpected trailing `,` in array literal.\\n                              abort();\\n                            }\\n                          } else {\\n                            // A `,` must separate each array element.\\n                            abort();\\n                          }\\n                        }\\n                        // Elisions and leading commas are not permitted.\\n                        if (value == \\\",\\\") {\\n                          abort();\\n                        }\\n                        results.push(get(value));\\n                      }\\n                      return results;\\n                    } else if (value == \\\"{\\\") {\\n                      // Parses a JSON object, returning a new JavaScript object.\\n                      results = {};\\n                      for (;; hasMembers || (hasMembers = true)) {\\n                        value = lex();\\n                        // A closing curly brace marks the end of the object literal.\\n                        if (value == \\\"}\\\") {\\n                          break;\\n                        }\\n                        // If the object literal contains members, the current token\\n                        // should be a comma separator.\\n                        if (hasMembers) {\\n                          if (value == \\\",\\\") {\\n                            value = lex();\\n                            if (value == \\\"}\\\") {\\n                              // Unexpected trailing `,` in object literal.\\n                              abort();\\n                            }\\n                          } else {\\n                            // A `,` must separate each object member.\\n                            abort();\\n                          }\\n                        }\\n                        // Leading commas are not permitted, object property names must be\\n                        // double-quoted strings, and a `:` must separate each property\\n                        // name and value.\\n                        if (value == \\\",\\\" || typeof value != \\\"string\\\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \\\"@\\\" || lex() != \\\":\\\") {\\n                          abort();\\n                        }\\n                        results[value.slice(1)] = get(lex());\\n                      }\\n                      return results;\\n                    }\\n                    // Unexpected token encountered.\\n                    abort();\\n                  }\\n                  return value;\\n                };\\n\\n                // Internal: Updates a traversed object member.\\n                var update = function (source, property, callback) {\\n                  var element = walk(source, property, callback);\\n                  if (element === undef) {\\n                    delete source[property];\\n                  } else {\\n                    source[property] = element;\\n                  }\\n                };\\n\\n                // Internal: Recursively traverses a parsed JSON object, invoking the\\n                // `callback` function for each value. This is an implementation of the\\n                // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\\n                var walk = function (source, property, callback) {\\n                  var value = source[property],\\n                      length;\\n                  if (typeof value == \\\"object\\\" && value) {\\n                    // `forEach` can't be used to traverse an array in Opera <= 8.54\\n                    // because its `Object#hasOwnProperty` implementation returns `false`\\n                    // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\\\"0\\\")`).\\n                    if (getClass.call(value) == arrayClass) {\\n                      for (length = value.length; length--;) {\\n                        update(value, length, callback);\\n                      }\\n                    } else {\\n                      forEach(value, function (property) {\\n                        update(value, property, callback);\\n                      });\\n                    }\\n                  }\\n                  return callback.call(source, property, value);\\n                };\\n\\n                // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\\n                exports.parse = function (source, callback) {\\n                  var result, value;\\n                  Index = 0;\\n                  Source = \\\"\\\" + source;\\n                  result = get(lex());\\n                  // If a JSON string contains multiple tokens, it is invalid.\\n                  if (lex() != \\\"$\\\") {\\n                    abort();\\n                  }\\n                  // Reset the parser state.\\n                  Index = Source = null;\\n                  return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\\\"\\\"] = result, value), \\\"\\\", callback) : result;\\n                };\\n              }\\n            }\\n\\n            exports[\\\"runInContext\\\"] = runInContext;\\n            return exports;\\n          }\\n\\n          if (freeExports && !isLoader) {\\n            // Export for CommonJS environments.\\n            runInContext(root, freeExports);\\n          } else {\\n            // Export for web browsers and JavaScript engines.\\n            var nativeJSON = root.JSON,\\n                previousJSON = root[\\\"JSON3\\\"],\\n                isRestored = false;\\n\\n            var JSON3 = runInContext(root, root[\\\"JSON3\\\"] = {\\n              // Public: Restores the original value of the global `JSON` object and\\n              // returns a reference to the `JSON3` object.\\n              \\\"noConflict\\\": function () {\\n                if (!isRestored) {\\n                  isRestored = true;\\n                  root.JSON = nativeJSON;\\n                  root[\\\"JSON3\\\"] = previousJSON;\\n                  nativeJSON = previousJSON = null;\\n                }\\n                return JSON3;\\n              }\\n            });\\n\\n            root.JSON = {\\n              \\\"parse\\\": JSON3.parse,\\n              \\\"stringify\\\": JSON3.stringify\\n            };\\n          }\\n\\n          // Export for asynchronous module loaders.\\n          if (isLoader) {\\n            define(function () {\\n              return JSON3;\\n            });\\n          }\\n        }).call(this);\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 59: [function (require, module, exports) {\\n      'use strict';\\n\\n      var has = Object.prototype.hasOwnProperty;\\n\\n      /**\\n       * Simple query string parser.\\n       *\\n       * @param {String} query The query string that needs to be parsed.\\n       * @returns {Object}\\n       * @api public\\n       */\\n      function querystring(query) {\\n        var parser = /([^=?&]+)=?([^&]*)/g,\\n            result = {},\\n            part;\\n\\n        //\\n        // Little nifty parsing hack, leverage the fact that RegExp.exec increments\\n        // the lastIndex property so we can continue executing this loop until we've\\n        // parsed all results.\\n        //\\n        for (; part = parser.exec(query); result[decodeURIComponent(part[1])] = decodeURIComponent(part[2]));\\n\\n        return result;\\n      }\\n\\n      /**\\n       * Transform a query string to an object.\\n       *\\n       * @param {Object} obj Object that should be transformed.\\n       * @param {String} prefix Optional prefix.\\n       * @returns {String}\\n       * @api public\\n       */\\n      function querystringify(obj, prefix) {\\n        prefix = prefix || '';\\n\\n        var pairs = [];\\n\\n        //\\n        // Optionally prefix with a '?' if needed\\n        //\\n        if ('string' !== typeof prefix) prefix = '?';\\n\\n        for (var key in obj) {\\n          if (has.call(obj, key)) {\\n            pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\\n          }\\n        }\\n\\n        return pairs.length ? prefix + pairs.join('&') : '';\\n      }\\n\\n      //\\n      // Expose the module.\\n      //\\n      exports.stringify = querystringify;\\n      exports.parse = querystring;\\n    }, {}], 60: [function (require, module, exports) {\\n      'use strict';\\n\\n      /**\\n       * Check if we're required to add a port number.\\n       *\\n       * @see https://url.spec.whatwg.org/#default-port\\n       * @param {Number|String} port Port number we need to check\\n       * @param {String} protocol Protocol we need to check against.\\n       * @returns {Boolean} Is it a default port for the given protocol\\n       * @api private\\n       */\\n\\n      module.exports = function required(port, protocol) {\\n        protocol = protocol.split(':')[0];\\n        port = +port;\\n\\n        if (!port) return false;\\n\\n        switch (protocol) {\\n          case 'http':\\n          case 'ws':\\n            return port !== 80;\\n\\n          case 'https':\\n          case 'wss':\\n            return port !== 443;\\n\\n          case 'ftp':\\n            return port !== 21;\\n\\n          case 'gopher':\\n            return port !== 70;\\n\\n          case 'file':\\n            return false;\\n        }\\n\\n        return port !== 0;\\n      };\\n    }, {}], 61: [function (require, module, exports) {\\n      'use strict';\\n\\n      var required = require('requires-port'),\\n          lolcation = require('./lolcation'),\\n          qs = require('querystringify'),\\n          protocolre = /^([a-z][a-z0-9.+-]*:)?(\\\\/\\\\/)?([\\\\S\\\\s]*)/i;\\n\\n      /**\\n       * These are the parse rules for the URL parser, it informs the parser\\n       * about:\\n       *\\n       * 0. The char it Needs to parse, if it's a string it should be done using\\n       *    indexOf, RegExp using exec and NaN means set as current value.\\n       * 1. The property we should set when parsing this value.\\n       * 2. Indication if it's backwards or forward parsing, when set as number it's\\n       *    the value of extra chars that should be split off.\\n       * 3. Inherit from location if non existing in the parser.\\n       * 4. `toLowerCase` the resulting value.\\n       */\\n      var rules = [['#', 'hash'], // Extract from the back.\\n      ['?', 'query'], // Extract from the back.\\n      ['/', 'pathname'], // Extract from the back.\\n      ['@', 'auth', 1], // Extract from the front.\\n      [NaN, 'host', undefined, 1, 1], // Set left over value.\\n      [/:(\\\\d+)$/, 'port', undefined, 1], // RegExp the back.\\n      [NaN, 'hostname', undefined, 1, 1] // Set left over.\\n      ];\\n\\n      /**\\n       * @typedef ProtocolExtract\\n       * @type Object\\n       * @property {String} protocol Protocol matched in the URL, in lowercase.\\n       * @property {Boolean} slashes `true` if protocol is followed by \\\"//\\\", else `false`.\\n       * @property {String} rest Rest of the URL that is not part of the protocol.\\n       */\\n\\n      /**\\n       * Extract protocol information from a URL with/without double slash (\\\"//\\\").\\n       *\\n       * @param {String} address URL we want to extract from.\\n       * @return {ProtocolExtract} Extracted information.\\n       * @api private\\n       */\\n      function extractProtocol(address) {\\n        var match = protocolre.exec(address);\\n\\n        return {\\n          protocol: match[1] ? match[1].toLowerCase() : '',\\n          slashes: !!match[2],\\n          rest: match[3]\\n        };\\n      }\\n\\n      /**\\n       * Resolve a relative URL pathname against a base URL pathname.\\n       *\\n       * @param {String} relative Pathname of the relative URL.\\n       * @param {String} base Pathname of the base URL.\\n       * @return {String} Resolved pathname.\\n       * @api private\\n       */\\n      function resolve(relative, base) {\\n        var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),\\n            i = path.length,\\n            last = path[i - 1],\\n            unshift = false,\\n            up = 0;\\n\\n        while (i--) {\\n          if (path[i] === '.') {\\n            path.splice(i, 1);\\n          } else if (path[i] === '..') {\\n            path.splice(i, 1);\\n            up++;\\n          } else if (up) {\\n            if (i === 0) unshift = true;\\n            path.splice(i, 1);\\n            up--;\\n          }\\n        }\\n\\n        if (unshift) path.unshift('');\\n        if (last === '.' || last === '..') path.push('');\\n\\n        return path.join('/');\\n      }\\n\\n      /**\\n       * The actual URL instance. Instead of returning an object we've opted-in to\\n       * create an actual constructor as it's much more memory efficient and\\n       * faster and it pleases my OCD.\\n       *\\n       * @constructor\\n       * @param {String} address URL we want to parse.\\n       * @param {Object|String} location Location defaults for relative paths.\\n       * @param {Boolean|Function} parser Parser for the query string.\\n       * @api public\\n       */\\n      function URL(address, location, parser) {\\n        if (!(this instanceof URL)) {\\n          return new URL(address, location, parser);\\n        }\\n\\n        var relative,\\n            extracted,\\n            parse,\\n            instruction,\\n            index,\\n            key,\\n            instructions = rules.slice(),\\n            type = typeof location,\\n            url = this,\\n            i = 0;\\n\\n        //\\n        // The following if statements allows this module two have compatibility with\\n        // 2 different API:\\n        //\\n        // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\\n        //    where the boolean indicates that the query string should also be parsed.\\n        //\\n        // 2. The `URL` interface of the browser which accepts a URL, object as\\n        //    arguments. The supplied object will be used as default values / fall-back\\n        //    for relative paths.\\n        //\\n        if ('object' !== type && 'string' !== type) {\\n          parser = location;\\n          location = null;\\n        }\\n\\n        if (parser && 'function' !== typeof parser) parser = qs.parse;\\n\\n        location = lolcation(location);\\n\\n        //\\n        // Extract protocol information before running the instructions.\\n        //\\n        extracted = extractProtocol(address || '');\\n        relative = !extracted.protocol && !extracted.slashes;\\n        url.slashes = extracted.slashes || relative && location.slashes;\\n        url.protocol = extracted.protocol || location.protocol || '';\\n        address = extracted.rest;\\n\\n        //\\n        // When the authority component is absent the URL starts with a path\\n        // component.\\n        //\\n        if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];\\n\\n        for (; i < instructions.length; i++) {\\n          instruction = instructions[i];\\n          parse = instruction[0];\\n          key = instruction[1];\\n\\n          if (parse !== parse) {\\n            url[key] = address;\\n          } else if ('string' === typeof parse) {\\n            if (~(index = address.indexOf(parse))) {\\n              if ('number' === typeof instruction[2]) {\\n                url[key] = address.slice(0, index);\\n                address = address.slice(index + instruction[2]);\\n              } else {\\n                url[key] = address.slice(index);\\n                address = address.slice(0, index);\\n              }\\n            }\\n          } else if (index = parse.exec(address)) {\\n            url[key] = index[1];\\n            address = address.slice(0, index.index);\\n          }\\n\\n          url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');\\n\\n          //\\n          // Hostname, host and protocol should be lowercased so they can be used to\\n          // create a proper `origin`.\\n          //\\n          if (instruction[4]) url[key] = url[key].toLowerCase();\\n        }\\n\\n        //\\n        // Also parse the supplied query string in to an object. If we're supplied\\n        // with a custom parser as function use that instead of the default build-in\\n        // parser.\\n        //\\n        if (parser) url.query = parser(url.query);\\n\\n        //\\n        // If the URL is relative, resolve the pathname against the base URL.\\n        //\\n        if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {\\n          url.pathname = resolve(url.pathname, location.pathname);\\n        }\\n\\n        //\\n        // We should not add port numbers if they are already the default port number\\n        // for a given protocol. As the host also contains the port number we're going\\n        // override it with the hostname which contains no port number.\\n        //\\n        if (!required(url.port, url.protocol)) {\\n          url.host = url.hostname;\\n          url.port = '';\\n        }\\n\\n        //\\n        // Parse down the `auth` for the username and password.\\n        //\\n        url.username = url.password = '';\\n        if (url.auth) {\\n          instruction = url.auth.split(':');\\n          url.username = instruction[0] || '';\\n          url.password = instruction[1] || '';\\n        }\\n\\n        url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';\\n\\n        //\\n        // The href is just the compiled result.\\n        //\\n        url.href = url.toString();\\n      }\\n\\n      /**\\n       * This is convenience method for changing properties in the URL instance to\\n       * insure that they all propagate correctly.\\n       *\\n       * @param {String} part          Property we need to adjust.\\n       * @param {Mixed} value          The newly assigned value.\\n       * @param {Boolean|Function} fn  When setting the query, it will be the function\\n       *                               used to parse the query.\\n       *                               When setting the protocol, double slash will be\\n       *                               removed from the final url if it is true.\\n       * @returns {URL}\\n       * @api public\\n       */\\n      function set(part, value, fn) {\\n        var url = this;\\n\\n        switch (part) {\\n          case 'query':\\n            if ('string' === typeof value && value.length) {\\n              value = (fn || qs.parse)(value);\\n            }\\n\\n            url[part] = value;\\n            break;\\n\\n          case 'port':\\n            url[part] = value;\\n\\n            if (!required(value, url.protocol)) {\\n              url.host = url.hostname;\\n              url[part] = '';\\n            } else if (value) {\\n              url.host = url.hostname + ':' + value;\\n            }\\n\\n            break;\\n\\n          case 'hostname':\\n            url[part] = value;\\n\\n            if (url.port) value += ':' + url.port;\\n            url.host = value;\\n            break;\\n\\n          case 'host':\\n            url[part] = value;\\n\\n            if (/:\\\\d+$/.test(value)) {\\n              value = value.split(':');\\n              url.port = value.pop();\\n              url.hostname = value.join(':');\\n            } else {\\n              url.hostname = value;\\n              url.port = '';\\n            }\\n\\n            break;\\n\\n          case 'protocol':\\n            url.protocol = value.toLowerCase();\\n            url.slashes = !fn;\\n            break;\\n\\n          case 'pathname':\\n            url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;\\n\\n            break;\\n\\n          default:\\n            url[part] = value;\\n        }\\n\\n        for (var i = 0; i < rules.length; i++) {\\n          var ins = rules[i];\\n\\n          if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\\n        }\\n\\n        url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';\\n\\n        url.href = url.toString();\\n\\n        return url;\\n      };\\n\\n      /**\\n       * Transform the properties back in to a valid and full URL string.\\n       *\\n       * @param {Function} stringify Optional query stringify function.\\n       * @returns {String}\\n       * @api public\\n       */\\n      function toString(stringify) {\\n        if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\\n\\n        var query,\\n            url = this,\\n            protocol = url.protocol;\\n\\n        if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\\n\\n        var result = protocol + (url.slashes ? '//' : '');\\n\\n        if (url.username) {\\n          result += url.username;\\n          if (url.password) result += ':' + url.password;\\n          result += '@';\\n        }\\n\\n        result += url.host + url.pathname;\\n\\n        query = 'object' === typeof url.query ? stringify(url.query) : url.query;\\n        if (query) result += '?' !== query.charAt(0) ? '?' + query : query;\\n\\n        if (url.hash) result += url.hash;\\n\\n        return result;\\n      }\\n\\n      URL.prototype = { set: set, toString: toString };\\n\\n      //\\n      // Expose the URL parser and some additional properties that might be useful for\\n      // others or testing.\\n      //\\n      URL.extractProtocol = extractProtocol;\\n      URL.location = lolcation;\\n      URL.qs = qs;\\n\\n      module.exports = URL;\\n    }, { \\\"./lolcation\\\": 62, \\\"querystringify\\\": 59, \\\"requires-port\\\": 60 }], 62: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\\\/\\\\//;\\n\\n        /**\\n         * These properties should not be copied or inherited from. This is only needed\\n         * for all non blob URL's as a blob URL does not include a hash, only the\\n         * origin.\\n         *\\n         * @type {Object}\\n         * @private\\n         */\\n        var ignore = { hash: 1, query: 1 },\\n            URL;\\n\\n        /**\\n         * The location object differs when your code is loaded through a normal page,\\n         * Worker or through a worker using a blob. And with the blobble begins the\\n         * trouble as the location object will contain the URL of the blob, not the\\n         * location of the page where our code is loaded in. The actual origin is\\n         * encoded in the `pathname` so we can thankfully generate a good \\\"default\\\"\\n         * location from it so we can generate proper relative URL's again.\\n         *\\n         * @param {Object|String} loc Optional default location object.\\n         * @returns {Object} lolcation object.\\n         * @api public\\n         */\\n        module.exports = function lolcation(loc) {\\n          loc = loc || global.location || {};\\n          URL = URL || require('./');\\n\\n          var finaldestination = {},\\n              type = typeof loc,\\n              key;\\n\\n          if ('blob:' === loc.protocol) {\\n            finaldestination = new URL(unescape(loc.pathname), {});\\n          } else if ('string' === type) {\\n            finaldestination = new URL(loc, {});\\n            for (key in ignore) delete finaldestination[key];\\n          } else if ('object' === type) {\\n            for (key in loc) {\\n              if (key in ignore) continue;\\n              finaldestination[key] = loc[key];\\n            }\\n\\n            if (finaldestination.slashes === undefined) {\\n              finaldestination.slashes = slashes.test(loc.href);\\n            }\\n          }\\n\\n          return finaldestination;\\n        };\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./\\\": 61 }] }, {}, [1])(1);\\n});\\n\\n//# sourceMappingURL=sockjs.js.map\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ 2)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcz85YmUyIl0sIm5hbWVzIjpbImYiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwiZSIsInQiLCJuIiwiciIsInMiLCJvIiwidSIsImEiLCJyZXF1aXJlIiwiaSIsIkVycm9yIiwiY29kZSIsImwiLCJjYWxsIiwibGVuZ3RoIiwiZ2xvYmFsIiwidHJhbnNwb3J0TGlzdCIsInNldFRpbWVvdXQiLCJfc29ja2pzX29ubG9hZCIsInNlbGYiLCJ3aW5kb3ciLCJpbmhlcml0cyIsIkV2ZW50IiwiQ2xvc2VFdmVudCIsImluaXRFdmVudCIsIndhc0NsZWFuIiwicmVhc29uIiwiRXZlbnRUYXJnZXQiLCJFdmVudEVtaXR0ZXIiLCJwcm90b3R5cGUiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJ0eXBlIiwiX2xpc3RlbmVycyIsIm9uY2UiLCJsaXN0ZW5lciIsImZpcmVkIiwiZyIsInJlbW92ZUxpc3RlbmVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJvbiIsImVtaXQiLCJsaXN0ZW5lcnMiLCJhcmdzIiwiQXJyYXkiLCJhaSIsImFkZExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudFR5cGUiLCJjYW5CdWJibGUiLCJjYW5jZWxhYmxlIiwiYnViYmxlcyIsInRpbWVTdGFtcCIsIkRhdGUiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwiYXJyIiwiaW5kZXhPZiIsImNvbmNhdCIsImlkeCIsInNsaWNlIiwiZGlzcGF0Y2hFdmVudCIsImV2ZW50IiwiVHJhbnNwb3J0TWVzc2FnZUV2ZW50IiwiZGF0YSIsIkpTT04zIiwiaWZyYW1lVXRpbHMiLCJGYWNhZGVKUyIsInRyYW5zcG9ydCIsIl90cmFuc3BvcnQiLCJfdHJhbnNwb3J0TWVzc2FnZSIsImJpbmQiLCJfdHJhbnNwb3J0Q2xvc2UiLCJwb3N0TWVzc2FnZSIsInN0cmluZ2lmeSIsImZyYW1lIiwiX3NlbmQiLCJzZW5kIiwiX2Nsb3NlIiwiY2xvc2UiLCJwcm9jZXNzIiwidXJsVXRpbHMiLCJldmVudFV0aWxzIiwiSW5mb0lmcmFtZVJlY2VpdmVyIiwibG9jIiwiZGVidWciLCJlbnYiLCJOT0RFX0VOViIsIlNvY2tKUyIsImF2YWlsYWJsZVRyYW5zcG9ydHMiLCJ0cmFuc3BvcnRNYXAiLCJmb3JFYWNoIiwiYXQiLCJmYWNhZGVUcmFuc3BvcnQiLCJ0cmFuc3BvcnROYW1lIiwicGFyZW50T3JpZ2luIiwiYm9vdHN0cmFwX2lmcmFtZSIsImZhY2FkZSIsImN1cnJlbnRXaW5kb3dJZCIsImhhc2giLCJvbk1lc3NhZ2UiLCJzb3VyY2UiLCJwYXJlbnQiLCJvcmlnaW4iLCJpZnJhbWVNZXNzYWdlIiwicGFyc2UiLCJpZ25vcmVkIiwid2luZG93SWQiLCJwIiwidmVyc2lvbiIsInRyYW5zVXJsIiwiYmFzZVVybCIsImlzT3JpZ2luRXF1YWwiLCJocmVmIiwiYXR0YWNoRXZlbnQiLCJvYmplY3RVdGlscyIsIkluZm9BamF4IiwidXJsIiwiQWpheE9iamVjdCIsInQwIiwieG8iLCJzdGF0dXMiLCJ0ZXh0IiwiaW5mbyIsInJ0dCIsImlzT2JqZWN0IiwiWEhSTG9jYWxPYmplY3QiLCJJbmZvUmVjZWl2ZXJJZnJhbWUiLCJpciIsInV0aWxzIiwiSWZyYW1lVHJhbnNwb3J0IiwiSW5mb0lmcmFtZSIsImdvIiwiaWZyIiwibXNnIiwiZCIsImRvY3VtZW50IiwiYm9keSIsImVuYWJsZWQiLCJYRFIiLCJYSFJDb3JzIiwiWEhSTG9jYWwiLCJYSFJGYWtlIiwiSW5mb1JlY2VpdmVyIiwidXJsSW5mbyIsImRvWGhyIiwiX2dldFJlY2VpdmVyIiwic2FtZU9yaWdpbiIsInNhbWVTY2hlbWUiLCJhZGRQYXRoIiwidGltZW91dFJlZiIsIl9jbGVhbnVwIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJob3N0IiwicG9ydCIsIlVSTCIsInJhbmRvbSIsImVzY2FwZSIsImJyb3dzZXIiLCJsb2ciLCJ0cmFuc3BvcnRzIiwicHJvdG9jb2xzIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsInJlYWR5U3RhdGUiLCJDT05ORUNUSU5HIiwiZXh0ZW5zaW9ucyIsInByb3RvY29sc193aGl0ZWxpc3QiLCJ3YXJuIiwiX3RyYW5zcG9ydHNXaGl0ZWxpc3QiLCJfdHJhbnNwb3J0T3B0aW9ucyIsInRyYW5zcG9ydE9wdGlvbnMiLCJzZXNzaW9uSWQiLCJfZ2VuZXJhdGVTZXNzaW9uSWQiLCJzdHJpbmciLCJfc2VydmVyIiwic2VydmVyIiwibnVtYmVyU3RyaW5nIiwicGFyc2VkVXJsIiwiU3ludGF4RXJyb3IiLCJzZWN1cmUiLCJpc0FycmF5Iiwic29ydGVkUHJvdG9jb2xzIiwic29ydCIsInByb3RvIiwiZ2V0T3JpZ2luIiwiX29yaWdpbiIsInRvTG93ZXJDYXNlIiwic2V0IiwicGF0aG5hbWUiLCJyZXBsYWNlIiwiX3VybEluZm8iLCJudWxsT3JpZ2luIiwiaGFzRG9tYWluIiwiaXNTY2hlbWVFcXVhbCIsIl9pciIsIl9yZWNlaXZlSW5mbyIsInVzZXJTZXRDb2RlIiwiQ0xPU0lORyIsIkNMT1NFRCIsIk9QRU4iLCJxdW90ZSIsIl9ydG8iLCJjb3VudFJUTyIsIl90cmFuc1VybCIsImJhc2VfdXJsIiwiZXh0ZW5kIiwiZW5hYmxlZFRyYW5zcG9ydHMiLCJmaWx0ZXJUb0VuYWJsZWQiLCJfdHJhbnNwb3J0cyIsIm1haW4iLCJfY29ubmVjdCIsIlRyYW5zcG9ydCIsInNoaWZ0IiwibmVlZEJvZHkiLCJ1bnNoaWZ0IiwidGltZW91dE1zIiwicm91bmRUcmlwcyIsIl90cmFuc3BvcnRUaW1lb3V0SWQiLCJfdHJhbnNwb3J0VGltZW91dCIsInRyYW5zcG9ydFVybCIsInRyYW5zcG9ydE9iaiIsImNvbnRlbnQiLCJwYXlsb2FkIiwiX29wZW4iLCJmb3JjZUZhaWwiLCJvbm1lc3NhZ2UiLCJvbmNsb3NlIiwib25lcnJvciIsIkFycmF5UHJvdG90eXBlIiwiT2JqZWN0UHJvdG90eXBlIiwiT2JqZWN0IiwiRnVuY3Rpb25Qcm90b3R5cGUiLCJGdW5jdGlvbiIsIlN0cmluZ1Byb3RvdHlwZSIsIlN0cmluZyIsImFycmF5X3NsaWNlIiwiX3RvU3RyaW5nIiwidG9TdHJpbmciLCJpc0Z1bmN0aW9uIiwidmFsIiwib2JqIiwiaXNTdHJpbmciLCJzdXBwb3J0c0Rlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmplY3QiLCJuYW1lIiwibWV0aG9kIiwiZm9yY2VBc3NpZ24iLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImRlZmluZVByb3BlcnRpZXMiLCJtYXAiLCJoYXNPd25Qcm9wZXJ0eSIsInRvT2JqZWN0IiwidG9JbnRlZ2VyIiwibnVtIiwiTWF0aCIsImZsb29yIiwiYWJzIiwiVG9VaW50MzIiLCJ4IiwiRW1wdHkiLCJ0aGF0IiwidGFyZ2V0IiwiYmluZGVyIiwiYm91bmQiLCJyZXN1bHQiLCJib3VuZExlbmd0aCIsIm1heCIsImJvdW5kQXJncyIsInB1c2giLCJqb2luIiwiYm94ZWRTdHJpbmciLCJzcGxpdFN0cmluZyIsInByb3Blcmx5Qm94ZXNDb250ZXh0IiwicHJvcGVybHlCb3hlZCIsInByb3Blcmx5Qm94ZXNOb25TdHJpY3QiLCJwcm9wZXJseUJveGVzU3RyaWN0IiwiXyIsIl9fIiwiY29udGV4dCIsImZ1biIsInNwbGl0IiwidGhpc3AiLCJoYXNGaXJlZm94MkluZGV4T2ZCdWciLCJzb3VnaHQiLCJzdHJpbmdfc3BsaXQiLCJjb21wbGlhbnRFeGVjTnBjZyIsImV4ZWMiLCJzZXBhcmF0b3IiLCJsaW1pdCIsIm91dHB1dCIsImZsYWdzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImV4dGVuZGVkIiwic3RpY2t5IiwibGFzdExhc3RJbmRleCIsInNlcGFyYXRvcjIiLCJtYXRjaCIsImxhc3RJbmRleCIsImxhc3RMZW5ndGgiLCJSZWdFeHAiLCJpbmRleCIsInRlc3QiLCJzdHJpbmdfc3Vic3RyIiwic3Vic3RyIiwiaGFzTmVnYXRpdmVTdWJzdHJCdWciLCJzdGFydCIsIlhIUiIsIlhNTEh0dHBSZXF1ZXN0IiwiQWJzdHJhY3RYSFJPYmplY3QiLCJvcHRzIiwiX3N0YXJ0IiwieGhyIiwiYWRkUXVlcnkiLCJ1bmxvYWRSZWYiLCJ1bmxvYWRBZGQiLCJvcGVuIiwib250aW1lb3V0Iiwibm9DcmVkZW50aWFscyIsInN1cHBvcnRzQ09SUyIsIndpdGhDcmVkZW50aWFscyIsImhlYWRlcnMiLCJrZXkiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUZXh0IiwiYWJvcnQiLCJ1bmxvYWREZWwiLCJheG8iLCJjb3JzIiwiRXZlbnRTb3VyY2UiLCJEcml2ZXIiLCJXZWJTb2NrZXQiLCJNb3pXZWJTb2NrZXQiLCJXZWJTb2NrZXRCcm93c2VyRHJpdmVyIiwidW5kZWZpbmVkIiwiQWpheEJhc2VkVHJhbnNwb3J0IiwiRXZlbnRTb3VyY2VSZWNlaXZlciIsIlhIUkNvcnNPYmplY3QiLCJFdmVudFNvdXJjZURyaXZlciIsIkV2ZW50U291cmNlVHJhbnNwb3J0IiwiSHRtbGZpbGVSZWNlaXZlciIsIkh0bWxGaWxlVHJhbnNwb3J0IiwiaWZyYW1lVXJsIiwiaWZyYW1lT2JqIiwiY3JlYXRlSWZyYW1lIiwib25tZXNzYWdlQ2FsbGJhY2siLCJfbWVzc2FnZSIsImRldGFjaEV2ZW50IiwiY2xlYW51cCIsImxvYWRlZCIsImNkYXRhIiwicG9zdCIsIm1lc3NhZ2UiLCJpZnJhbWVFbmFibGVkIiwiU2VuZGVyUmVjZWl2ZXIiLCJKc29ucFJlY2VpdmVyIiwianNvbnBTZW5kZXIiLCJKc29uUFRyYW5zcG9ydCIsImNyZWF0ZUFqYXhTZW5kZXIiLCJjYWxsYmFjayIsIm9wdCIsImFqYXhVcmwiLCJlcnIiLCJ1cmxTdWZmaXgiLCJSZWNlaXZlciIsIkJ1ZmZlcmVkU2VuZGVyIiwic2VuZGVyIiwic2VuZEJ1ZmZlciIsInNlbmRTdG9wIiwic2VuZFNjaGVkdWxlIiwic2VuZFNjaGVkdWxlV2FpdCIsInRyZWYiLCJJZnJhbWVXcmFwVHJhbnNwb3J0IiwiaWZyYW1lSW5mbyIsIlBvbGxpbmciLCJyZWNlaXZlVXJsIiwiX3NjaGVkdWxlUmVjZWl2ZXIiLCJwb2xsIiwicG9sbElzQ2xvc2luZyIsInNlbmRlckZ1bmMiLCJwb2xsVXJsIiwiZXMiLCJkZWNvZGVVUkkiLCJwb2xsdXRlR2xvYmFsTmFtZXNwYWNlIiwiaWQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJXUHJlZml4IiwiaHRtbGZpbGVFbmFibGVkIiwiY29uc3RydWN0RnVuYyIsImNyZWF0ZUh0bWxmaWxlIiwic3RvcCIsInVybFdpdGhJZCIsImVuY29kZVVSSUNvbXBvbmVudCIsIl9jYWxsYmFjayIsIl9jcmVhdGVTY3JpcHQiLCJ0aW1lb3V0SWQiLCJfYWJvcnQiLCJzY3JpcHRFcnJvclRpbWVvdXQiLCJhYm9ydGluZyIsInNjcmlwdDIiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJzY3JpcHQiLCJvbmxvYWQiLCJvbmNsaWNrIiwiX3NjcmlwdEVycm9yIiwiZXJyb3JUaW1lciIsImxvYWRlZE9rYXkiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiY2hhcnNldCIsImh0bWxGb3IiLCJhc3luYyIsImlzT3BlcmEiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwiWGhyUmVjZWl2ZXIiLCJidWZmZXJQb3NpdGlvbiIsIl9jaHVua0hhbmRsZXIiLCJidWYiLCJmb3JtIiwiYXJlYSIsImlmcmFtZSIsImNyZWF0ZUZvcm0iLCJzdHlsZSIsImRpc3BsYXkiLCJwb3NpdGlvbiIsImVuY3R5cGUiLCJhY2NlcHRDaGFyc2V0IiwiYXBwZW5kQ2hpbGQiLCJhY3Rpb24iLCJzdWJtaXQiLCJjb21wbGV0ZWQiLCJYRFJPYmplY3QiLCJ4ZHIiLCJYRG9tYWluUmVxdWVzdCIsIl9lcnJvciIsIm9ucHJvZ3Jlc3MiLCJYaHJEcml2ZXIiLCJ0byIsIldlYnNvY2tldERyaXZlciIsIldlYlNvY2tldFRyYW5zcG9ydCIsImlnbm9yZSIsIndzIiwiWGRyU3RyZWFtaW5nVHJhbnNwb3J0IiwiWGRyUG9sbGluZ1RyYW5zcG9ydCIsImNvb2tpZV9uZWVkZWQiLCJYaHJQb2xsaW5nVHJhbnNwb3J0IiwiWGhyU3RyZWFtaW5nVHJhbnNwb3J0IiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tQnl0ZXMiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0tvbnF1ZXJvciIsImRvbWFpbiIsImV4dHJhRXNjYXBhYmxlIiwiZXh0cmFMb29rdXAiLCJ1bnJvbGxMb29rdXAiLCJlc2NhcGFibGUiLCJ1bnJvbGxlZCIsImMiLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZUF0IiwicXVvdGVkIiwib25VbmxvYWQiLCJhZnRlclVubG9hZCIsImlzQ2hyb21lUGFja2FnZWRBcHAiLCJjaHJvbWUiLCJhcHAiLCJydW50aW1lIiwicmVmIiwidHJpZ2dlclVubG9hZENhbGxiYWNrcyIsInVubG9hZFRyaWdnZXJlZCIsImVycm9yQ2FsbGJhY2siLCJ1bmF0dGFjaCIsImNvbnRlbnRXaW5kb3ciLCJkb2MiLCJDb2xsZWN0R2FyYmFnZSIsIndyaXRlIiwicGFyZW50V2luZG93IiwibG9nT2JqZWN0IiwibGV2ZWwiLCJsZXZlbEV4aXN0cyIsImNvbnNvbGUiLCJwcm9wIiwiX3JhbmRvbVN0cmluZ0NoYXJzIiwicmV0IiwibnVtYmVyIiwidHJhbnNwb3J0c1doaXRlbGlzdCIsInRyYW5zIiwid2Vic29ja2V0IiwiaG9zdG5hbWUiLCJiIiwicmVzIiwicGF0aCIsInFzIiwicSIsIm0iLCJoIiwieSIsImlzTmFOIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsIkpTT04iLCJzdHIiLCJwYXJzZUZsb2F0IiwibXMiLCJyb3VuZCIsInBsdXJhbCIsImNlaWwiLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJzdG9yYWdlIiwibG9jYWwiLCJsb2NhbHN0b3JhZ2UiLCJjb2xvcnMiLCJkb2N1bWVudEVsZW1lbnQiLCJXZWJraXRBcHBlYXJhbmNlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwicGFyc2VJbnQiLCIkMSIsImZvcm1hdHRlcnMiLCJqIiwidiIsIm5hbWVzcGFjZSIsImh1bWFuaXplIiwiZGlmZiIsImNvbG9yIiwic3BsaWNlIiwibGFzdEMiLCJuYW1lc3BhY2VzIiwicmVtb3ZlSXRlbSIsIkRFQlVHIiwiZW5hYmxlIiwibG9jYWxTdG9yYWdlIiwiY3JlYXRlRGVidWciLCJjb2VyY2UiLCJkaXNhYmxlIiwibmFtZXMiLCJza2lwcyIsInByZXZUaW1lIiwic2VsZWN0Q29sb3IiLCJjdXJyIiwicHJldiIsImZvcm1hdCIsImZvcm1hdHRlciIsImxvZ0ZuIiwiaW5pdCIsImxlbiIsInN0YWNrIiwiY3JlYXRlIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwiVGVtcEN0b3IiLCJpc0xvYWRlciIsImFtZCIsIm9iamVjdFR5cGVzIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsInJvb3QiLCJmcmVlR2xvYmFsIiwicnVuSW5Db250ZXh0IiwiTnVtYmVyIiwibmF0aXZlSlNPTiIsIm9iamVjdFByb3RvIiwiZ2V0Q2xhc3MiLCJpc1Byb3BlcnR5IiwidW5kZWYiLCJpc0V4dGVuZGVkIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiaGFzIiwiaXNTdXBwb3J0ZWQiLCJzZXJpYWxpemVkIiwic3RyaW5naWZ5U3VwcG9ydGVkIiwidG9KU09OIiwicGFyc2VTdXBwb3J0ZWQiLCJmdW5jdGlvbkNsYXNzIiwiZGF0ZUNsYXNzIiwibnVtYmVyQ2xhc3MiLCJzdHJpbmdDbGFzcyIsImFycmF5Q2xhc3MiLCJib29sZWFuQ2xhc3MiLCJjaGFySW5kZXhCdWdneSIsIk1vbnRocyIsImdldERheSIsInllYXIiLCJtb250aCIsInByb3BlcnR5IiwibWVtYmVycyIsIl9fcHJvdG9fXyIsIm9yaWdpbmFsIiwic2l6ZSIsIlByb3BlcnRpZXMiLCJ2YWx1ZU9mIiwiaGFzUHJvcGVydHkiLCJpc0NvbnN0cnVjdG9yIiwiRXNjYXBlcyIsImxlYWRpbmdaZXJvZXMiLCJ0b1BhZGRlZFN0cmluZyIsIndpZHRoIiwidW5pY29kZVByZWZpeCIsInVzZUNoYXJJbmRleCIsInN5bWJvbHMiLCJjaGFyQ29kZSIsImNoYXJBdCIsInNlcmlhbGl6ZSIsInByb3BlcnRpZXMiLCJ3aGl0ZXNwYWNlIiwiaW5kZW50YXRpb24iLCJjbGFzc05hbWUiLCJkYXRlIiwidGltZSIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJyZXN1bHRzIiwiZWxlbWVudCIsInByZWZpeCIsInBvcCIsImZpbHRlciIsIlVuZXNjYXBlcyIsIkluZGV4IiwiU291cmNlIiwibGV4IiwiYmVnaW4iLCJpc1NpZ25lZCIsImdldCIsImhhc01lbWJlcnMiLCJ1cGRhdGUiLCJ3YWxrIiwicHJldmlvdXNKU09OIiwiaXNSZXN0b3JlZCIsInF1ZXJ5c3RyaW5nIiwicXVlcnkiLCJwYXJzZXIiLCJwYXJ0IiwicXVlcnlzdHJpbmdpZnkiLCJwYWlycyIsInJlcXVpcmVkIiwibG9sY2F0aW9uIiwicHJvdG9jb2xyZSIsInJ1bGVzIiwiTmFOIiwiZXh0cmFjdFByb3RvY29sIiwiYWRkcmVzcyIsInNsYXNoZXMiLCJyZXN0IiwicmVzb2x2ZSIsInJlbGF0aXZlIiwiYmFzZSIsImxhc3QiLCJ1cCIsImV4dHJhY3RlZCIsImluc3RydWN0aW9uIiwiaW5zdHJ1Y3Rpb25zIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImF1dGgiLCJmbiIsImlucyIsImZpbmFsZGVzdGluYXRpb24iLCJ1bmVzY2FwZSJdLCJtYXBwaW5ncyI6IjBEQUFBO0FBQ0Es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T0UsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUMsT0FBT0ksSUFBUCxLQUFnQixXQUFoQixHQUE4QkEsSUFBOUIsR0FBcUMsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUMsRUF2RHBJO0FBeURDLEtBMUQrRCxFQTBEOUQsRUFBQyxNQUFLLEVBQU4sRUExRDhELENBcmlMeXVCLEVBQTNiLEVBK2xMaFcsRUEvbExnVyxFQStsTDdWLENBQUMsQ0FBRCxDQS9sTDZWLEVBK2xMeFYsQ0EvbEx3VixDQUFQO0FBZ21MdFcsQ0FobUxEOztBQW1tTEEsa0MiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBzb2NranMtY2xpZW50IHYxLjEuNCB8IGh0dHA6Ly9zb2NranMub3JnIHwgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLlNvY2tKUyA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJykodHJhbnNwb3J0TGlzdCk7XG5cbi8vIFRPRE8gY2FuJ3QgZ2V0IHJpZCBvZiB0aGlzIHVudGlsIGFsbCBzZXJ2ZXJzIGRvXG5pZiAoJ19zb2NranNfb25sb2FkJyBpbiBnbG9iYWwpIHtcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL21haW5cIjoxNCxcIi4vdHJhbnNwb3J0LWxpc3RcIjoxNn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICBmb3IgKHZhciBhaSA9IDE7IGFpIDwgbDsgYWkrKykge1xuICAgIGFyZ3NbYWkgLSAxXSA9IGFyZ3VtZW50c1thaV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSx7XCIuL2V2ZW50dGFyZ2V0XCI6NSxcImluaGVyaXRzXCI6NTd9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbn1cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB0aGlzLnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5pbmhlcml0cyhUcmFuc3BvcnRNZXNzYWdlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgO1xuXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcbiAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG59XG5cbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OMy5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG5cbn0se1wiLi91dGlscy9pZnJhbWVcIjo0NyxcImpzb24zXCI6NTh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvaWZyYW1lJylcbiAgLCBJbmZvUmVjZWl2ZXJJZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8taWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcblxuICAgIGlmci5vbmNlKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgbXNnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IGRbMF0sIHJ0dCA9IGRbMV07XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmci5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgc2VlbXMgdGhlIHNhbWUgYXMgdGhlICduZWVkQm9keScgZnJvbSB0cmFuc3BvcnRzXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcbiAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgfSBlbHNlIHtcbiAgICBnbygpO1xuICB9XG59XG5cbmluaGVyaXRzKEluZm9JZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cbkluZm9JZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlmcikge1xuICAgIHRoaXMuaWZyLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5pZnIgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL3RyYW5zcG9ydC9pZnJhbWVcIjoyMixcIi4vdXRpbHMvZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL2luZm8taWZyYW1lXCI6MTEsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGRyXCI6MzQsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZVwiOjM2LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHAnXG4sIGhvc3Q6ICdsb2NhbGhvc3QnXG4sIHBvcnQ6IDgwXG4sIGhyZWY6ICdodHRwOi8vbG9jYWxob3N0LydcbiwgaGFzaDogJydcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9zaGltcycpO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuL3V0aWxzL3JhbmRvbScpXG4gICwgZXNjYXBlID0gcmVxdWlyZSgnLi91dGlscy9lc2NhcGUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCB0cmFuc3BvcnQgPSByZXF1aXJlKCcuL3V0aWxzL3RyYW5zcG9ydCcpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vdXRpbHMvYnJvd3NlcicpXG4gICwgbG9nID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudCcpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50dGFyZ2V0JylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgLCBDbG9zZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9jbG9zZScpXG4gICwgVHJhbnNwb3J0TWVzc2FnZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC90cmFucy1tZXNzYWdlJylcbiAgLCBJbmZvUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8tcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6bWFpbicpO1xufVxuXG52YXIgdHJhbnNwb3J0cztcblxuLy8gZm9sbG93IGNvbnN0cnVjdG9yIHN0ZXBzIGRlZmluZWQgYXQgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbmZ1bmN0aW9uIFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja0pTKSkge1xuICAgIHJldHVybiBuZXcgU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnU29ja0pTOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnRcIik7XG4gIH1cbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgdGhpcy5leHRlbnNpb25zID0gJyc7XG4gIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAvLyBub24tc3RhbmRhcmQgZXh0ZW5zaW9uXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgbG9nLndhcm4oXCIncHJvdG9jb2xzX3doaXRlbGlzdCcgaXMgREVQUkVDQVRFRC4gVXNlICd0cmFuc3BvcnRzJyBpbnN0ZWFkLlwiKTtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0ID0gb3B0aW9ucy50cmFuc3BvcnRzO1xuICB0aGlzLl90cmFuc3BvcnRPcHRpb25zID0gb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzZXNzaW9uSWQgPSBvcHRpb25zLnNlc3Npb25JZCB8fCA4O1xuICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5kb20uc3RyaW5nKHNlc3Npb25JZCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiBzZXNzaW9uSWQgaXMgdXNlZCBpbiB0aGUgb3B0aW9ucywgaXQgbmVlZHMgdG8gYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyIHx8IHJhbmRvbS5udW1iZXJTdHJpbmcoMTAwMCk7XG5cbiAgLy8gU3RlcCAxIG9mIFdTIHNwZWMgLSBwYXJzZSBhbmQgdmFsaWRhdGUgdGhlIHVybC4gSXNzdWUgIzhcbiAgdmFyIHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCB8fCAhcGFyc2VkVXJsLnByb3RvY29sKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCAnXCIgKyB1cmwgKyBcIicgaXMgaW52YWxpZFwiKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVGhlIFVSTCBtdXN0IG5vdCBjb250YWluIGEgZnJhZ21lbnQnKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwncyBzY2hlbWUgbXVzdCBiZSBlaXRoZXIgJ2h0dHA6JyBvciAnaHR0cHM6Jy4gJ1wiICsgcGFyc2VkVXJsLnByb3RvY29sICsgXCInIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgfVxuXG4gIHZhciBzZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAvLyBTdGVwIDIgLSBkb24ndCBhbGxvdyBzZWN1cmUgb3JpZ2luIHdpdGggYW4gaW5zZWN1cmUgcHJvdG9jb2xcbiAgaWYgKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzJyAmJiAhc2VjdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cml0eUVycm9yOiBBbiBpbnNlY3VyZSBTb2NrSlMgY29ubmVjdGlvbiBtYXkgbm90IGJlIGluaXRpYXRlZCBmcm9tIGEgcGFnZSBsb2FkZWQgb3ZlciBIVFRQUycpO1xuICB9XG5cbiAgLy8gU3RlcCAzIC0gY2hlY2sgcG9ydCBhY2Nlc3MgLSBubyBuZWVkIGhlcmVcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIGlmICghcHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICB9XG5cbiAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIHZhciBzb3J0ZWRQcm90b2NvbHMgPSBwcm90b2NvbHMuc29ydCgpO1xuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgKHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxKSAmJiBwcm90byA9PT0gc29ydGVkUHJvdG9jb2xzW2kgKyAxXSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gIHZhciBvID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGxvYy5ocmVmKTtcbiAgdGhpcy5fb3JpZ2luID0gbyA/IG8udG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICBwYXJzZWRVcmwuc2V0KCdwYXRobmFtZScsIHBhcnNlZFVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sICcnKSk7XG5cbiAgLy8gc3RvcmUgdGhlIHNhbml0aXplZCB1cmxcbiAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcblxuICAvLyBTdGVwIDcgLSBzdGFydCBjb25uZWN0aW9uIGluIGJhY2tncm91bmRcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gIC8vIGh0dHA6Ly9zb2NranMuZ2l0aHViLmlvL3NvY2tqcy1wcm90b2NvbC9zb2NranMtcHJvdG9jb2wtMC4zLjMuaHRtbCNzZWN0aW9uLTI2XG4gIHRoaXMuX3VybEluZm8gPSB7XG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcbiAgLCBzYW1lT3JpZ2luOiB1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgLCBzYW1lU2NoZW1lOiB1cmxVdGlscy5pc1NjaGVtZUVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgfTtcblxuICB0aGlzLl9pciA9IG5ldyBJbmZvUmVjZWl2ZXIodGhpcy51cmwsIHRoaXMuX3VybEluZm8pO1xuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcbn1cblxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XG5cbmZ1bmN0aW9uIHVzZXJTZXRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufVxuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIC8vIFN0ZXAgMVxuICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XG4gIH1cbiAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncmVhc29uIGFyZ3VtZW50IGhhcyBhbiBpbnZhbGlkIGxlbmd0aCcpO1xuICB9XG5cbiAgLy8gU3RlcCAzLjFcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xuICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICB0aGlzLl9jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCAnTm9ybWFsIGNsb3N1cmUnLCB3YXNDbGVhbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgLy8gVE9ETyB0aGlzIGN1cnJlbnRseSB0dXJucyBvYmplY3RzIGludG8gW29iamVjdCBPYmplY3RdXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVzY2FwZS5xdW90ZShkYXRhKSk7XG59O1xuXG5Tb2NrSlMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgZGVidWcoJ19yZWNlaXZlSW5mbycsIHJ0dCk7XG4gIHRoaXMuX2lyID0gbnVsbDtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhpcy5fY2xvc2UoMTAwMiwgJ0Nhbm5vdCBjb25uZWN0IHRvIHNlcnZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBhIHJvdW5kLXRyaXAgdGltZW91dCAoUlRPKSBiYXNlZCBvbiB0aGVcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gIHRoaXMuX3J0byA9IHRoaXMuY291bnRSVE8ocnR0KTtcbiAgLy8gYWxsb3cgc2VydmVyIHRvIG92ZXJyaWRlIHVybCB1c2VkIGZvciB0aGUgYWN0dWFsIHRyYW5zcG9ydFxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gIGluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoaW5mbywgdGhpcy5fdXJsSW5mbyk7XG4gIGRlYnVnKCdpbmZvJywgaW5mbyk7XG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gIHZhciBlbmFibGVkVHJhbnNwb3J0cyA9IHRyYW5zcG9ydHMuZmlsdGVyVG9FbmFibGVkKHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pO1xuICB0aGlzLl90cmFuc3BvcnRzID0gZW5hYmxlZFRyYW5zcG9ydHMubWFpbjtcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuXG4gIHRoaXMuX2Nvbm5lY3QoKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xuICAgIGRlYnVnKCdhdHRlbXB0JywgVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUpO1xuICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAodHlwZW9mIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgYm9keScpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGltZW91dCBiYXNlZCBvbiBSVE8gYW5kIHJvdW5kIHRyaXBzLiBEZWZhdWx0IHRvIDVzXG4gICAgdmFyIHRpbWVvdXRNcyA9ICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMDtcbiAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICBkZWJ1ZygndXNpbmcgdGltZW91dCcsIHRpbWVvdXRNcyk7XG5cbiAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl90cmFuc3BvcnRPcHRpb25zW1RyYW5zcG9ydC50cmFuc3BvcnROYW1lXTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKTtcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgLy8gY29ubmVjdGlvbi5cbiAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB2YXIgZm9yY2VGYWlsID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2lyKSB7XG4gICAgZm9yY2VGYWlsID0gdHJ1ZTtcbiAgICB0aGlzLl9pci5jbG9zZSgpO1xuICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgaWYgKGZvcmNlRmFpbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XG4gICAgZS5jb2RlID0gY29kZSB8fCAxMDAwO1xuICAgIGUucmVhc29uID0gcmVhc29uO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XG4gIH0uYmluZCh0aGlzKSwgMCk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XG4gIC8vIEluIGEgbG9jYWwgZW52aXJvbm1lbnQsIHdoZW4gdXNpbmcgSUU4LzkgYW5kIHRoZSBganNvbnAtcG9sbGluZ2BcbiAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcbiAgLy8gYXJvdW5kIDIwMG1zZWMgKHRoZSBsb3dlciBib3VuZCB1c2VkIGluIHRoZSBhcnRpY2xlIGFib3ZlKSBhbmQgdGhpc1xuICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXG4gIGlmIChydHQgPiAxMDApIHtcbiAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICB9XG4gIHJldHVybiAzMDAgKyBydHQ7IC8vIDMwMG1zZWMgPCBydG8gPD0gNDAwbXNlY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHRyYW5zcG9ydHMgPSB0cmFuc3BvcnQoYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJldHVybiBTb2NrSlM7XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MixcIi4vZXZlbnQvZXZlbnRcIjo0LFwiLi9ldmVudC9ldmVudHRhcmdldFwiOjUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjo2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6OCxcIi4vaW5mby1yZWNlaXZlclwiOjEyLFwiLi9sb2NhdGlvblwiOjEzLFwiLi9zaGltc1wiOjE1LFwiLi91dGlscy9icm93c2VyXCI6NDQsXCIuL3V0aWxzL2VzY2FwZVwiOjQ1LFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9sb2dcIjo0OCxcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi91dGlscy90cmFuc3BvcnRcIjo1MSxcIi4vdXRpbHMvdXJsXCI6NTIsXCIuL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OCxcInVybC1wYXJzZVwiOjYxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGpzY3M6IGRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gcHVsbGVkIHNwZWNpZmljIHNoaW1zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbnZhciBkZWZpbmVQcm9wZXJ0eTtcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgOS40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICAgIHZhciBuID0gK251bTtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgIHJldHVybiB4ID4+PiAwO1xufVxuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG5mdW5jdGlvbiBFbXB0eSgpIHt9XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgdmFyIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG5cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ICAgICA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIFRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4vLyBbYnVnZml4LCBjaHJvbWVdXG4vLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4vLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4vLyBlbGVtZW50cy5cbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbn0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3RhcnQgPCAwID8gKChzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQpIDwgMCA/IDAgOiBzdGFydCkgOiBzdGFydCxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJykpXG5cbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxuXTtcblxufSx7XCIuL3RyYW5zcG9ydC9ldmVudHNvdXJjZVwiOjIwLFwiLi90cmFuc3BvcnQvaHRtbGZpbGVcIjoyMSxcIi4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmdcIjoyMyxcIi4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcFwiOjI2LFwiLi90cmFuc3BvcnQvd2Vic29ja2V0XCI6MzgsXCIuL3RyYW5zcG9ydC94ZHItcG9sbGluZ1wiOjM5LFwiLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZ1wiOjQwLFwiLi90cmFuc3BvcnQveGhyLXBvbGxpbmdcIjo0MSxcIi4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmdcIjo0Mn1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFhIUiA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdFxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnJvd3Nlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gQWJzdHJhY3RYSFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEFic3RyYWN0WEhST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgdGhpcy54aHIgPSBuZXcgWEhSKCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cblxuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgZGVidWcoJ25vIHhocicpO1xuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNldmVyYWwgYnJvd3NlcnMgY2FjaGUgUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgLy8gRXhwbG9yZXIgdGVuZHMgdG8ga2VlcCBjb25uZWN0aW9uIG9wZW4sIGV2ZW4gYWZ0ZXIgdGhlXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy50aW1lb3V0ICYmICd0aW1lb3V0JyBpbiB0aGlzLnhocikge1xuICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoIW9wdHMgfHwgIW9wdHMubm9DcmVkZW50aWFscykgJiYgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTKSB7XG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAvLyBcIlRoaXMgbmV2ZXIgYWZmZWN0cyBzYW1lLXNpdGUgcmVxdWVzdHMuXCJcblxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9ICd0cnVlJztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnhocikge1xuICAgICAgdmFyIHggPSBzZWxmLnhocjtcbiAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgLy8gb24gTWljcm9zb2Z0LlhNTEhUVFAgYW5kIHJlYWR5c3RhdGU9M1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgIHRleHQgPSB4LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlYnVnKCdjaHVuaycpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzODM3NzAodj12cy44NSkuYXNweFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjAwNSB8fCBzdGF0dXMgPT09IDEyMDI5KSB7XG4gICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfVxufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgaWYgKCF0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XG4vLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2Lzdcbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIChheG8gaW4gZ2xvYmFsKSkge1xuICBkZWJ1Zygnb3ZlcnJpZGluZyB4bWxodHRwcmVxdWVzdCcpO1xuICBYSFIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIW5ldyBYSFIoKTtcbn1cblxudmFyIGNvcnMgPSBmYWxzZTtcbnRyeSB7XG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XG59IGNhdGNoIChpZ25vcmVkKSB7XG4gIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbn1cblxuQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFhIUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5pZiAoRHJpdmVyKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckRyaXZlcih1cmwpIHtcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvZXZlbnRzb3VyY2VcIjoyOSxcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEh0bWxmaWxlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2h0bWxmaWxlJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gIDtcblxuZnVuY3Rpb24gSHRtbEZpbGVUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIFhIUkxvY2FsT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkh0bWxGaWxlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIHJldHVybiBIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luO1xufTtcblxuSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sRmlsZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6MzAsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XG4vLyAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MxOTcwMTUodj1WUy44NSkuYXNweFxuLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICBpZiAoIUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub3JpZ2luID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGJhc2VVcmwpO1xuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcblxuICB2YXIgaWZyYW1lVXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2lmcmFtZS5odG1sJykgKyAnIycgKyB0aGlzLndpbmRvd0lkO1xuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xuXG4gIHRoaXMuaWZyYW1lT2JqID0gaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lKGlmcmFtZVVybCwgZnVuY3Rpb24ocikge1xuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1VuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoJyArIHIgKyAnKScpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xufVxuXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gICAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgIGRlYnVnKCdub3Qgc2FtZSBvcmlnaW4nLCBlLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xuICB0cnkge1xuICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gIGNhc2UgJ3MnOlxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIC8vIHdpbmRvdyBnbG9iYWwgZGVwZW5kZW5jeVxuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ3MnLCBKU09OMy5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNkYXRhWzBdLCBjZGF0YVsxXSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcbiAgdGhpcy5pZnJhbWVPYmoucG9zdChKU09OMy5zdHJpbmdpZnkoe1xuICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICwgdHlwZTogdHlwZVxuICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgfSksIHRoaXMub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5wb3N0TWVzc2FnZSgnbScsIG1lc3NhZ2UpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3Rcbi8vIGV2ZXJ5d2hlcmUuXG4vLyBLbm93biBsaW1pdGF0aW9uczpcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3Jcbi8vICAgbyBmb3IgS29ucXVlcm9yIGEgZHVtYiB0aW1lciBpcyBuZWVkZWQgdG8gZGV0ZWN0IGVycm9yc1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9zZW5kZXItcmVjZWl2ZXInKVxuICAsIEpzb25wUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2pzb25wJylcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcbiAgO1xuXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUpzb25QVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsICcvanNvbnAnLCBqc29ucFNlbmRlciwgSnNvbnBSZWNlaXZlcik7XG59XG5cbmluaGVyaXRzKEpzb25QVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50O1xufTtcblxuSnNvblBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdqc29ucC1wb2xsaW5nJztcbkpzb25QVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAxO1xuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25QVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmFqYXgtYmFzZWQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ2NyZWF0ZSBhamF4IHNlbmRlcicsIHVybCwgcGF5bG9hZCk7XG4gICAgdmFyIG9wdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5oZWFkZXJzID0geydDb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbid9O1xuICAgIH1cbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XG4gICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCBhamF4VXJsLCBwYXlsb2FkLCBvcHQpO1xuICAgIHhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdodHRwIHN0YXR1cyAnICsgc3RhdHVzKSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xuICAgICAgeG8uY2xvc2UoKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBBamF4QmFzZWRUcmFuc3BvcnQodHJhbnNVcmwsIHVybFN1ZmZpeCwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqYXhCYXNlZFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnVmZmVyZWQtc2VuZGVyJyk7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkU2VuZGVyKHVybCwgc2VuZGVyKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gIHRoaXMudXJsID0gdXJsO1xufVxuXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICBpZiAoIXRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xuICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmVmO1xuICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3NlbmRTdG9wJyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICB9O1xuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XG4gIH0sIDI1KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZScsIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhpcy5zZW5kQnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSB8fCAxMDA2LCAnU2VuZGluZyBlcnJvcjogJyArIGVycik7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2VuZFNjaGVkdWxlV2FpdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTdG9wKCk7XG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL29iamVjdFwiOjQ5LFwiLi4vaWZyYW1lXCI6MjIsXCJpbmhlcml0c1wiOjU3fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2J1ZmZlcmVkLXNlbmRlclwiOjI1LFwiLi9wb2xsaW5nXCI6MjcsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG59XG5cbmZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB2YXIgdXJsV2l0aElkID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgdGhpcy5fY3JlYXRlU2NyaXB0KHVybFdpdGhJZCk7XG5cbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XG4gIH0sIEpzb25wUmVjZWl2ZXIudGltZW91dCk7XG59XG5cbmluaGVyaXRzKEpzb25wUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAoZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgdGhpcy5fYWJvcnQoZXJyKTtcbiAgfVxufTtcblxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XG5Kc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGVidWcoJ19jYWxsYmFjaycsIGRhdGEpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgaWYgKHRoaXMuYWJvcnRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5hYm9ydGluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcbiAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgIHRoaXMuc2NyaXB0MiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcbiAgICAvLyB0aGUgc2NyaXB0LlxuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9zY3JpcHRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjcmlwdEVycm9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyb3JUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKScpKTtcbiAgICB9XG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgZGVidWcoJ19jcmVhdGVTY3JpcHQnLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIHNjcmlwdDI7ICAvLyBPcGVyYSBzeW5jaHJvbm91cyBsb2FkIHRyaWNrLlxuXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpJykpO1xuICB9O1xuXG4gIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgLy8gVXNlIGxvYWRlZE9rYXkgdG8gZGV0ZXJtaW5lIGlmIGFjdHVhbGx5IGVycm9yZWRcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBzY3JpcHQucmVhZHlTdGF0ZSk7XG4gICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICBzZWxmLmxvYWRlZE9rYXkgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgIGlmICghYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICB0cnkge1xuICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIiArIHNjcmlwdC5pZCArIFwiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIH1cblxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIGlmIChzY3JpcHQyKSB7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5idWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsLCBudWxsKTtcbiAgdGhpcy54by5vbignY2h1bmsnLCB0aGlzLl9jaHVua0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi54byA9IG51bGw7XG4gICAgdmFyIHJlYXNvbiA9IHN0YXR1cyA9PT0gMjAwID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jaHVua0hhbmRsZXIgPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgZGVidWcoJ19jaHVua0hhbmRsZXInLCBzdGF0dXMpO1xuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAtMTsgOyB0aGlzLmJ1ZmZlclBvc2l0aW9uICs9IGlkeCArIDEpIHtcbiAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIGlkeCk7XG4gICAgaWYgKG1zZykge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICd1c2VyJyk7XG4gICAgdGhpcy54byA9IG51bGw7XG4gIH1cbiAgdGhpcy5fY2xlYW51cCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbn1cblxudmFyIGZvcm0sIGFyZWE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShpZCkge1xuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICB0cnkge1xuICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9ybSgpIHtcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgZm9ybSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcblxuICBhcmVhID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGFyZWEubmFtZSA9ICdkJztcbiAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIGRlYnVnKHVybCwgcGF5bG9hZCk7XG4gIGlmICghZm9ybSkge1xuICAgIGNyZWF0ZUZvcm0oKTtcbiAgfVxuICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBmb3JtLnRhcmdldCA9IGlkO1xuICBmb3JtLmFjdGlvbiA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL2pzb25wX3NlbmQnKSwgJ2k9JyArIGlkKTtcblxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcbiAgaWZyYW1lLmlkID0gaWQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgfVxuICBmb3JtLnN1Ym1pdCgpO1xuXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgaWYgKCFpZnJhbWUub25lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUgPSBudWxsO1xuICAgIH0sIDUwMCk7XG4gICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgaWYgdGhlIGlmcmFtZSBzdWNjZWVkZWQgb3JcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XG4gICAgY29tcGxldGVkKG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6eGRyJyk7XG59XG5cbi8vIFJlZmVyZW5jZXM6XG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcbi8vICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMjg4MDYwKHY9VlMuODUpLmFzcHhcblxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKFhEUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZygnX3N0YXJ0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcbiAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncHJvZ3Jlc3MnLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLmVtaXQoJ2NodW5rJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdsb2FkJyk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9O1xuICB0aGlzLnhkciA9IHhkcjtcbiAgdGhpcy51bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMueGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMueGRyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB0aGlzLl9lcnJvcigpO1xuICB9XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnLCBhYm9ydCk7XG4gIGlmICghdGhpcy54ZHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIHRoaXMueGRyLm9udGltZW91dCA9IHRoaXMueGRyLm9uZXJyb3IgPSB0aGlzLnhkci5vbnByb2dyZXNzID0gdGhpcy54ZHIub25sb2FkID0gbnVsbDtcbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGRyID0gbnVsbDtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XG5YRFJPYmplY3QuZW5hYmxlZCA9ICEhKGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiBicm93c2VyLmhhc0RvbWFpbigpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkZha2UoLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XG4gIH0sIFhIUkZha2UudGltZW91dCk7XG59XG5cbmluaGVyaXRzKFhIUkZha2UsIEV2ZW50RW1pdHRlcik7XG5cblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcbn07XG5cblhIUkZha2UudGltZW91dCA9IDIwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcblxufSx7XCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBXZWJzb2NrZXREcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlci93ZWJzb2NrZXQnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6d2Vic29ja2V0Jyk7XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydCh0cmFuc1VybCwgaWdub3JlLCBvcHRpb25zKSB7XG4gIGlmICghV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjb25zdHJ1Y3RvcicsIHRyYW5zVXJsKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCAnL3dlYnNvY2tldCcpO1xuICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgfVxuICB0aGlzLnVybCA9IHVybDtcblxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZSBldmVudCcsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgfTtcbiAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gIC8vIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2UuIEluIHN1Y2ggc2l0dWF0aW9uIGxldCdzIGxpZSAtXG4gIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NjA4NVxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkJyk7XG4gICAgc2VsZi53cy5jbG9zZSgpO1xuICB9KTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdjbG9zZSBldmVudCcsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1dlYlNvY2tldCBjb25uZWN0aW9uIGJyb2tlbicpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xuICBkZWJ1Zygnc2VuZCcsIG1zZyk7XG4gIHRoaXMud3Muc2VuZChtc2cpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAod3MpIHtcbiAgICB3cy5jbG9zZSgpO1xuICB9XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi9kcml2ZXIvd2Vic29ja2V0XCI6MTksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcblhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU3fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5mdW5jdGlvbiBYZHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8uY29va2llX25lZWRlZCB8fCBpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFhEUk9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZVNjaGVtZTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1zdHJlYW1pbmcnO1xuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiaW5oZXJpdHNcIjo1N31dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICA7XG5cbmZ1bmN0aW9uIFhoclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXBvbGxpbmcnO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qgc3VwcG9ydCB4aHItc3RyZWFtaW5nICM2MFxuICAvLyBCdXQgaXQgbWlnaHQgYmUgYWJsZSB0byAjOTJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1zdHJlYW1pbmcnO1xuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuLy8gYmVmb3JlIG9ubG9hZC4gVGhpcyBjYXVzZXMgdGhlIGxvYWQgaW5kaWNhdG9yIHRvIHNwaW4gaW5kZWZpbmV0ZWx5LlxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRCb2R5ID0gISFnbG9iYWwuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi91dGlscy9icm93c2VyXCI6NDQsXCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcbiAgLCBleHRyYUxvb2t1cDtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxMb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgdmFyIGk7XG4gIHZhciB1bnJvbGxlZCA9IHt9O1xuICB2YXIgYyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICB9XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OMy5zdHJpbmdpZnkoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYUVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFFc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcbiAgICB9KTtcbiAgfVxufTtcblxufSx7XCJqc29uM1wiOjU4fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL3JhbmRvbVwiOjUwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04zLnN0cmluZ2lmeSh7XG4gICAgICAgIHdpbmRvd0lkOiBtb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93SWRcbiAgICAgICwgdHlwZTogdHlwZVxuICAgICAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gICAgICB9KSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy4nLCB0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuLCBjcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgIC8vIGV4ZWN1dGVkLiBHaXZlIGl0IGZldyBzZWNvbmRzIHRvIGFjdHVhbGx5IGxvYWQgc3R1ZmYuXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25lcnJvcignb25sb2FkIHRpbWVvdXQnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG5cbi8qIGVzbGludCBuby11bmRlZjogXCJvZmZcIiwgbmV3LWNhcDogXCJvZmZcIiAqL1xuLCBjcmVhdGVIdG1sZmlsZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgdmFyIGRvYyA9IG5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUgPSBkb2MgPSBudWxsO1xuICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2Mub3BlbigpO1xuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xuICAgICAgICAgICAgICAnZG9jdW1lbnQuZG9tYWluPVwiJyArIGdsb2JhbC5kb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgIHZhciBjID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9IGZhbHNlO1xuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgbW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9ICh0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcbn1cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9icm93c2VyXCI6NDQsXCIuL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ09iamVjdCA9IHt9O1xuWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gIHZhciBsZXZlbEV4aXN0cztcblxuICB0cnkge1xuICAgIGxldmVsRXhpc3RzID0gZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseTtcbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgbG9nT2JqZWN0W2xldmVsXSA9IGxldmVsRXhpc3RzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH1cblxuLCBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5pc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG5cbn0se1wiY3J5cHRvXCI6NDN9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnRyYW5zcG9ydCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcbiAgICAgIHZhciB0cmFuc3BvcnRzID0ge1xuICAgICAgICBtYWluOiBbXVxuICAgICAgLCBmYWNhZGU6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKCF0cmFuc3BvcnRzV2hpdGVsaXN0KSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbdHJhbnNwb3J0c1doaXRlbGlzdF07XG4gICAgICB9XG5cbiAgICAgIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbih0cmFucykge1xuICAgICAgICBpZiAoIXRyYW5zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLnRyYW5zcG9ydE5hbWUgPT09ICd3ZWJzb2NrZXQnICYmIGluZm8ud2Vic29ja2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCBmcm9tIHNlcnZlcicsICd3ZWJzb2NrZXQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QuaW5kZXhPZih0cmFucy50cmFuc3BvcnROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBkZWJ1Zygnbm90IGluIHdoaXRlbGlzdCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XG4gICAgICAgICAgZGVidWcoJ2VuYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICB0cmFuc3BvcnRzLm1haW4ucHVzaCh0cmFucyk7XG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0cy5mYWNhZGUucHVzaCh0cmFucy5mYWNhZGVUcmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJ1cmwtcGFyc2VcIjo2MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gJzEuMS40JztcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMFxudmFyIG0gPSBzICogNjBcbnZhciBoID0gbSAqIDYwXG52YXIgZCA9IGggKiAyNFxudmFyIHkgPSBkICogMzY1LjI1XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWxcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgP1xuXHRcdFx0Zm10TG9uZyh2YWwpIDpcblx0XHRcdGZtdFNob3J0KHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKClcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZFxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbVxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogc1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCdcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCdcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSdcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncydcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnXG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnXG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWVcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnXG59XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2RlYnVnXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG59LHtcIm1zXCI6NTR9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICAvL1xuICAvLyBMaXR0bGUgbmlmdHkgcGFyc2luZyBoYWNrLCBsZXZlcmFnZSB0aGUgZmFjdCB0aGF0IFJlZ0V4cC5leGVjIGluY3JlbWVudHNcbiAgLy8gdGhlIGxhc3RJbmRleCBwcm9wZXJ0eSBzbyB3ZSBjYW4gY29udGludWUgZXhlY3V0aW5nIHRoaXMgbG9vcCB1bnRpbCB3ZSd2ZVxuICAvLyBwYXJzZWQgYWxsIHJlc3VsdHMuXG4gIC8vXG4gIGZvciAoO1xuICAgIHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSk7XG4gICAgcmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChwYXJ0WzFdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFydFsyXSlcbiAgKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW107XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcblxufSx7fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG5cbn0se31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgbG9sY2F0aW9uID0gcmVxdWlyZSgnLi9sb2xjYXRpb24nKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2k7XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIFVSTChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1syXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICAgIHVybC5wYXRobmFtZSA9IHZhbHVlLmxlbmd0aCAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09ICcvJyA/ICcvJyArIHZhbHVlIDogdmFsdWU7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVSTC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VUkwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVVJMLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVVJMLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVVJMO1xuXG59LHtcIi4vbG9sY2F0aW9uXCI6NjIsXCJxdWVyeXN0cmluZ2lmeVwiOjU5LFwicmVxdWlyZXMtcG9ydFwiOjYwfV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvLztcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH1cbiAgLCBVUkw7XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbiB8fCB7fTtcbiAgVVJMID0gVVJMIHx8IHJlcXVpcmUoJy4vJyk7XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVUkwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVUkwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL1wiOjYxfV19LHt9LFsxXSkoMSlcbn0pO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tqcy5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///10\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nvar SockJS = __webpack_require__(/*! sockjs-client/dist/sockjs */ 10);\\n\\nvar retries = 0;\\nvar sock = null;\\n\\nvar socket = function initSocket(url, handlers) {\\n  sock = new SockJS(url);\\n\\n  sock.onopen = function onopen() {\\n    retries = 0;\\n  };\\n\\n  sock.onclose = function onclose() {\\n    if (retries === 0) {\\n      handlers.close();\\n    }\\n\\n    // Try to reconnect.\\n    sock = null;\\n\\n    // After 10 retries stop trying, to prevent logspam.\\n    if (retries <= 10) {\\n      // Exponentially increase timeout to reconnect.\\n      // Respectfully copied from the package `got`.\\n      // eslint-disable-next-line no-mixed-operators, no-restricted-properties\\n      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;\\n      retries += 1;\\n\\n      setTimeout(function () {\\n        socket(url, handlers);\\n      }, retryInMs);\\n    }\\n  };\\n\\n  sock.onmessage = function onmessage(e) {\\n    // This assumes that all data sent via the websocket is JSON.\\n    var msg = JSON.parse(e.data);\\n    if (handlers[msg.type]) {\\n      handlers[msg.type](msg.data);\\n    }\\n  };\\n};\\n\\nmodule.exports = socket;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcz9lMjljIl0sIm5hbWVzIjpbIlNvY2tKUyIsInJlcXVpcmUiLCJyZXRyaWVzIiwic29jayIsInNvY2tldCIsImluaXRTb2NrZXQiLCJ1cmwiLCJoYW5kbGVycyIsIm9ub3BlbiIsIm9uY2xvc2UiLCJjbG9zZSIsInJldHJ5SW5NcyIsIk1hdGgiLCJwb3ciLCJyYW5kb20iLCJzZXRUaW1lb3V0Iiwib25tZXNzYWdlIiwiZSIsIm1zZyIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJ0eXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsSUFBSUEsU0FBUyxtQkFBQUMsQ0FBUSxtQ0FBUixDQUFiOztBQUVBLElBQUlDLFVBQVUsQ0FBZDtBQUNBLElBQUlDLE9BQU8sSUFBWDs7QUFFQSxJQUFJQyxTQUFTLFNBQVNDLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCQyxRQUF6QixFQUFtQztBQUM5Q0osU0FBTyxJQUFJSCxNQUFKLENBQVdNLEdBQVgsQ0FBUDs7QUFFQUgsT0FBS0ssTUFBTCxHQUFjLFNBQVNBLE1BQVQsR0FBa0I7QUFDOUJOLGNBQVUsQ0FBVjtBQUNELEdBRkQ7O0FBSUFDLE9BQUtNLE9BQUwsR0FBZSxTQUFTQSxPQUFULEdBQW1CO0FBQ2hDLFFBQUlQLFlBQVksQ0FBaEIsRUFBbUI7QUFDakJLLGVBQVNHLEtBQVQ7QUFDRDs7QUFFRDtBQUNBUCxXQUFPLElBQVA7O0FBRUE7QUFDQSxRQUFJRCxXQUFXLEVBQWYsRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBSVMsWUFBWSxPQUFPQyxLQUFLQyxHQUFMLENBQVMsQ0FBVCxFQUFZWCxPQUFaLENBQVAsR0FBOEJVLEtBQUtFLE1BQUwsS0FBZ0IsR0FBOUQ7QUFDQVosaUJBQVcsQ0FBWDs7QUFFQWEsaUJBQVcsWUFBWTtBQUNyQlgsZUFBT0UsR0FBUCxFQUFZQyxRQUFaO0FBQ0QsT0FGRCxFQUVHSSxTQUZIO0FBR0Q7QUFDRixHQXBCRDs7QUFzQkFSLE9BQUthLFNBQUwsR0FBaUIsU0FBU0EsU0FBVCxDQUFtQkMsQ0FBbkIsRUFBc0I7QUFDckM7QUFDQSxRQUFJQyxNQUFNQyxLQUFLQyxLQUFMLENBQVdILEVBQUVJLElBQWIsQ0FBVjtBQUNBLFFBQUlkLFNBQVNXLElBQUlJLElBQWIsQ0FBSixFQUF3QjtBQUN0QmYsZUFBU1csSUFBSUksSUFBYixFQUFtQkosSUFBSUcsSUFBdkI7QUFDRDtBQUNGLEdBTkQ7QUFPRCxDQXBDRDs7QUFzQ0FFLE9BQU9DLE9BQVAsR0FBaUJwQixNQUFqQiIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcblxudmFyIHJldHJpZXMgPSAwO1xudmFyIHNvY2sgPSBudWxsO1xuXG52YXIgc29ja2V0ID0gZnVuY3Rpb24gaW5pdFNvY2tldCh1cmwsIGhhbmRsZXJzKSB7XG4gIHNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG5cbiAgc29jay5vbm9wZW4gPSBmdW5jdGlvbiBvbm9wZW4oKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gIH07XG5cbiAgc29jay5vbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gcmVjb25uZWN0LlxuICAgIHNvY2sgPSBudWxsO1xuXG4gICAgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9O1xuXG4gIHNvY2sub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGUpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCBhbGwgZGF0YSBzZW50IHZpYSB0aGUgd2Vic29ja2V0IGlzIEpTT04uXG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICBpZiAoaGFuZGxlcnNbbXNnLnR5cGVdKSB7XG4gICAgICBoYW5kbGVyc1ttc2cudHlwZV0obXNnLmRhdGEpO1xuICAgIH1cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29ja2V0OyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///11\\n\")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\\n* loglevel - https://github.com/pimterry/loglevel\\n*\\n* Copyright (c) 2013 Tim Perry\\n* Licensed under the MIT license.\\n*/\\n(function (root, definition) {\\n    \"use strict\";\\n\\n    if (true) {\\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    } else {}\\n})(this, function () {\\n    \"use strict\";\\n\\n    // Slightly dubious tricks to cut down minimized file size\\n\\n    var noop = function () {};\\n    var undefinedType = \"undefined\";\\n\\n    var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\\n\\n    // Cross-browser bind equivalent that works at least back to IE6\\n    function bindMethod(obj, methodName) {\\n        var method = obj[methodName];\\n        if (typeof method.bind === \\'function\\') {\\n            return method.bind(obj);\\n        } else {\\n            try {\\n                return Function.prototype.bind.call(method, obj);\\n            } catch (e) {\\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\\n                return function () {\\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\\n                };\\n            }\\n        }\\n    }\\n\\n    // Build the best logging method possible for this env\\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\\n    function realMethod(methodName) {\\n        if (methodName === \\'debug\\') {\\n            methodName = \\'log\\';\\n        }\\n\\n        if (typeof console === undefinedType) {\\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\\n        } else if (console[methodName] !== undefined) {\\n            return bindMethod(console, methodName);\\n        } else if (console.log !== undefined) {\\n            return bindMethod(console, \\'log\\');\\n        } else {\\n            return noop;\\n        }\\n    }\\n\\n    // These private functions always need `this` to be set properly\\n\\n    function replaceLoggingMethods(level, loggerName) {\\n        /*jshint validthis:true */\\n        for (var i = 0; i < logMethods.length; i++) {\\n            var methodName = logMethods[i];\\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\\n        }\\n\\n        // Define log.log as an alias for log.debug\\n        this.log = this.debug;\\n    }\\n\\n    // In old IE versions, the console isn\\'t present until you first open it.\\n    // We build realMethod() replacements here that regenerate logging methods\\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\\n        return function () {\\n            if (typeof console !== undefinedType) {\\n                replaceLoggingMethods.call(this, level, loggerName);\\n                this[methodName].apply(this, arguments);\\n            }\\n        };\\n    }\\n\\n    // By default, we use closely bound real methods wherever possible, and\\n    // otherwise we wait for a console to appear, and then try again.\\n    function defaultMethodFactory(methodName, level, loggerName) {\\n        /*jshint validthis:true */\\n        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\\n    }\\n\\n    function Logger(name, defaultLevel, factory) {\\n        var self = this;\\n        var currentLevel;\\n        var storageKey = \"loglevel\";\\n        if (name) {\\n            storageKey += \":\" + name;\\n        }\\n\\n        function persistLevelIfPossible(levelNum) {\\n            var levelName = (logMethods[levelNum] || \\'silent\\').toUpperCase();\\n\\n            if (typeof window === undefinedType) return;\\n\\n            // Use localStorage if available\\n            try {\\n                window.localStorage[storageKey] = levelName;\\n                return;\\n            } catch (ignore) {}\\n\\n            // Use session cookie as fallback\\n            try {\\n                window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\\n            } catch (ignore) {}\\n        }\\n\\n        function getPersistedLevel() {\\n            var storedLevel;\\n\\n            if (typeof window === undefinedType) return;\\n\\n            try {\\n                storedLevel = window.localStorage[storageKey];\\n            } catch (ignore) {}\\n\\n            // Fallback to cookies if local storage gives us nothing\\n            if (typeof storedLevel === undefinedType) {\\n                try {\\n                    var cookie = window.document.cookie;\\n                    var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\\n                    if (location !== -1) {\\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\\n                    }\\n                } catch (ignore) {}\\n            }\\n\\n            // If the stored level is not valid, treat it as if nothing was stored.\\n            if (self.levels[storedLevel] === undefined) {\\n                storedLevel = undefined;\\n            }\\n\\n            return storedLevel;\\n        }\\n\\n        /*\\n         *\\n         * Public logger API - see https://github.com/pimterry/loglevel for details\\n         *\\n         */\\n\\n        self.name = name;\\n\\n        self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\\n            \"ERROR\": 4, \"SILENT\": 5 };\\n\\n        self.methodFactory = factory || defaultMethodFactory;\\n\\n        self.getLevel = function () {\\n            return currentLevel;\\n        };\\n\\n        self.setLevel = function (level, persist) {\\n            if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\\n                level = self.levels[level.toUpperCase()];\\n            }\\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\\n                currentLevel = level;\\n                if (persist !== false) {\\n                    // defaults to true\\n                    persistLevelIfPossible(level);\\n                }\\n                replaceLoggingMethods.call(self, level, name);\\n                if (typeof console === undefinedType && level < self.levels.SILENT) {\\n                    return \"No console available for logging\";\\n                }\\n            } else {\\n                throw \"log.setLevel() called with invalid level: \" + level;\\n            }\\n        };\\n\\n        self.setDefaultLevel = function (level) {\\n            if (!getPersistedLevel()) {\\n                self.setLevel(level, false);\\n            }\\n        };\\n\\n        self.enableAll = function (persist) {\\n            self.setLevel(self.levels.TRACE, persist);\\n        };\\n\\n        self.disableAll = function (persist) {\\n            self.setLevel(self.levels.SILENT, persist);\\n        };\\n\\n        // Initialize with the right level\\n        var initialLevel = getPersistedLevel();\\n        if (initialLevel == null) {\\n            initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\\n        }\\n        self.setLevel(initialLevel, false);\\n    }\\n\\n    /*\\n     *\\n     * Top-level API\\n     *\\n     */\\n\\n    var defaultLogger = new Logger();\\n\\n    var _loggersByName = {};\\n    defaultLogger.getLogger = function getLogger(name) {\\n        if (typeof name !== \"string\" || name === \"\") {\\n            throw new TypeError(\"You must supply a name when creating a logger.\");\\n        }\\n\\n        var logger = _loggersByName[name];\\n        if (!logger) {\\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\\n        }\\n        return logger;\\n    };\\n\\n    // Grab the current global log variable in case of overwrite\\n    var _log = typeof window !== undefinedType ? window.log : undefined;\\n    defaultLogger.noConflict = function () {\\n        if (typeof window !== undefinedType && window.log === defaultLogger) {\\n            window.log = _log;\\n        }\\n\\n        return defaultLogger;\\n    };\\n\\n    defaultLogger.getLoggers = function getLoggers() {\\n        return _loggersByName;\\n    };\\n\\n    return defaultLogger;\\n});//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzVjN2QiXSwibmFtZXMiOlsicm9vdCIsImRlZmluaXRpb24iLCJkZWZpbmUiLCJub29wIiwidW5kZWZpbmVkVHlwZSIsImxvZ01ldGhvZHMiLCJiaW5kTWV0aG9kIiwib2JqIiwibWV0aG9kTmFtZSIsIm1ldGhvZCIsImJpbmQiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImNhbGwiLCJlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJyZWFsTWV0aG9kIiwiY29uc29sZSIsInVuZGVmaW5lZCIsImxvZyIsInJlcGxhY2VMb2dnaW5nTWV0aG9kcyIsImxldmVsIiwibG9nZ2VyTmFtZSIsImkiLCJsZW5ndGgiLCJtZXRob2RGYWN0b3J5IiwiZGVidWciLCJlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzIiwiZGVmYXVsdE1ldGhvZEZhY3RvcnkiLCJMb2dnZXIiLCJuYW1lIiwiZGVmYXVsdExldmVsIiwiZmFjdG9yeSIsInNlbGYiLCJjdXJyZW50TGV2ZWwiLCJzdG9yYWdlS2V5IiwicGVyc2lzdExldmVsSWZQb3NzaWJsZSIsImxldmVsTnVtIiwibGV2ZWxOYW1lIiwidG9VcHBlckNhc2UiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJpZ25vcmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImdldFBlcnNpc3RlZExldmVsIiwic3RvcmVkTGV2ZWwiLCJsb2NhdGlvbiIsImluZGV4T2YiLCJleGVjIiwic2xpY2UiLCJsZXZlbHMiLCJnZXRMZXZlbCIsInNldExldmVsIiwicGVyc2lzdCIsIlNJTEVOVCIsInNldERlZmF1bHRMZXZlbCIsImVuYWJsZUFsbCIsIlRSQUNFIiwiZGlzYWJsZUFsbCIsImluaXRpYWxMZXZlbCIsImRlZmF1bHRMb2dnZXIiLCJfbG9nZ2Vyc0J5TmFtZSIsImdldExvZ2dlciIsIlR5cGVFcnJvciIsImxvZ2dl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IC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///12\\n')},function(module,exports){eval(\"throw new Error(\\\"Module build failed: Error: ENOENT: no such file or directory, open 'D:\\\\\\\\workspace\\\\\\\\onePageStuff\\\\\\\\node_modules\\\\\\\\ansi-regex\\\\\\\\index.js'\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///13\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nvar ansiRegex = __webpack_require__(/*! ansi-regex */ 13)();\\n\\nmodule.exports = function (str) {\\n\\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcz83NjcxIl0sIm5hbWVzIjpbImFuc2lSZWdleCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwic3RyIiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsWUFBWSxtQkFBQUMsQ0FBUSxvQkFBUixHQUFoQjs7QUFFQUMsT0FBT0MsT0FBUCxHQUFpQixVQUFVQyxHQUFWLEVBQWU7QUFDL0IsUUFBTyxPQUFPQSxHQUFQLEtBQWUsUUFBZixHQUEwQkEsSUFBSUMsT0FBSixDQUFZTCxTQUFaLEVBQXVCLEVBQXZCLENBQTFCLEdBQXVESSxHQUE5RDtBQUNBLENBRkQiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIucmVwbGFjZShhbnNpUmVnZXgsICcnKSA6IHN0cjtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///14\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\n\\nvar stringifyPrimitive = function (v) {\\n  switch (typeof v) {\\n    case 'string':\\n      return v;\\n\\n    case 'boolean':\\n      return v ? 'true' : 'false';\\n\\n    case 'number':\\n      return isFinite(v) ? v : '';\\n\\n    default:\\n      return '';\\n  }\\n};\\n\\nmodule.exports = function (obj, sep, eq, name) {\\n  sep = sep || '&';\\n  eq = eq || '=';\\n  if (obj === null) {\\n    obj = undefined;\\n  }\\n\\n  if (typeof obj === 'object') {\\n    return map(objectKeys(obj), function (k) {\\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\\n      if (isArray(obj[k])) {\\n        return map(obj[k], function (v) {\\n          return ks + encodeURIComponent(stringifyPrimitive(v));\\n        }).join(sep);\\n      } else {\\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\\n      }\\n    }).join(sep);\\n  }\\n\\n  if (!name) return '';\\n  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\\n};\\n\\nvar isArray = Array.isArray || function (xs) {\\n  return Object.prototype.toString.call(xs) === '[object Array]';\\n};\\n\\nfunction map(xs, f) {\\n  if (xs.map) return xs.map(f);\\n  var res = [];\\n  for (var i = 0; i < xs.length; i++) {\\n    res.push(f(xs[i], i));\\n  }\\n  return res;\\n}\\n\\nvar objectKeys = Object.keys || function (obj) {\\n  var res = [];\\n  for (var key in obj) {\\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\\n  }\\n  return res;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcz9lMDk5Il0sIm5hbWVzIjpbInN0cmluZ2lmeVByaW1pdGl2ZSIsInYiLCJpc0Zpbml0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJvYmoiLCJzZXAiLCJlcSIsIm5hbWUiLCJ1bmRlZmluZWQiLCJtYXAiLCJvYmplY3RLZXlzIiwiayIsImtzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaXNBcnJheSIsImpvaW4iLCJBcnJheSIsInhzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiZiIsInJlcyIsImkiLCJsZW5ndGgiLCJwdXNoIiwia2V5cyIsImtleSIsImhhc093blByb3BlcnR5Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUlBLHFCQUFxQixVQUFTQyxDQUFULEVBQVk7QUFDbkMsVUFBUSxPQUFPQSxDQUFmO0FBQ0UsU0FBSyxRQUFMO0FBQ0UsYUFBT0EsQ0FBUDs7QUFFRixTQUFLLFNBQUw7QUFDRSxhQUFPQSxJQUFJLE1BQUosR0FBYSxPQUFwQjs7QUFFRixTQUFLLFFBQUw7QUFDRSxhQUFPQyxTQUFTRCxDQUFULElBQWNBLENBQWQsR0FBa0IsRUFBekI7O0FBRUY7QUFDRSxhQUFPLEVBQVA7QUFYSjtBQWFELENBZEQ7O0FBZ0JBRSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNDLEdBQVQsRUFBY0MsR0FBZCxFQUFtQkMsRUFBbkIsRUFBdUJDLElBQXZCLEVBQTZCO0FBQzVDRixRQUFNQSxPQUFPLEdBQWI7QUFDQUMsT0FBS0EsTUFBTSxHQUFYO0FBQ0EsTUFBSUYsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCQSxVQUFNSSxTQUFOO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPSixHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsV0FBT0ssSUFBSUMsV0FBV04sR0FBWCxDQUFKLEVBQXFCLFVBQVNPLENBQVQsRUFBWTtBQUN0QyxVQUFJQyxLQUFLQyxtQkFBbUJkLG1CQUFtQlksQ0FBbkIsQ0FBbkIsSUFBNENMLEVBQXJEO0FBQ0EsVUFBSVEsUUFBUVYsSUFBSU8sQ0FBSixDQUFSLENBQUosRUFBcUI7QUFDbkIsZUFBT0YsSUFBSUwsSUFBSU8sQ0FBSixDQUFKLEVBQVksVUFBU1gsQ0FBVCxFQUFZO0FBQzdCLGlCQUFPWSxLQUFLQyxtQkFBbUJkLG1CQUFtQkMsQ0FBbkIsQ0FBbkIsQ0FBWjtBQUNELFNBRk0sRUFFSmUsSUFGSSxDQUVDVixHQUZELENBQVA7QUFHRCxPQUpELE1BSU87QUFDTCxlQUFPTyxLQUFLQyxtQkFBbUJkLG1CQUFtQkssSUFBSU8sQ0FBSixDQUFuQixDQUFuQixDQUFaO0FBQ0Q7QUFDRixLQVRNLEVBU0pJLElBVEksQ0FTQ1YsR0FURCxDQUFQO0FBV0Q7O0FBRUQsTUFBSSxDQUFDRSxJQUFMLEVBQVcsT0FBTyxFQUFQO0FBQ1gsU0FBT00sbUJBQW1CZCxtQkFBbUJRLElBQW5CLENBQW5CLElBQStDRCxFQUEvQyxHQUNBTyxtQkFBbUJkLG1CQUFtQkssR0FBbkIsQ0FBbkIsQ0FEUDtBQUVELENBeEJEOztBQTBCQSxJQUFJVSxVQUFVRSxNQUFNRixPQUFOLElBQWlCLFVBQVVHLEVBQVYsRUFBYztBQUMzQyxTQUFPQyxPQUFPQyxTQUFQLENBQWlCQyxRQUFqQixDQUEwQkMsSUFBMUIsQ0FBK0JKLEVBQS9CLE1BQXVDLGdCQUE5QztBQUNELENBRkQ7O0FBSUEsU0FBU1IsR0FBVCxDQUFjUSxFQUFkLEVBQWtCSyxDQUFsQixFQUFxQjtBQUNuQixNQUFJTCxHQUFHUixHQUFQLEVBQVksT0FBT1EsR0FBR1IsR0FBSCxDQUFPYSxDQUFQLENBQVA7QUFDWixNQUFJQyxNQUFNLEVBQVY7QUFDQSxPQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSVAsR0FBR1EsTUFBdkIsRUFBK0JELEdBQS9CLEVBQW9DO0FBQ2xDRCxRQUFJRyxJQUFKLENBQVNKLEVBQUVMLEdBQUdPLENBQUgsQ0FBRixFQUFTQSxDQUFULENBQVQ7QUFDRDtBQUNELFNBQU9ELEdBQVA7QUFDRDs7QUFFRCxJQUFJYixhQUFhUSxPQUFPUyxJQUFQLElBQWUsVUFBVXZCLEdBQVYsRUFBZTtBQUM3QyxNQUFJbUIsTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJSyxHQUFULElBQWdCeEIsR0FBaEIsRUFBcUI7QUFDbkIsUUFBSWMsT0FBT0MsU0FBUCxDQUFpQlUsY0FBakIsQ0FBZ0NSLElBQWhDLENBQXFDakIsR0FBckMsRUFBMEN3QixHQUExQyxDQUFKLEVBQW9ETCxJQUFJRyxJQUFKLENBQVNFLEdBQVQ7QUFDckQ7QUFDRCxTQUFPTCxHQUFQO0FBQ0QsQ0FORCIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///15\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\n\\n// If obj.hasOwnProperty has been overridden, then calling\\n// obj.hasOwnProperty(prop) will break.\\n// See: https://github.com/joyent/node/issues/1707\\n\\nfunction hasOwnProperty(obj, prop) {\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\n}\\n\\nmodule.exports = function (qs, sep, eq, options) {\\n  sep = sep || '&';\\n  eq = eq || '=';\\n  var obj = {};\\n\\n  if (typeof qs !== 'string' || qs.length === 0) {\\n    return obj;\\n  }\\n\\n  var regexp = /\\\\+/g;\\n  qs = qs.split(sep);\\n\\n  var maxKeys = 1000;\\n  if (options && typeof options.maxKeys === 'number') {\\n    maxKeys = options.maxKeys;\\n  }\\n\\n  var len = qs.length;\\n  // maxKeys <= 0 means that we should not limit keys count\\n  if (maxKeys > 0 && len > maxKeys) {\\n    len = maxKeys;\\n  }\\n\\n  for (var i = 0; i < len; ++i) {\\n    var x = qs[i].replace(regexp, '%20'),\\n        idx = x.indexOf(eq),\\n        kstr,\\n        vstr,\\n        k,\\n        v;\\n\\n    if (idx >= 0) {\\n      kstr = x.substr(0, idx);\\n      vstr = x.substr(idx + 1);\\n    } else {\\n      kstr = x;\\n      vstr = '';\\n    }\\n\\n    k = decodeURIComponent(kstr);\\n    v = decodeURIComponent(vstr);\\n\\n    if (!hasOwnProperty(obj, k)) {\\n      obj[k] = v;\\n    } else if (isArray(obj[k])) {\\n      obj[k].push(v);\\n    } else {\\n      obj[k] = [obj[k], v];\\n    }\\n  }\\n\\n  return obj;\\n};\\n\\nvar isArray = Array.isArray || function (xs) {\\n  return Object.prototype.toString.call(xs) === '[object Array]';\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcz85MWRkIl0sIm5hbWVzIjpbImhhc093blByb3BlcnR5Iiwib2JqIiwicHJvcCIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJtb2R1bGUiLCJleHBvcnRzIiwicXMiLCJzZXAiLCJlcSIsIm9wdGlvbnMiLCJsZW5ndGgiLCJyZWdleHAiLCJzcGxpdCIsIm1heEtleXMiLCJsZW4iLCJpIiwieCIsInJlcGxhY2UiLCJpZHgiLCJpbmRleE9mIiwia3N0ciIsInZzdHIiLCJrIiwidiIsInN1YnN0ciIsImRlY29kZVVSSUNvbXBvbmVudCIsImlzQXJyYXkiLCJwdXNoIiwiQXJyYXkiLCJ4cyIsInRvU3RyaW5nIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTQSxjQUFULENBQXdCQyxHQUF4QixFQUE2QkMsSUFBN0IsRUFBbUM7QUFDakMsU0FBT0MsT0FBT0MsU0FBUCxDQUFpQkosY0FBakIsQ0FBZ0NLLElBQWhDLENBQXFDSixHQUFyQyxFQUEwQ0MsSUFBMUMsQ0FBUDtBQUNEOztBQUVESSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNDLEVBQVQsRUFBYUMsR0FBYixFQUFrQkMsRUFBbEIsRUFBc0JDLE9BQXRCLEVBQStCO0FBQzlDRixRQUFNQSxPQUFPLEdBQWI7QUFDQUMsT0FBS0EsTUFBTSxHQUFYO0FBQ0EsTUFBSVQsTUFBTSxFQUFWOztBQUVBLE1BQUksT0FBT08sRUFBUCxLQUFjLFFBQWQsSUFBMEJBLEdBQUdJLE1BQUgsS0FBYyxDQUE1QyxFQUErQztBQUM3QyxXQUFPWCxHQUFQO0FBQ0Q7O0FBRUQsTUFBSVksU0FBUyxLQUFiO0FBQ0FMLE9BQUtBLEdBQUdNLEtBQUgsQ0FBU0wsR0FBVCxDQUFMOztBQUVBLE1BQUlNLFVBQVUsSUFBZDtBQUNBLE1BQUlKLFdBQVcsT0FBT0EsUUFBUUksT0FBZixLQUEyQixRQUExQyxFQUFvRDtBQUNsREEsY0FBVUosUUFBUUksT0FBbEI7QUFDRDs7QUFFRCxNQUFJQyxNQUFNUixHQUFHSSxNQUFiO0FBQ0E7QUFDQSxNQUFJRyxVQUFVLENBQVYsSUFBZUMsTUFBTUQsT0FBekIsRUFBa0M7QUFDaENDLFVBQU1ELE9BQU47QUFDRDs7QUFFRCxPQUFLLElBQUlFLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsR0FBcEIsRUFBeUIsRUFBRUMsQ0FBM0IsRUFBOEI7QUFDNUIsUUFBSUMsSUFBSVYsR0FBR1MsQ0FBSCxFQUFNRSxPQUFOLENBQWNOLE1BQWQsRUFBc0IsS0FBdEIsQ0FBUjtBQUFBLFFBQ0lPLE1BQU1GLEVBQUVHLE9BQUYsQ0FBVVgsRUFBVixDQURWO0FBQUEsUUFFSVksSUFGSjtBQUFBLFFBRVVDLElBRlY7QUFBQSxRQUVnQkMsQ0FGaEI7QUFBQSxRQUVtQkMsQ0FGbkI7O0FBSUEsUUFBSUwsT0FBTyxDQUFYLEVBQWM7QUFDWkUsYUFBT0osRUFBRVEsTUFBRixDQUFTLENBQVQsRUFBWU4sR0FBWixDQUFQO0FBQ0FHLGFBQU9MLEVBQUVRLE1BQUYsQ0FBU04sTUFBTSxDQUFmLENBQVA7QUFDRCxLQUhELE1BR087QUFDTEUsYUFBT0osQ0FBUDtBQUNBSyxhQUFPLEVBQVA7QUFDRDs7QUFFREMsUUFBSUcsbUJBQW1CTCxJQUFuQixDQUFKO0FBQ0FHLFFBQUlFLG1CQUFtQkosSUFBbkIsQ0FBSjs7QUFFQSxRQUFJLENBQUN2QixlQUFlQyxHQUFmLEVBQW9CdUIsQ0FBcEIsQ0FBTCxFQUE2QjtBQUMzQnZCLFVBQUl1QixDQUFKLElBQVNDLENBQVQ7QUFDRCxLQUZELE1BRU8sSUFBSUcsUUFBUTNCLElBQUl1QixDQUFKLENBQVIsQ0FBSixFQUFxQjtBQUMxQnZCLFVBQUl1QixDQUFKLEVBQU9LLElBQVAsQ0FBWUosQ0FBWjtBQUNELEtBRk0sTUFFQTtBQUNMeEIsVUFBSXVCLENBQUosSUFBUyxDQUFDdkIsSUFBSXVCLENBQUosQ0FBRCxFQUFTQyxDQUFULENBQVQ7QUFDRDtBQUNGOztBQUVELFNBQU94QixHQUFQO0FBQ0QsQ0FqREQ7O0FBbURBLElBQUkyQixVQUFVRSxNQUFNRixPQUFOLElBQWlCLFVBQVVHLEVBQVYsRUFBYztBQUMzQyxTQUFPNUIsT0FBT0MsU0FBUCxDQUFpQjRCLFFBQWpCLENBQTBCM0IsSUFBMUIsQ0FBK0IwQixFQUEvQixNQUF1QyxnQkFBOUM7QUFDRCxDQUZEIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///16\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ 16);\\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ 15);//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzP2IzODMiXSwibmFtZXMiOlsiZXhwb3J0cyIsImRlY29kZSIsInBhcnNlIiwicmVxdWlyZSIsImVuY29kZSIsInN0cmluZ2lmeSJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUFBLFFBQVFDLE1BQVIsR0FBaUJELFFBQVFFLEtBQVIsR0FBZ0IsbUJBQUFDLENBQVEsa0JBQVIsQ0FBakM7QUFDQUgsUUFBUUksTUFBUixHQUFpQkosUUFBUUssU0FBUixHQUFvQixtQkFBQUYsQ0FBUSxrQkFBUixDQUFyQyIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///17\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nmodule.exports = {\\n  isString: function (arg) {\\n    return typeof arg === 'string';\\n  },\\n  isObject: function (arg) {\\n    return typeof arg === 'object' && arg !== null;\\n  },\\n  isNull: function (arg) {\\n    return arg === null;\\n  },\\n  isNullOrUndefined: function (arg) {\\n    return arg == null;\\n  }\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanM/MzVlOCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiaXNTdHJpbmciLCJhcmciLCJpc09iamVjdCIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQUEsT0FBT0MsT0FBUCxHQUFpQjtBQUNmQyxZQUFVLFVBQVNDLEdBQVQsRUFBYztBQUN0QixXQUFPLE9BQU9BLEdBQVAsS0FBZ0IsUUFBdkI7QUFDRCxHQUhjO0FBSWZDLFlBQVUsVUFBU0QsR0FBVCxFQUFjO0FBQ3RCLFdBQU8sT0FBT0EsR0FBUCxLQUFnQixRQUFoQixJQUE0QkEsUUFBUSxJQUEzQztBQUNELEdBTmM7QUFPZkUsVUFBUSxVQUFTRixHQUFULEVBQWM7QUFDcEIsV0FBT0EsUUFBUSxJQUFmO0FBQ0QsR0FUYztBQVVmRyxxQkFBbUIsVUFBU0gsR0FBVCxFQUFjO0FBQy9CLFdBQU9BLE9BQU8sSUFBZDtBQUNEO0FBWmMsQ0FBakIiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///18\\n\")},function(module,exports){eval('module.exports = function (module) {\\n\\tif (!module.webpackPolyfill) {\\n\\t\\tmodule.deprecate = function () {};\\n\\t\\tmodule.paths = [];\\n\\t\\t// module.parent = undefined by default\\n\\t\\tif (!module.children) module.children = [];\\n\\t\\tObject.defineProperty(module, \"loaded\", {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tget: function () {\\n\\t\\t\\t\\treturn module.l;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tObject.defineProperty(module, \"id\", {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tget: function () {\\n\\t\\t\\t\\treturn module.i;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tmodule.webpackPolyfill = 1;\\n\\t}\\n\\treturn module;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJsIiwiaSJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU9DLE9BQVAsR0FBaUIsVUFBU0QsTUFBVCxFQUFpQjtBQUNqQyxLQUFJLENBQUNBLE9BQU9FLGVBQVosRUFBNkI7QUFDNUJGLFNBQU9HLFNBQVAsR0FBbUIsWUFBVyxDQUFFLENBQWhDO0FBQ0FILFNBQU9JLEtBQVAsR0FBZSxFQUFmO0FBQ0E7QUFDQSxNQUFJLENBQUNKLE9BQU9LLFFBQVosRUFBc0JMLE9BQU9LLFFBQVAsR0FBa0IsRUFBbEI7QUFDdEJDLFNBQU9DLGNBQVAsQ0FBc0JQLE1BQXRCLEVBQThCLFFBQTlCLEVBQXdDO0FBQ3ZDUSxlQUFZLElBRDJCO0FBRXZDQyxRQUFLLFlBQVc7QUFDZixXQUFPVCxPQUFPVSxDQUFkO0FBQ0E7QUFKc0MsR0FBeEM7QUFNQUosU0FBT0MsY0FBUCxDQUFzQlAsTUFBdEIsRUFBOEIsSUFBOUIsRUFBb0M7QUFDbkNRLGVBQVksSUFEdUI7QUFFbkNDLFFBQUssWUFBVztBQUNmLFdBQU9ULE9BQU9XLENBQWQ7QUFDQTtBQUprQyxHQUFwQztBQU1BWCxTQUFPRSxlQUFQLEdBQXlCLENBQXpCO0FBQ0E7QUFDRCxRQUFPRixNQUFQO0FBQ0EsQ0FyQkQiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///19\\n')},function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\\n;(function (root) {\\n\\n\\t/** Detect free variables */\\n\\tvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\\n\\tvar freeModule = typeof module == 'object' && module && !module.nodeType && module;\\n\\tvar freeGlobal = typeof global == 'object' && global;\\n\\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\\n\\t\\troot = freeGlobal;\\n\\t}\\n\\n\\t/**\\n  * The `punycode` object.\\n  * @name punycode\\n  * @type Object\\n  */\\n\\tvar punycode,\\n\\n\\n\\t/** Highest positive signed 32-bit float value */\\n\\tmaxInt = 2147483647,\\n\\t    // aka. 0x7FFFFFFF or 2^31-1\\n\\n\\t/** Bootstring parameters */\\n\\tbase = 36,\\n\\t    tMin = 1,\\n\\t    tMax = 26,\\n\\t    skew = 38,\\n\\t    damp = 700,\\n\\t    initialBias = 72,\\n\\t    initialN = 128,\\n\\t    // 0x80\\n\\tdelimiter = '-',\\n\\t    // '\\\\x2D'\\n\\n\\t/** Regular expressions */\\n\\tregexPunycode = /^xn--/,\\n\\t    regexNonASCII = /[^\\\\x20-\\\\x7E]/,\\n\\t    // unprintable ASCII chars + non-ASCII chars\\n\\tregexSeparators = /[\\\\x2E\\\\u3002\\\\uFF0E\\\\uFF61]/g,\\n\\t    // RFC 3490 separators\\n\\n\\t/** Error messages */\\n\\terrors = {\\n\\t\\t'overflow': 'Overflow: input needs wider integers to process',\\n\\t\\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\\n\\t\\t'invalid-input': 'Invalid input'\\n\\t},\\n\\n\\n\\t/** Convenience shortcuts */\\n\\tbaseMinusTMin = base - tMin,\\n\\t    floor = Math.floor,\\n\\t    stringFromCharCode = String.fromCharCode,\\n\\n\\n\\t/** Temporary variable */\\n\\tkey;\\n\\n\\t/*--------------------------------------------------------------------------*/\\n\\n\\t/**\\n  * A generic error utility function.\\n  * @private\\n  * @param {String} type The error type.\\n  * @returns {Error} Throws a `RangeError` with the applicable error message.\\n  */\\n\\tfunction error(type) {\\n\\t\\tthrow new RangeError(errors[type]);\\n\\t}\\n\\n\\t/**\\n  * A generic `Array#map` utility function.\\n  * @private\\n  * @param {Array} array The array to iterate over.\\n  * @param {Function} callback The function that gets called for every array\\n  * item.\\n  * @returns {Array} A new array of values returned by the callback function.\\n  */\\n\\tfunction map(array, fn) {\\n\\t\\tvar length = array.length;\\n\\t\\tvar result = [];\\n\\t\\twhile (length--) {\\n\\t\\t\\tresult[length] = fn(array[length]);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n  * A simple `Array#map`-like wrapper to work with domain name strings or email\\n  * addresses.\\n  * @private\\n  * @param {String} domain The domain name or email address.\\n  * @param {Function} callback The function that gets called for every\\n  * character.\\n  * @returns {Array} A new string of characters returned by the callback\\n  * function.\\n  */\\n\\tfunction mapDomain(string, fn) {\\n\\t\\tvar parts = string.split('@');\\n\\t\\tvar result = '';\\n\\t\\tif (parts.length > 1) {\\n\\t\\t\\t// In email addresses, only the domain name should be punycoded. Leave\\n\\t\\t\\t// the local part (i.e. everything up to `@`) intact.\\n\\t\\t\\tresult = parts[0] + '@';\\n\\t\\t\\tstring = parts[1];\\n\\t\\t}\\n\\t\\t// Avoid `split(regex)` for IE8 compatibility. See #17.\\n\\t\\tstring = string.replace(regexSeparators, '\\\\x2E');\\n\\t\\tvar labels = string.split('.');\\n\\t\\tvar encoded = map(labels, fn).join('.');\\n\\t\\treturn result + encoded;\\n\\t}\\n\\n\\t/**\\n  * Creates an array containing the numeric code points of each Unicode\\n  * character in the string. While JavaScript uses UCS-2 internally,\\n  * this function will convert a pair of surrogate halves (each of which\\n  * UCS-2 exposes as separate characters) into a single code point,\\n  * matching UTF-16.\\n  * @see `punycode.ucs2.encode`\\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n  * @memberOf punycode.ucs2\\n  * @name decode\\n  * @param {String} string The Unicode input string (UCS-2).\\n  * @returns {Array} The new array of code points.\\n  */\\n\\tfunction ucs2decode(string) {\\n\\t\\tvar output = [],\\n\\t\\t    counter = 0,\\n\\t\\t    length = string.length,\\n\\t\\t    value,\\n\\t\\t    extra;\\n\\t\\twhile (counter < length) {\\n\\t\\t\\tvalue = string.charCodeAt(counter++);\\n\\t\\t\\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\\n\\t\\t\\t\\t// high surrogate, and there is a next character\\n\\t\\t\\t\\textra = string.charCodeAt(counter++);\\n\\t\\t\\t\\tif ((extra & 0xFC00) == 0xDC00) {\\n\\t\\t\\t\\t\\t// low surrogate\\n\\t\\t\\t\\t\\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// unmatched surrogate; only append this code unit, in case the next\\n\\t\\t\\t\\t\\t// code unit is the high surrogate of a surrogate pair\\n\\t\\t\\t\\t\\toutput.push(value);\\n\\t\\t\\t\\t\\tcounter--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput.push(value);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn output;\\n\\t}\\n\\n\\t/**\\n  * Creates a string based on an array of numeric code points.\\n  * @see `punycode.ucs2.decode`\\n  * @memberOf punycode.ucs2\\n  * @name encode\\n  * @param {Array} codePoints The array of numeric code points.\\n  * @returns {String} The new Unicode string (UCS-2).\\n  */\\n\\tfunction ucs2encode(array) {\\n\\t\\treturn map(array, function (value) {\\n\\t\\t\\tvar output = '';\\n\\t\\t\\tif (value > 0xFFFF) {\\n\\t\\t\\t\\tvalue -= 0x10000;\\n\\t\\t\\t\\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\\n\\t\\t\\t\\tvalue = 0xDC00 | value & 0x3FF;\\n\\t\\t\\t}\\n\\t\\t\\toutput += stringFromCharCode(value);\\n\\t\\t\\treturn output;\\n\\t\\t}).join('');\\n\\t}\\n\\n\\t/**\\n  * Converts a basic code point into a digit/integer.\\n  * @see `digitToBasic()`\\n  * @private\\n  * @param {Number} codePoint The basic numeric code point value.\\n  * @returns {Number} The numeric value of a basic code point (for use in\\n  * representing integers) in the range `0` to `base - 1`, or `base` if\\n  * the code point does not represent a value.\\n  */\\n\\tfunction basicToDigit(codePoint) {\\n\\t\\tif (codePoint - 48 < 10) {\\n\\t\\t\\treturn codePoint - 22;\\n\\t\\t}\\n\\t\\tif (codePoint - 65 < 26) {\\n\\t\\t\\treturn codePoint - 65;\\n\\t\\t}\\n\\t\\tif (codePoint - 97 < 26) {\\n\\t\\t\\treturn codePoint - 97;\\n\\t\\t}\\n\\t\\treturn base;\\n\\t}\\n\\n\\t/**\\n  * Converts a digit/integer into a basic code point.\\n  * @see `basicToDigit()`\\n  * @private\\n  * @param {Number} digit The numeric value of a basic code point.\\n  * @returns {Number} The basic code point whose value (when used for\\n  * representing integers) is `digit`, which needs to be in the range\\n  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\\n  * used; else, the lowercase form is used. The behavior is undefined\\n  * if `flag` is non-zero and `digit` has no uppercase form.\\n  */\\n\\tfunction digitToBasic(digit, flag) {\\n\\t\\t//  0..25 map to ASCII a..z or A..Z\\n\\t\\t// 26..35 map to ASCII 0..9\\n\\t\\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\\n\\t}\\n\\n\\t/**\\n  * Bias adaptation function as per section 3.4 of RFC 3492.\\n  * https://tools.ietf.org/html/rfc3492#section-3.4\\n  * @private\\n  */\\n\\tfunction adapt(delta, numPoints, firstTime) {\\n\\t\\tvar k = 0;\\n\\t\\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\\n\\t\\tdelta += floor(delta / numPoints);\\n\\t\\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\\n\\t\\t\\tdelta = floor(delta / baseMinusTMin);\\n\\t\\t}\\n\\t\\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\\n\\t}\\n\\n\\t/**\\n  * Converts a Punycode string of ASCII-only symbols to a string of Unicode\\n  * symbols.\\n  * @memberOf punycode\\n  * @param {String} input The Punycode string of ASCII-only symbols.\\n  * @returns {String} The resulting string of Unicode symbols.\\n  */\\n\\tfunction decode(input) {\\n\\t\\t// Don't use UCS-2\\n\\t\\tvar output = [],\\n\\t\\t    inputLength = input.length,\\n\\t\\t    out,\\n\\t\\t    i = 0,\\n\\t\\t    n = initialN,\\n\\t\\t    bias = initialBias,\\n\\t\\t    basic,\\n\\t\\t    j,\\n\\t\\t    index,\\n\\t\\t    oldi,\\n\\t\\t    w,\\n\\t\\t    k,\\n\\t\\t    digit,\\n\\t\\t    t,\\n\\n\\t\\t/** Cached calculation results */\\n\\t\\tbaseMinusT;\\n\\n\\t\\t// Handle the basic code points: let `basic` be the number of input code\\n\\t\\t// points before the last delimiter, or `0` if there is none, then copy\\n\\t\\t// the first basic code points to the output.\\n\\n\\t\\tbasic = input.lastIndexOf(delimiter);\\n\\t\\tif (basic < 0) {\\n\\t\\t\\tbasic = 0;\\n\\t\\t}\\n\\n\\t\\tfor (j = 0; j < basic; ++j) {\\n\\t\\t\\t// if it's not a basic code point\\n\\t\\t\\tif (input.charCodeAt(j) >= 0x80) {\\n\\t\\t\\t\\terror('not-basic');\\n\\t\\t\\t}\\n\\t\\t\\toutput.push(input.charCodeAt(j));\\n\\t\\t}\\n\\n\\t\\t// Main decoding loop: start just after the last delimiter if any basic code\\n\\t\\t// points were copied; start at the beginning otherwise.\\n\\n\\t\\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\\n\\n\\t\\t\\t// `index` is the index of the next character to be consumed.\\n\\t\\t\\t// Decode a generalized variable-length integer into `delta`,\\n\\t\\t\\t// which gets added to `i`. The overflow checking is easier\\n\\t\\t\\t// if we increase `i` as we go, then subtract off its starting\\n\\t\\t\\t// value at the end to obtain `delta`.\\n\\t\\t\\tfor (oldi = i, w = 1, k = base;; /* no condition */k += base) {\\n\\n\\t\\t\\t\\tif (index >= inputLength) {\\n\\t\\t\\t\\t\\terror('invalid-input');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdigit = basicToDigit(input.charCodeAt(index++));\\n\\n\\t\\t\\t\\tif (digit >= base || digit > floor((maxInt - i) / w)) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ti += digit * w;\\n\\t\\t\\t\\tt = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\\n\\n\\t\\t\\t\\tif (digit < t) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbaseMinusT = base - t;\\n\\t\\t\\t\\tif (w > floor(maxInt / baseMinusT)) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tw *= baseMinusT;\\n\\t\\t\\t}\\n\\n\\t\\t\\tout = output.length + 1;\\n\\t\\t\\tbias = adapt(i - oldi, out, oldi == 0);\\n\\n\\t\\t\\t// `i` was supposed to wrap around from `out` to `0`,\\n\\t\\t\\t// incrementing `n` each time, so we'll fix that now:\\n\\t\\t\\tif (floor(i / out) > maxInt - n) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\n\\t\\t\\tn += floor(i / out);\\n\\t\\t\\ti %= out;\\n\\n\\t\\t\\t// Insert `n` at position `i` of the output\\n\\t\\t\\toutput.splice(i++, 0, n);\\n\\t\\t}\\n\\n\\t\\treturn ucs2encode(output);\\n\\t}\\n\\n\\t/**\\n  * Converts a string of Unicode symbols (e.g. a domain name label) to a\\n  * Punycode string of ASCII-only symbols.\\n  * @memberOf punycode\\n  * @param {String} input The string of Unicode symbols.\\n  * @returns {String} The resulting Punycode string of ASCII-only symbols.\\n  */\\n\\tfunction encode(input) {\\n\\t\\tvar n,\\n\\t\\t    delta,\\n\\t\\t    handledCPCount,\\n\\t\\t    basicLength,\\n\\t\\t    bias,\\n\\t\\t    j,\\n\\t\\t    m,\\n\\t\\t    q,\\n\\t\\t    k,\\n\\t\\t    t,\\n\\t\\t    currentValue,\\n\\t\\t    output = [],\\n\\n\\t\\t/** `inputLength` will hold the number of code points in `input`. */\\n\\t\\tinputLength,\\n\\n\\t\\t/** Cached calculation results */\\n\\t\\thandledCPCountPlusOne,\\n\\t\\t    baseMinusT,\\n\\t\\t    qMinusT;\\n\\n\\t\\t// Convert the input in UCS-2 to Unicode\\n\\t\\tinput = ucs2decode(input);\\n\\n\\t\\t// Cache the length\\n\\t\\tinputLength = input.length;\\n\\n\\t\\t// Initialize the state\\n\\t\\tn = initialN;\\n\\t\\tdelta = 0;\\n\\t\\tbias = initialBias;\\n\\n\\t\\t// Handle the basic code points\\n\\t\\tfor (j = 0; j < inputLength; ++j) {\\n\\t\\t\\tcurrentValue = input[j];\\n\\t\\t\\tif (currentValue < 0x80) {\\n\\t\\t\\t\\toutput.push(stringFromCharCode(currentValue));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\thandledCPCount = basicLength = output.length;\\n\\n\\t\\t// `handledCPCount` is the number of code points that have been handled;\\n\\t\\t// `basicLength` is the number of basic code points.\\n\\n\\t\\t// Finish the basic string - if it is not empty - with a delimiter\\n\\t\\tif (basicLength) {\\n\\t\\t\\toutput.push(delimiter);\\n\\t\\t}\\n\\n\\t\\t// Main encoding loop:\\n\\t\\twhile (handledCPCount < inputLength) {\\n\\n\\t\\t\\t// All non-basic code points < n have been handled already. Find the next\\n\\t\\t\\t// larger one:\\n\\t\\t\\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\\n\\t\\t\\t\\tcurrentValue = input[j];\\n\\t\\t\\t\\tif (currentValue >= n && currentValue < m) {\\n\\t\\t\\t\\t\\tm = currentValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\\n\\t\\t\\t// but guard against overflow\\n\\t\\t\\thandledCPCountPlusOne = handledCPCount + 1;\\n\\t\\t\\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\n\\t\\t\\tdelta += (m - n) * handledCPCountPlusOne;\\n\\t\\t\\tn = m;\\n\\n\\t\\t\\tfor (j = 0; j < inputLength; ++j) {\\n\\t\\t\\t\\tcurrentValue = input[j];\\n\\n\\t\\t\\t\\tif (currentValue < n && ++delta > maxInt) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (currentValue == n) {\\n\\t\\t\\t\\t\\t// Represent delta as a generalized variable-length integer\\n\\t\\t\\t\\t\\tfor (q = delta, k = base;; /* no condition */k += base) {\\n\\t\\t\\t\\t\\t\\tt = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\\n\\t\\t\\t\\t\\t\\tif (q < t) {\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqMinusT = q - t;\\n\\t\\t\\t\\t\\t\\tbaseMinusT = base - t;\\n\\t\\t\\t\\t\\t\\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\\n\\t\\t\\t\\t\\t\\tq = floor(qMinusT / baseMinusT);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\\n\\t\\t\\t\\t\\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\\n\\t\\t\\t\\t\\tdelta = 0;\\n\\t\\t\\t\\t\\t++handledCPCount;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t++delta;\\n\\t\\t\\t++n;\\n\\t\\t}\\n\\t\\treturn output.join('');\\n\\t}\\n\\n\\t/**\\n  * Converts a Punycode string representing a domain name or an email address\\n  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\\n  * it doesn't matter if you call it on a string that has already been\\n  * converted to Unicode.\\n  * @memberOf punycode\\n  * @param {String} input The Punycoded domain name or email address to\\n  * convert to Unicode.\\n  * @returns {String} The Unicode representation of the given Punycode\\n  * string.\\n  */\\n\\tfunction toUnicode(input) {\\n\\t\\treturn mapDomain(input, function (string) {\\n\\t\\t\\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\\n\\t\\t});\\n\\t}\\n\\n\\t/**\\n  * Converts a Unicode string representing a domain name or an email address to\\n  * Punycode. Only the non-ASCII parts of the domain name will be converted,\\n  * i.e. it doesn't matter if you call it with a domain that's already in\\n  * ASCII.\\n  * @memberOf punycode\\n  * @param {String} input The domain name or email address to convert, as a\\n  * Unicode string.\\n  * @returns {String} The Punycode representation of the given domain name or\\n  * email address.\\n  */\\n\\tfunction toASCII(input) {\\n\\t\\treturn mapDomain(input, function (string) {\\n\\t\\t\\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\\n\\t\\t});\\n\\t}\\n\\n\\t/*--------------------------------------------------------------------------*/\\n\\n\\t/** Define the public API */\\n\\tpunycode = {\\n\\t\\t/**\\n   * A string representing the current Punycode.js version number.\\n   * @memberOf punycode\\n   * @type String\\n   */\\n\\t\\t'version': '1.4.1',\\n\\t\\t/**\\n   * An object of methods to convert from JavaScript's internal character\\n   * representation (UCS-2) to Unicode code points, and back.\\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n   * @memberOf punycode\\n   * @type Object\\n   */\\n\\t\\t'ucs2': {\\n\\t\\t\\t'decode': ucs2decode,\\n\\t\\t\\t'encode': ucs2encode\\n\\t\\t},\\n\\t\\t'decode': decode,\\n\\t\\t'encode': encode,\\n\\t\\t'toASCII': toASCII,\\n\\t\\t'toUnicode': toUnicode\\n\\t};\\n\\n\\t/** Expose `punycode` */\\n\\t// Some AMD build optimizers, like r.js, check for specific condition patterns\\n\\t// like the following:\\n\\tif (true) {\\n\\t\\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\\n\\t\\t\\treturn punycode;\\n\\t\\t}).call(exports, __webpack_require__, exports, module),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n\\t} else {}\\n})(this);\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ 19)(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ 2)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanM/OWQ4OCJdLCJuYW1lcyI6WyJyb290IiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsIndpbmRvdyIsInNlbGYiLCJwdW55Y29kZSIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsImZsb29yIiwiTWF0aCIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImtleSIsImVycm9yIiwidHlwZSIsIlJhbmdlRXJyb3IiLCJtYXAiLCJhcnJheSIsImZuIiwibGVuZ3RoIiwicmVzdWx0IiwibWFwRG9tYWluIiwic3RyaW5nIiwicGFydHMiLCJzcGxpdCIsInJlcGxhY2UiLCJsYWJlbHMiLCJlbmNvZGVkIiwiam9pbiIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwidmFsdWUiLCJleHRyYSIsImNoYXJDb2RlQXQiLCJwdXNoIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJrIiwiZGVjb2RlIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsIm91dCIsImkiLCJuIiwiYmlhcyIsImJhc2ljIiwiaiIsImluZGV4Iiwib2xkaSIsInciLCJ0IiwiYmFzZU1pbnVzVCIsImxhc3RJbmRleE9mIiwic3BsaWNlIiwiZW5jb2RlIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsIm0iLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRlc3QiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwidG9BU0NJSSIsImRlZmluZSJdLCJtYXBwaW5ncyI6InNEQUFBO0FBQ0EsQ0FBRSxXQUFTQSxJQUFULEVBQWU7O0FBRWhCO0FBQ0EsS0FBSUMsY0FBYyxPQUFPQyxPQUFQLElBQWtCLFFBQWxCLElBQThCQSxPQUE5QixJQUNqQixDQUFDQSxRQUFRQyxRQURRLElBQ0lELE9BRHRCO0FBRUEsS0FBSUUsYUFBYSxPQUFPQyxNQUFQLElBQWlCLFFBQWpCLElBQTZCQSxNQUE3QixJQUNoQixDQUFDQSxPQUFPRixRQURRLElBQ0lFLE1BRHJCO0FBRUEsS0FBSUMsYUFBYSxPQUFPQyxNQUFQLElBQWlCLFFBQWpCLElBQTZCQSxNQUE5QztBQUNBLEtBQ0NELFdBQVdDLE1BQVgsS0FBc0JELFVBQXRCLElBQ0FBLFdBQVdFLE1BQVgsS0FBc0JGLFVBRHRCLElBRUFBLFdBQVdHLElBQVgsS0FBb0JILFVBSHJCLEVBSUU7QUFDRE4sU0FBT00sVUFBUDtBQUNBOztBQUVEOzs7OztBQUtBLEtBQUlJLFFBQUo7OztBQUVBO0FBQ0FDLFVBQVMsVUFIVDtBQUFBLEtBR3FCOztBQUVyQjtBQUNBQyxRQUFPLEVBTlA7QUFBQSxLQU9BQyxPQUFPLENBUFA7QUFBQSxLQVFBQyxPQUFPLEVBUlA7QUFBQSxLQVNBQyxPQUFPLEVBVFA7QUFBQSxLQVVBQyxPQUFPLEdBVlA7QUFBQSxLQVdBQyxjQUFjLEVBWGQ7QUFBQSxLQVlBQyxXQUFXLEdBWlg7QUFBQSxLQVlnQjtBQUNoQkMsYUFBWSxHQWJaO0FBQUEsS0FhaUI7O0FBRWpCO0FBQ0FDLGlCQUFnQixPQWhCaEI7QUFBQSxLQWlCQUMsZ0JBQWdCLGNBakJoQjtBQUFBLEtBaUJnQztBQUNoQ0MsbUJBQWtCLDJCQWxCbEI7QUFBQSxLQWtCK0M7O0FBRS9DO0FBQ0FDLFVBQVM7QUFDUixjQUFZLGlE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O0FBR0EsRUFSRCxNQVFPLEVBYU47QUFFRCxDQW5oQkMsRUFtaEJBLElBbmhCQSxDQUFELEMiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///20\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\n\\nvar punycode = __webpack_require__(/*! punycode */ 20);\\nvar util = __webpack_require__(/*! ./util */ 18);\\n\\nexports.parse = urlParse;\\nexports.resolve = urlResolve;\\nexports.resolveObject = urlResolveObject;\\nexports.format = urlFormat;\\n\\nexports.Url = Url;\\n\\nfunction Url() {\\n  this.protocol = null;\\n  this.slashes = null;\\n  this.auth = null;\\n  this.host = null;\\n  this.port = null;\\n  this.hostname = null;\\n  this.hash = null;\\n  this.search = null;\\n  this.query = null;\\n  this.pathname = null;\\n  this.path = null;\\n  this.href = null;\\n}\\n\\n// Reference: RFC 3986, RFC 1808, RFC 2396\\n\\n// define these here so at least they only have to be\\n// compiled once on the first module load.\\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\\n    portPattern = /:[0-9]*$/,\\n\\n\\n// Special case for a simple path URL\\nsimplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,\\n\\n\\n// RFC 2396: characters reserved for delimiting URLs.\\n// We actually just auto-escape these.\\ndelims = ['<', '>', '\\\"', '`', ' ', '\\\\r', '\\\\n', '\\\\t'],\\n\\n\\n// RFC 2396: characters not allowed for various reasons.\\nunwise = ['{', '}', '|', '\\\\\\\\', '^', '`'].concat(delims),\\n\\n\\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\\nautoEscape = ['\\\\''].concat(unwise),\\n\\n// Characters that are never ever allowed in a hostname.\\n// Note that any invalid chars are also handled, but these\\n// are the ones that are *expected* to be seen, so we fast-path\\n// them.\\nnonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\\n    hostEndingChars = ['/', '?', '#'],\\n    hostnameMaxLen = 255,\\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\\n\\n// protocols that can allow \\\"unsafe\\\" and \\\"unwise\\\" chars.\\nunsafeProtocol = {\\n  'javascript': true,\\n  'javascript:': true\\n},\\n\\n// protocols that never have a hostname.\\nhostlessProtocol = {\\n  'javascript': true,\\n  'javascript:': true\\n},\\n\\n// protocols that always contain a // bit.\\nslashedProtocol = {\\n  'http': true,\\n  'https': true,\\n  'ftp': true,\\n  'gopher': true,\\n  'file': true,\\n  'http:': true,\\n  'https:': true,\\n  'ftp:': true,\\n  'gopher:': true,\\n  'file:': true\\n},\\n    querystring = __webpack_require__(/*! querystring */ 17);\\n\\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\\n  if (url && util.isObject(url) && url instanceof Url) return url;\\n\\n  var u = new Url();\\n  u.parse(url, parseQueryString, slashesDenoteHost);\\n  return u;\\n}\\n\\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\\n  if (!util.isString(url)) {\\n    throw new TypeError(\\\"Parameter 'url' must be a string, not \\\" + typeof url);\\n  }\\n\\n  // Copy chrome, IE, opera backslash-handling behavior.\\n  // Back slashes before the query string get converted to forward slashes\\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\\n  var queryIndex = url.indexOf('?'),\\n      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\\n      uSplit = url.split(splitter),\\n      slashRegex = /\\\\\\\\/g;\\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\\n  url = uSplit.join(splitter);\\n\\n  var rest = url;\\n\\n  // trim before proceeding.\\n  // This is to support parse stuff like \\\"  http://foo.com  \\\\n\\\"\\n  rest = rest.trim();\\n\\n  if (!slashesDenoteHost && url.split('#').length === 1) {\\n    // Try fast path regexp\\n    var simplePath = simplePathPattern.exec(rest);\\n    if (simplePath) {\\n      this.path = rest;\\n      this.href = rest;\\n      this.pathname = simplePath[1];\\n      if (simplePath[2]) {\\n        this.search = simplePath[2];\\n        if (parseQueryString) {\\n          this.query = querystring.parse(this.search.substr(1));\\n        } else {\\n          this.query = this.search.substr(1);\\n        }\\n      } else if (parseQueryString) {\\n        this.search = '';\\n        this.query = {};\\n      }\\n      return this;\\n    }\\n  }\\n\\n  var proto = protocolPattern.exec(rest);\\n  if (proto) {\\n    proto = proto[0];\\n    var lowerProto = proto.toLowerCase();\\n    this.protocol = lowerProto;\\n    rest = rest.substr(proto.length);\\n  }\\n\\n  // figure out if it's got a host\\n  // user@server is *always* interpreted as a hostname, and url\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\n  // how the browser resolves relative URLs.\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\n    var slashes = rest.substr(0, 2) === '//';\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\n      rest = rest.substr(2);\\n      this.slashes = true;\\n    }\\n  }\\n\\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\\n\\n    // there's a hostname.\\n    // the first instance of /, ?, ;, or # ends the host.\\n    //\\n    // If there is an @ in the hostname, then non-host chars *are* allowed\\n    // to the left of the last @ sign, unless some host-ending character\\n    // comes *before* the @-sign.\\n    // URLs are obnoxious.\\n    //\\n    // ex:\\n    // http://a@b@c/ => user:a@b host:c\\n    // http://a@b?@c => user:a host:c path:/?@c\\n\\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\\n    // Review our test case against browsers more comprehensively.\\n\\n    // find the first instance of any hostEndingChars\\n    var hostEnd = -1;\\n    for (var i = 0; i < hostEndingChars.length; i++) {\\n      var hec = rest.indexOf(hostEndingChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\\n    }\\n\\n    // at this point, either we have an explicit point where the\\n    // auth portion cannot go past, or the last @ char is the decider.\\n    var auth, atSign;\\n    if (hostEnd === -1) {\\n      // atSign can be anywhere.\\n      atSign = rest.lastIndexOf('@');\\n    } else {\\n      // atSign must be in auth portion.\\n      // http://a@b/c@d => host:b auth:a path:/c@d\\n      atSign = rest.lastIndexOf('@', hostEnd);\\n    }\\n\\n    // Now we have a portion which is definitely the auth.\\n    // Pull that off.\\n    if (atSign !== -1) {\\n      auth = rest.slice(0, atSign);\\n      rest = rest.slice(atSign + 1);\\n      this.auth = decodeURIComponent(auth);\\n    }\\n\\n    // the host is the remaining to the left of the first non-host char\\n    hostEnd = -1;\\n    for (var i = 0; i < nonHostChars.length; i++) {\\n      var hec = rest.indexOf(nonHostChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\\n    }\\n    // if we still have not hit it, then the entire thing is a host.\\n    if (hostEnd === -1) hostEnd = rest.length;\\n\\n    this.host = rest.slice(0, hostEnd);\\n    rest = rest.slice(hostEnd);\\n\\n    // pull out port.\\n    this.parseHost();\\n\\n    // we've indicated that there is a hostname,\\n    // so even if it's empty, it has to be present.\\n    this.hostname = this.hostname || '';\\n\\n    // if hostname begins with [ and ends with ]\\n    // assume that it's an IPv6 address.\\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\\n\\n    // validate a little.\\n    if (!ipv6Hostname) {\\n      var hostparts = this.hostname.split(/\\\\./);\\n      for (var i = 0, l = hostparts.length; i < l; i++) {\\n        var part = hostparts[i];\\n        if (!part) continue;\\n        if (!part.match(hostnamePartPattern)) {\\n          var newpart = '';\\n          for (var j = 0, k = part.length; j < k; j++) {\\n            if (part.charCodeAt(j) > 127) {\\n              // we replace non-ASCII char with a temporary placeholder\\n              // we need this to make sure size of hostname is not\\n              // broken by replacing non-ASCII by nothing\\n              newpart += 'x';\\n            } else {\\n              newpart += part[j];\\n            }\\n          }\\n          // we test again with ASCII char only\\n          if (!newpart.match(hostnamePartPattern)) {\\n            var validParts = hostparts.slice(0, i);\\n            var notHost = hostparts.slice(i + 1);\\n            var bit = part.match(hostnamePartStart);\\n            if (bit) {\\n              validParts.push(bit[1]);\\n              notHost.unshift(bit[2]);\\n            }\\n            if (notHost.length) {\\n              rest = '/' + notHost.join('.') + rest;\\n            }\\n            this.hostname = validParts.join('.');\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (this.hostname.length > hostnameMaxLen) {\\n      this.hostname = '';\\n    } else {\\n      // hostnames are always lower case.\\n      this.hostname = this.hostname.toLowerCase();\\n    }\\n\\n    if (!ipv6Hostname) {\\n      // IDNA Support: Returns a punycoded representation of \\\"domain\\\".\\n      // It only converts parts of the domain name that\\n      // have non-ASCII characters, i.e. it doesn't matter if\\n      // you call it with a domain that already is ASCII-only.\\n      this.hostname = punycode.toASCII(this.hostname);\\n    }\\n\\n    var p = this.port ? ':' + this.port : '';\\n    var h = this.hostname || '';\\n    this.host = h + p;\\n    this.href += this.host;\\n\\n    // strip [ and ] from the hostname\\n    // the host field still retains them, though\\n    if (ipv6Hostname) {\\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\\n      if (rest[0] !== '/') {\\n        rest = '/' + rest;\\n      }\\n    }\\n  }\\n\\n  // now rest is set to the post-host stuff.\\n  // chop off any delim chars.\\n  if (!unsafeProtocol[lowerProto]) {\\n\\n    // First, make 100% sure that any \\\"autoEscape\\\" chars get\\n    // escaped, even if encodeURIComponent doesn't think they\\n    // need to be.\\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\\n      var ae = autoEscape[i];\\n      if (rest.indexOf(ae) === -1) continue;\\n      var esc = encodeURIComponent(ae);\\n      if (esc === ae) {\\n        esc = escape(ae);\\n      }\\n      rest = rest.split(ae).join(esc);\\n    }\\n  }\\n\\n  // chop off from the tail first.\\n  var hash = rest.indexOf('#');\\n  if (hash !== -1) {\\n    // got a fragment string.\\n    this.hash = rest.substr(hash);\\n    rest = rest.slice(0, hash);\\n  }\\n  var qm = rest.indexOf('?');\\n  if (qm !== -1) {\\n    this.search = rest.substr(qm);\\n    this.query = rest.substr(qm + 1);\\n    if (parseQueryString) {\\n      this.query = querystring.parse(this.query);\\n    }\\n    rest = rest.slice(0, qm);\\n  } else if (parseQueryString) {\\n    // no query string, but parseQueryString still requested\\n    this.search = '';\\n    this.query = {};\\n  }\\n  if (rest) this.pathname = rest;\\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\\n    this.pathname = '/';\\n  }\\n\\n  //to support http.request\\n  if (this.pathname || this.search) {\\n    var p = this.pathname || '';\\n    var s = this.search || '';\\n    this.path = p + s;\\n  }\\n\\n  // finally, reconstruct the href based on what has been validated.\\n  this.href = this.format();\\n  return this;\\n};\\n\\n// format a parsed object into a url string\\nfunction urlFormat(obj) {\\n  // ensure it's an object, and not a string url.\\n  // If it's an obj, this is a no-op.\\n  // this way, you can call url_format() on strings\\n  // to clean up potentially wonky urls.\\n  if (util.isString(obj)) obj = urlParse(obj);\\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\\n  return obj.format();\\n}\\n\\nUrl.prototype.format = function () {\\n  var auth = this.auth || '';\\n  if (auth) {\\n    auth = encodeURIComponent(auth);\\n    auth = auth.replace(/%3A/i, ':');\\n    auth += '@';\\n  }\\n\\n  var protocol = this.protocol || '',\\n      pathname = this.pathname || '',\\n      hash = this.hash || '',\\n      host = false,\\n      query = '';\\n\\n  if (this.host) {\\n    host = auth + this.host;\\n  } else if (this.hostname) {\\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\\n    if (this.port) {\\n      host += ':' + this.port;\\n    }\\n  }\\n\\n  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\\n    query = querystring.stringify(this.query);\\n  }\\n\\n  var search = this.search || query && '?' + query || '';\\n\\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\\n\\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\\n  // unless they had them to begin with.\\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\\n    host = '//' + (host || '');\\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\\n  } else if (!host) {\\n    host = '';\\n  }\\n\\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\\n  if (search && search.charAt(0) !== '?') search = '?' + search;\\n\\n  pathname = pathname.replace(/[?#]/g, function (match) {\\n    return encodeURIComponent(match);\\n  });\\n  search = search.replace('#', '%23');\\n\\n  return protocol + host + pathname + search + hash;\\n};\\n\\nfunction urlResolve(source, relative) {\\n  return urlParse(source, false, true).resolve(relative);\\n}\\n\\nUrl.prototype.resolve = function (relative) {\\n  return this.resolveObject(urlParse(relative, false, true)).format();\\n};\\n\\nfunction urlResolveObject(source, relative) {\\n  if (!source) return relative;\\n  return urlParse(source, false, true).resolveObject(relative);\\n}\\n\\nUrl.prototype.resolveObject = function (relative) {\\n  if (util.isString(relative)) {\\n    var rel = new Url();\\n    rel.parse(relative, false, true);\\n    relative = rel;\\n  }\\n\\n  var result = new Url();\\n  var tkeys = Object.keys(this);\\n  for (var tk = 0; tk < tkeys.length; tk++) {\\n    var tkey = tkeys[tk];\\n    result[tkey] = this[tkey];\\n  }\\n\\n  // hash is always overridden, no matter what.\\n  // even href=\\\"\\\" will remove it.\\n  result.hash = relative.hash;\\n\\n  // if the relative url is empty, then there's nothing left to do here.\\n  if (relative.href === '') {\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // hrefs like //foo/bar always cut to the protocol.\\n  if (relative.slashes && !relative.protocol) {\\n    // take everything except the protocol from relative\\n    var rkeys = Object.keys(relative);\\n    for (var rk = 0; rk < rkeys.length; rk++) {\\n      var rkey = rkeys[rk];\\n      if (rkey !== 'protocol') result[rkey] = relative[rkey];\\n    }\\n\\n    //urlParse appends trailing / to urls like http://www.example.com\\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\\n      result.path = result.pathname = '/';\\n    }\\n\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (relative.protocol && relative.protocol !== result.protocol) {\\n    // if it's a known url protocol, then changing\\n    // the protocol does weird things\\n    // first, if it's not file:, then we MUST have a host,\\n    // and if there was a path\\n    // to begin with, then we MUST have a path.\\n    // if it is file:, then the host is dropped,\\n    // because that's known to be hostless.\\n    // anything else is assumed to be absolute.\\n    if (!slashedProtocol[relative.protocol]) {\\n      var keys = Object.keys(relative);\\n      for (var v = 0; v < keys.length; v++) {\\n        var k = keys[v];\\n        result[k] = relative[k];\\n      }\\n      result.href = result.format();\\n      return result;\\n    }\\n\\n    result.protocol = relative.protocol;\\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\\n      var relPath = (relative.pathname || '').split('/');\\n      while (relPath.length && !(relative.host = relPath.shift()));\\n      if (!relative.host) relative.host = '';\\n      if (!relative.hostname) relative.hostname = '';\\n      if (relPath[0] !== '') relPath.unshift('');\\n      if (relPath.length < 2) relPath.unshift('');\\n      result.pathname = relPath.join('/');\\n    } else {\\n      result.pathname = relative.pathname;\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    result.host = relative.host || '';\\n    result.auth = relative.auth;\\n    result.hostname = relative.hostname || relative.host;\\n    result.port = relative.port;\\n    // to support http.request\\n    if (result.pathname || result.search) {\\n      var p = result.pathname || '';\\n      var s = result.search || '';\\n      result.path = p + s;\\n    }\\n    result.slashes = result.slashes || relative.slashes;\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\\n      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\\n      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\\n      removeAllDots = mustEndAbs,\\n      srcPath = result.pathname && result.pathname.split('/') || [],\\n      relPath = relative.pathname && relative.pathname.split('/') || [],\\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\\n\\n  // if the url is a non-slashed url, then relative\\n  // links like ../.. should be able\\n  // to crawl up to the hostname, as well.  This is strange.\\n  // result.protocol has already been set by now.\\n  // Later on, put the first path part into the host field.\\n  if (psychotic) {\\n    result.hostname = '';\\n    result.port = null;\\n    if (result.host) {\\n      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\\n    }\\n    result.host = '';\\n    if (relative.protocol) {\\n      relative.hostname = null;\\n      relative.port = null;\\n      if (relative.host) {\\n        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\\n      }\\n      relative.host = null;\\n    }\\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\\n  }\\n\\n  if (isRelAbs) {\\n    // it's absolute.\\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    srcPath = relPath;\\n    // fall through to the dot-handling below.\\n  } else if (relPath.length) {\\n    // it's relative\\n    // throw away the existing file, and take the new path instead.\\n    if (!srcPath) srcPath = [];\\n    srcPath.pop();\\n    srcPath = srcPath.concat(relPath);\\n    result.search = relative.search;\\n    result.query = relative.query;\\n  } else if (!util.isNullOrUndefined(relative.search)) {\\n    // just pull out the search.\\n    // like href='?foo'.\\n    // Put this after the other two cases because it simplifies the booleans\\n    if (psychotic) {\\n      result.hostname = result.host = srcPath.shift();\\n      //occationaly the auth can get stuck only in host\\n      //this especially happens in cases like\\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\\n      if (authInHost) {\\n        result.auth = authInHost.shift();\\n        result.host = result.hostname = authInHost.shift();\\n      }\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    //to support http.request\\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (!srcPath.length) {\\n    // no path at all.  easy.\\n    // we've already handled the other stuff above.\\n    result.pathname = null;\\n    //to support http.request\\n    if (result.search) {\\n      result.path = '/' + result.search;\\n    } else {\\n      result.path = null;\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // if a url ENDs in . or .., then it must get a trailing slash.\\n  // however, if it ends in anything else non-slashy,\\n  // then it must NOT get a trailing slash.\\n  var last = srcPath.slice(-1)[0];\\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\\n\\n  // strip single dots, resolve double dots to parent dir\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = srcPath.length; i >= 0; i--) {\\n    last = srcPath[i];\\n    if (last === '.') {\\n      srcPath.splice(i, 1);\\n    } else if (last === '..') {\\n      srcPath.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      srcPath.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (!mustEndAbs && !removeAllDots) {\\n    for (; up--; up) {\\n      srcPath.unshift('..');\\n    }\\n  }\\n\\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\\n    srcPath.push('');\\n  }\\n\\n  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\\n\\n  // put the host back\\n  if (psychotic) {\\n    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\\n    //occationaly the auth can get stuck only in host\\n    //this especially happens in cases like\\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\\n    if (authInHost) {\\n      result.auth = authInHost.shift();\\n      result.host = result.hostname = authInHost.shift();\\n    }\\n  }\\n\\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\\n\\n  if (mustEndAbs && !isAbsolute) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (!srcPath.length) {\\n    result.pathname = null;\\n    result.path = null;\\n  } else {\\n    result.pathname = srcPath.join('/');\\n  }\\n\\n  //to support request.http\\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\\n  }\\n  result.auth = relative.auth || result.auth;\\n  result.slashes = result.slashes || relative.slashes;\\n  result.href = result.format();\\n  return result;\\n};\\n\\nUrl.prototype.parseHost = function () {\\n  var host = this.host;\\n  var port = portPattern.exec(host);\\n  if (port) {\\n    port = port[0];\\n    if (port !== ':') {\\n      this.port = port.substr(1);\\n    }\\n    host = host.substr(0, host.length - port.length);\\n  }\\n  if (host) this.hostname = host;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcz8wYjE2Il0sIm5hbWVzIjpbInB1bnljb2RlIiwicmVxdWlyZSIsInV0aWwiLCJleHBvcnRzIiwicGFyc2UiLCJ1cmxQYXJzZSIsInJlc29sdmUiLCJ1cmxSZXNvbHZlIiwicmVzb2x2ZU9iamVjdCIsInVybFJlc29sdmVPYmplY3QiLCJmb3JtYXQiLCJ1cmxGb3JtYXQiLCJVcmwiLCJwcm90b2NvbCIsInNsYXNoZXMiLCJhdXRoIiwiaG9zdCIsInBvcnQiLCJob3N0bmFtZSIsImhhc2giLCJzZWFyY2giLCJxdWVyeSIsInBhdGhuYW1lIiwicGF0aCIsImhyZWYiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiY29uY2F0IiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJ1cmwiLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJpc09iamVjdCIsInUiLCJwcm90b3R5cGUiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsInF1ZXJ5SW5kZXgiLCJpbmRleE9mIiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzcGxpdCIsInNsYXNoUmVnZXgiLCJyZXBsYWNlIiwiam9pbiIsInJlc3QiLCJ0cmltIiwibGVuZ3RoIiwic2ltcGxlUGF0aCIsImV4ZWMiLCJzdWJzdHIiLCJwcm90byIsImxvd2VyUHJvdG8iLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwiaG9zdEVuZCIsImkiLCJoZWMiLCJhdFNpZ24iLCJsYXN0SW5kZXhPZiIsInNsaWNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwibCIsInBhcnQiLCJuZXdwYXJ0IiwiaiIsImsiLCJjaGFyQ29kZUF0IiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJwdXNoIiwidW5zaGlmdCIsInRvQVNDSUkiLCJwIiwiaCIsImFlIiwiZXNjIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwicW0iLCJzIiwib2JqIiwiY2FsbCIsIk9iamVjdCIsImtleXMiLCJzdHJpbmdpZnkiLCJjaGFyQXQiLCJzb3VyY2UiLCJyZWxhdGl2ZSIsInJlbCIsInJlc3VsdCIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJ2IiwicmVsUGF0aCIsInNoaWZ0IiwiaXNTb3VyY2VBYnMiLCJpc1JlbEFicyIsIm11c3RFbmRBYnMiLCJyZW1vdmVBbGxEb3RzIiwic3JjUGF0aCIsInBzeWNob3RpYyIsInBvcCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiYXV0aEluSG9zdCIsImlzTnVsbCIsImxhc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJzcGxpY2UiLCJpc0Fic29sdXRlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUlBLFdBQVcsbUJBQUFDLENBQVEsa0JBQVIsQ0FBZjtBQUNBLElBQUlDLE9BQU8sbUJBQUFELENBQVEsZ0JBQVIsQ0FBWDs7QUFFQUUsUUFBUUMsS0FBUixHQUFnQkMsUUFBaEI7QUFDQUYsUUFBUUcsT0FBUixHQUFrQkMsVUFBbEI7QUFDQUosUUFBUUssYUFBUixHQUF3QkMsZ0JBQXhCO0FBQ0FOLFFBQVFPLE1BQVIsR0FBaUJDLFNBQWpCOztBQUVBUixRQUFRUyxHQUFSLEdBQWNBLEdBQWQ7O0FBRUEsU0FBU0EsR0FBVCxHQUFlO0FBQ2IsT0FBS0MsUUFBTCxHQUFnQixJQUFoQjtBQUNBLE9BQUtDLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBS0MsSUFBTCxHQUFZLElBQVo7QUFDQSxPQUFLQyxJQUFMLEdBQVksSUFBWjtBQUNBLE9BQUtDLElBQUwsR0FBWSxJQUFaO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQixJQUFoQjtBQUNBLE9BQUtDLElBQUwsR0FBWSxJQUFaO0FBQ0EsT0FBS0MsTUFBTCxHQUFjLElBQWQ7QUFDQSxPQUFLQyxLQUFMLEdBQWEsSUFBYjtBQUNBLE9BQUtDLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxPQUFLQyxJQUFMLEdBQVksSUFBWjtBQUNBLE9BQUtDLElBQUwsR0FBWSxJQUFaO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLElBQUlDLGtCQUFrQixtQkFBdEI7QUFBQSxJQUNJQyxjQUFjLFVBRGxCOzs7QUFHSTtBQUNBQyxvQkFBb0Isb0NBSnhCOzs7QUFNSTtBQUNBO0FBQ0FDLFNBQVMsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEIsSUFBMUIsRUFBZ0MsSUFBaEMsRUFBc0MsSUFBdEMsQ0FSYjs7O0FBVUk7QUFDQUMsU0FBUyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixJQUFoQixFQUFzQixHQUF0QixFQUEyQixHQUEzQixFQUFnQ0MsTUFBaEMsQ0FBdUNGLE1BQXZDLENBWGI7OztBQWFJO0FBQ0FHLGFBQWEsQ0FBQyxJQUFELEVBQU9ELE1BQVAsQ0FBY0QsTUFBZCxDQWRqQjs7QUFlSTtBQUNBO0FBQ0E7QUFDQTtBQUNBRyxlQUFlLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCRixNQUExQixDQUFpQ0MsVUFBakMsQ0FuQm5CO0FBQUEsSUFvQklFLGtCQUFrQixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxDQXBCdEI7QUFBQSxJQXFCSUMsaUJBQWlCLEdBckJyQjtBQUFBLElBc0JJQyxzQkFBc0Isd0JBdEIxQjtBQUFBLElBdUJJQyxvQkFBb0IsOEJBdkJ4Qjs7QUF3Qkk7QUFDQUMsaUJBQWlCO0FBQ2YsZ0JBQWMsSUFEQztBQUVmLGlCQUFlO0FBRkEsQ0F6QnJCOztBQTZCSTtBQUNBQyxtQkFBbUI7QUFDakIsZ0JBQWMsSUFERztBQUVqQixpQkFBZTtBQUZFLENBOUJ2Qjs7QUFrQ0k7QUFDQUMsa0JBQWtCO0FBQ2hCLFVBQVEsSUFEUTtBQUVoQixXQUFTLElBRk87QUFHaEIsU0FBTyxJQUhTO0FBSWhCLFlBQVUsSUFKTTtBQUtoQixVQUFRLElBTFE7QUFNaEIsV0FBUyxJQU5PO0FBT2hCLFlBQVUsSUFQTTtBQVFoQixVQUFRLElBUlE7QUFTaEIsYUFBVyxJQVRLO0FBVWhCLFdBQVM7QUFWTyxDQW5DdEI7QUFBQSxJQStDSUMsY0FBYyxtQkFBQXZDLENBQVEscUJBQVIsQ0EvQ2xCOztBQWlEQSxTQUFTSSxRQUFULENBQWtCb0MsR0FBbEIsRUFBdUJDLGdCQUF2QixFQUF5Q0MsaUJBQXpDLEVBQTREO0FBQzFELE1BQUlGLE9BQU92QyxLQUFLMEMsUUFBTCxDQUFjSCxHQUFkLENBQVAsSUFBNkJBLGVBQWU3QixHQUFoRCxFQUFxRCxPQUFPNkIsR0FBUDs7QUFFckQsTUFBSUksSUFBSSxJQUFJakMsR0FBSixFQUFSO0FBQ0FpQyxJQUFFekMsS0FBRixDQUFRcUMsR0FBUixFQUFhQyxnQkFBYixFQUErQkMsaUJBQS9CO0FBQ0EsU0FBT0UsQ0FBUDtBQUNEOztBQUVEakMsSUFBSWtDLFNBQUosQ0FBYzFDLEtBQWQsR0FBc0IsVUFBU3FDLEdBQVQsRUFBY0MsZ0JBQWQsRUFBZ0NDLGlCQUFoQyxFQUFtRDtBQUN2RSxNQUFJLENBQUN6QyxLQUFLNkMsUUFBTCxDQUFjTixHQUFkLENBQUwsRUFBeUI7QUFDdkIsVUFBTSxJQUFJTyxTQUFKLENBQWMsMkNBQTJDLE9BQU9QLEdBQWhFLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxNQUFJUSxhQUFhUixJQUFJUyxPQUFKLENBQVksR0FBWixDQUFqQjtBQUFBLE1BQ0lDLFdBQ0tGLGVBQWUsQ0FBQyxDQUFoQixJQUFxQkEsYUFBYVIsSUFBSVMsT0FBSixDQUFZLEdBQVosQ0FBbkMsR0FBdUQsR0FBdkQsR0FBNkQsR0FGckU7QUFBQSxNQUdJRSxTQUFTWCxJQUFJWSxLQUFKLENBQVVGLFFBQVYsQ0FIYjtBQUFBLE1BSUlHLGFBQWEsS0FKakI7QUFLQUYsU0FBTyxDQUFQLElBQVlBLE9BQU8sQ0FBUCxFQUFVRyxPQUFWLENBQWtCRCxVQUFsQixFQUE4QixHQUE5QixDQUFaO0FBQ0FiLFFBQU1XLE9BQU9JLElBQVAsQ0FBWUwsUUFBWixDQUFOOztBQUVBLE1BQUlNLE9BQU9oQixHQUFYOztBQUVBO0FBQ0E7QUFDQWdCLFNBQU9BLEtBQUtDLElBQUwsRUFBUDs7QUFFQSxNQUFJLENBQUNmLGlCQUFELElBQXNCRixJQUFJWSxLQUFKLENBQVUsR0FBVixFQUFlTSxNQUFmLEtBQTBCLENBQXBELEVBQXVEO0FBQ3JEO0FBQ0EsUUFBSUMsYUFBYWpDLGtCQUFrQmtDLElBQWxCLENBQXVCSixJQUF2QixDQUFqQjtBQUNBLFFBQUlHLFVBQUosRUFBZ0I7QUFDZCxXQUFLckMsSUFBTCxHQUFZa0MsSUFBWjtBQUNBLFdBQUtqQyxJQUFMLEdBQVlpQyxJQUFaO0FBQ0EsV0FBS25DLFFBQUwsR0FBZ0JzQyxXQUFXLENBQVgsQ0FBaEI7QUFDQSxVQUFJQSxXQUFXLENBQVgsQ0FBSixFQUFtQjtBQUNqQixhQUFLeEMsTUFBTCxHQUFjd0MsV0FBVyxDQUFYLENBQWQ7QUFDQSxZQUFJbEIsZ0JBQUosRUFBc0I7QUFDcEIsZUFBS3JCLEtBQUwsR0FBYW1CLFlBQVlwQyxLQUFaLENBQWtCLEtBQUtnQixNQUFMLENBQVkwQyxNQUFaLENBQW1CLENBQW5CLENBQWxCLENBQWI7QUFDRCxTQUZELE1BRU87QUFDTCxlQUFLekMsS0FBTCxHQUFhLEtBQUtELE1BQUwsQ0FBWTBDLE1BQVosQ0FBbUIsQ0FBbkIsQ0FBYjtBQUNEO0FBQ0YsT0FQRCxNQU9PLElBQUlwQixnQkFBSixFQUFzQjtBQUMzQixhQUFLdEIsTUFBTCxHQUFjLEVBQWQ7QUFDQSxhQUFLQyxLQUFMLEdBQWEsRUFBYjtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJMEMsUUFBUXRDLGdCQUFnQm9DLElBQWhCLENBQXFCSixJQUFyQixDQUFaO0FBQ0EsTUFBSU0sS0FBSixFQUFXO0FBQ1RBLFlBQVFBLE1BQU0sQ0FBTixDQUFSO0FBQ0EsUUFBSUMsYUFBYUQsTUFBTUUsV0FBTixFQUFqQjtBQUNBLFNBQUtwRCxRQUFMLEdBQWdCbUQsVUFBaEI7QUFDQVAsV0FBT0EsS0FBS0ssTUFBTCxDQUFZQyxNQUFNSixNQUFsQixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJaEIscUJBQXFCb0IsS0FBckIsSUFBOEJOLEtBQUtTLEtBQUwsQ0FBVyxzQkFBWCxDQUFsQyxFQUFzRTtBQUNwRSxRQUFJcEQsVUFBVTJDLEtBQUtLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixNQUFzQixJQUFwQztBQUNBLFFBQUloRCxXQUFXLEVBQUVpRCxTQUFTekIsaUJBQWlCeUIsS0FBakIsQ0FBWCxDQUFmLEVBQW9EO0FBQ2xETixhQUFPQSxLQUFLSyxNQUFMLENBQVksQ0FBWixDQUFQO0FBQ0EsV0FBS2hELE9BQUwsR0FBZSxJQUFmO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLENBQUN3QixpQkFBaUJ5QixLQUFqQixDQUFELEtBQ0NqRCxXQUFZaUQsU0FBUyxDQUFDeEIsZ0JBQWdCd0IsS0FBaEIsQ0FEdkIsQ0FBSixFQUNxRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBSUksVUFBVSxDQUFDLENBQWY7QUFDQSxTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSW5DLGdCQUFnQjBCLE1BQXBDLEVBQTRDUyxHQUE1QyxFQUFpRDtBQUMvQyxVQUFJQyxNQUFNWixLQUFLUCxPQUFMLENBQWFqQixnQkFBZ0JtQyxDQUFoQixDQUFiLENBQVY7QUFDQSxVQUFJQyxRQUFRLENBQUMsQ0FBVCxLQUFlRixZQUFZLENBQUMsQ0FBYixJQUFrQkUsTUFBTUYsT0FBdkMsQ0FBSixFQUNFQSxVQUFVRSxHQUFWO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLFFBQUl0RCxJQUFKLEVBQVV1RCxNQUFWO0FBQ0EsUUFBSUgsWUFBWSxDQUFDLENBQWpCLEVBQW9CO0FBQ2xCO0FBQ0FHLGVBQVNiLEtBQUtjLFdBQUwsQ0FBaUIsR0FBakIsQ0FBVDtBQUNELEtBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQUQsZUFBU2IsS0FBS2MsV0FBTCxDQUFpQixHQUFqQixFQUFzQkosT0FBdEIsQ0FBVDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxRQUFJRyxXQUFXLENBQUMsQ0FBaEIsRUFBbUI7QUFDakJ2RCxhQUFPMEMsS0FBS2UsS0FBTCxDQUFXLENBQVgsRUFBY0YsTUFBZCxDQUFQO0FBQ0FiLGFBQU9BLEtBQUtlLEtBQUwsQ0FBV0YsU0FBUyxDQUFwQixDQUFQO0FBQ0EsV0FBS3ZELElBQUwsR0FBWTBELG1CQUFtQjFELElBQW5CLENBQVo7QUFDRDs7QUFFRDtBQUNBb0QsY0FBVSxDQUFDLENBQVg7QUFDQSxTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSXBDLGFBQWEyQixNQUFqQyxFQUF5Q1MsR0FBekMsRUFBOEM7QUFDNUMsVUFBSUMsTUFBTVosS0FBS1AsT0FBTCxDQUFhbEIsYUFBYW9DLENBQWIsQ0FBYixDQUFWO0FBQ0EsVUFBSUMsUUFBUSxDQUFDLENBQVQsS0FBZUYsWUFBWSxDQUFDLENBQWIsSUFBa0JFLE1BQU1GLE9BQXZDLENBQUosRUFDRUEsVUFBVUUsR0FBVjtBQUNIO0FBQ0Q7QUFDQSxRQUFJRixZQUFZLENBQUMsQ0FBakIsRUFDRUEsVUFBVVYsS0FBS0UsTUFBZjs7QUFFRixTQUFLM0MsSUFBTCxHQUFZeUMsS0FBS2UsS0FBTCxDQUFXLENBQVgsRUFBY0wsT0FBZCxDQUFaO0FBQ0FWLFdBQU9BLEtBQUtlLEtBQUwsQ0FBV0wsT0FBWCxDQUFQOztBQUVBO0FBQ0EsU0FBS08sU0FBTDs7QUFFQTtBQUNBO0FBQ0EsU0FBS3hELFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxJQUFpQixFQUFqQzs7QUFFQTtBQUNBO0FBQ0EsUUFBSXlELGVBQWUsS0FBS3pELFFBQUwsQ0FBYyxDQUFkLE1BQXFCLEdBQXJCLElBQ2YsS0FBS0EsUUFBTCxDQUFjLEtBQUtBLFFBQUwsQ0FBY3lDLE1BQWQsR0FBdUIsQ0FBckMsTUFBNEMsR0FEaEQ7O0FBR0E7QUFDQSxRQUFJLENBQUNnQixZQUFMLEVBQW1CO0FBQ2pCLFVBQUlDLFlBQVksS0FBSzFELFFBQUwsQ0FBY21DLEtBQWQsQ0FBb0IsSUFBcEIsQ0FBaEI7QUFDQSxXQUFLLElBQUllLElBQUksQ0FBUixFQUFXUyxJQUFJRCxVQUFVakIsTUFBOUIsRUFBc0NTLElBQUlTLENBQTFDLEVBQTZDVCxHQUE3QyxFQUFrRDtBQUNoRCxZQUFJVSxPQUFPRixVQUFVUixDQUFWLENBQVg7QUFDQSxZQUFJLENBQUNVLElBQUwsRUFBVztBQUNYLFlBQUksQ0FBQ0EsS0FBS1osS0FBTCxDQUFXL0IsbUJBQVgsQ0FBTCxFQUFzQztBQUNwQyxjQUFJNEMsVUFBVSxFQUFkO0FBQ0EsZUFBSyxJQUFJQyxJQUFJLENBQVIsRUFBV0MsSUFBSUgsS0FBS25CLE1BQXpCLEVBQWlDcUIsSUFBSUMsQ0FBckMsRUFBd0NELEdBQXhDLEVBQTZDO0FBQzNDLGdCQUFJRixLQUFLSSxVQUFMLENBQWdCRixDQUFoQixJQUFxQixHQUF6QixFQUE4QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQUQseUJBQVcsR0FBWDtBQUNELGFBTEQsTUFLTztBQUNMQSx5QkFBV0QsS0FBS0UsQ0FBTCxDQUFYO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsY0FBSSxDQUFDRCxRQUFRYixLQUFSLENBQWMvQixtQkFBZCxDQUFMLEVBQXlDO0FBQ3ZDLGdCQUFJZ0QsYUFBYVAsVUFBVUosS0FBVixDQUFnQixDQUFoQixFQUFtQkosQ0FBbkIsQ0FBakI7QUFDQSxnQkFBSWdCLFVBQVVSLFVBQVVKLEtBQVYsQ0FBZ0JKLElBQUksQ0FBcEIsQ0FBZDtBQUNBLGdCQUFJaUIsTUFBTVAsS0FBS1osS0FBTCxDQUFXOUIsaUJBQVgsQ0FBVjtBQUNBLGdCQUFJaUQsR0FBSixFQUFTO0FBQ1BGLHlCQUFXRyxJQUFYLENBQWdCRCxJQUFJLENBQUosQ0FBaEI7QUFDQUQsc0JBQVFHLE9BQVIsQ0FBZ0JGLElBQUksQ0FBSixDQUFoQjtBQUNEO0FBQ0QsZ0JBQUlELFFBQVF6QixNQUFaLEVBQW9CO0FBQ2xCRixxQkFBTyxNQUFNMkIsUUFBUTVCLElBQVIsQ0FBYSxHQUFiLENBQU4sR0FBMEJDLElBQWpDO0FBQ0Q7QUFDRCxpQkFBS3ZDLFFBQUwsR0FBZ0JpRSxXQUFXM0IsSUFBWCxDQUFnQixHQUFoQixDQUFoQjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsUUFBSSxLQUFLdEMsUUFBTCxDQUFjeUMsTUFBZCxHQUF1QnpCLGNBQTNCLEVBQTJDO0FBQ3pDLFdBQUtoQixRQUFMLEdBQWdCLEVBQWhCO0FBQ0QsS0FGRCxNQUVPO0FBQ0w7QUFDQSxXQUFLQSxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsQ0FBYytDLFdBQWQsRUFBaEI7QUFDRDs7QUFFRCxRQUFJLENBQUNVLFlBQUwsRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFLekQsUUFBTCxHQUFnQmxCLFNBQVN3RixPQUFULENBQWlCLEtBQUt0RSxRQUF0QixDQUFoQjtBQUNEOztBQUVELFFBQUl1RSxJQUFJLEtBQUt4RSxJQUFMLEdBQVksTUFBTSxLQUFLQSxJQUF2QixHQUE4QixFQUF0QztBQUNBLFFBQUl5RSxJQUFJLEtBQUt4RSxRQUFMLElBQWlCLEVBQXpCO0FBQ0EsU0FBS0YsSUFBTCxHQUFZMEUsSUFBSUQsQ0FBaEI7QUFDQSxTQUFLakUsSUFBTCxJQUFhLEtBQUtSLElBQWxCOztBQUVBO0FBQ0E7QUFDQSxRQUFJMkQsWUFBSixFQUFrQjtBQUNoQixXQUFLekQsUUFBTCxHQUFnQixLQUFLQSxRQUFMLENBQWM0QyxNQUFkLENBQXFCLENBQXJCLEVBQXdCLEtBQUs1QyxRQUFMLENBQWN5QyxNQUFkLEdBQXVCLENBQS9DLENBQWhCO0FBQ0EsVUFBSUYsS0FBSyxDQUFMLE1BQVksR0FBaEIsRUFBcUI7QUFDbkJBLGVBQU8sTUFBTUEsSUFBYjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsTUFBSSxDQUFDcEIsZUFBZTJCLFVBQWYsQ0FBTCxFQUFpQzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsU0FBSyxJQUFJSSxJQUFJLENBQVIsRUFBV1MsSUFBSTlDLFdBQVc0QixNQUEvQixFQUF1Q1MsSUFBSVMsQ0FBM0MsRUFBOENULEdBQTlDLEVBQW1EO0FBQ2pELFVBQUl1QixLQUFLNUQsV0FBV3FDLENBQVgsQ0FBVDtBQUNBLFVBQUlYLEtBQUtQLE9BQUwsQ0FBYXlDLEVBQWIsTUFBcUIsQ0FBQyxDQUExQixFQUNFO0FBQ0YsVUFBSUMsTUFBTUMsbUJBQW1CRixFQUFuQixDQUFWO0FBQ0EsVUFBSUMsUUFBUUQsRUFBWixFQUFnQjtBQUNkQyxjQUFNRSxPQUFPSCxFQUFQLENBQU47QUFDRDtBQUNEbEMsYUFBT0EsS0FBS0osS0FBTCxDQUFXc0MsRUFBWCxFQUFlbkMsSUFBZixDQUFvQm9DLEdBQXBCLENBQVA7QUFDRDtBQUNGOztBQUdEO0FBQ0EsTUFBSXpFLE9BQU9zQyxLQUFLUCxPQUFMLENBQWEsR0FBYixDQUFYO0FBQ0EsTUFBSS9CLFNBQVMsQ0FBQyxDQUFkLEVBQWlCO0FBQ2Y7QUFDQSxTQUFLQSxJQUFMLEdBQVlzQyxLQUFLSyxNQUFMLENBQVkzQyxJQUFaLENBQVo7QUFDQXNDLFdBQU9BLEtBQUtlLEtBQUwsQ0FBVyxDQUFYLEVBQWNyRCxJQUFkLENBQVA7QUFDRDtBQUNELE1BQUk0RSxLQUFLdEMsS0FBS1AsT0FBTCxDQUFhLEdBQWIsQ0FBVDtBQUNBLE1BQUk2QyxPQUFPLENBQUMsQ0FBWixFQUFlO0FBQ2IsU0FBSzNFLE1BQUwsR0FBY3FDLEtBQUtLLE1BQUwsQ0FBWWlDLEVBQVosQ0FBZDtBQUNBLFNBQUsxRSxLQUFMLEdBQWFvQyxLQUFLSyxNQUFMLENBQVlpQyxLQUFLLENBQWpCLENBQWI7QUFDQSxRQUFJckQsZ0JBQUosRUFBc0I7QUFDcEIsV0FBS3JCLEtBQUwsR0FBYW1CLFlBQVlwQyxLQUFaLENBQWtCLEtBQUtpQixLQUF2QixDQUFiO0FBQ0Q7QUFDRG9DLFdBQU9BLEtBQUtlLEtBQUwsQ0FBVyxDQUFYLEVBQWN1QixFQUFkLENBQVA7QUFDRCxHQVBELE1BT08sSUFBSXJELGdCQUFKLEVBQXNCO0FBQzNCO0FBQ0EsU0FBS3RCLE1BQUwsR0FBYyxFQUFkO0FBQ0EsU0FBS0MsS0FBTCxHQUFhLEVBQWI7QUFDRDtBQUNELE1BQUlvQyxJQUFKLEVBQVUsS0FBS25DLFFBQUwsR0FBZ0JtQyxJQUFoQjtBQUNWLE1BQUlsQixnQkFBZ0J5QixVQUFoQixLQUNBLEtBQUs5QyxRQURMLElBQ2lCLENBQUMsS0FBS0ksUUFEM0IsRUFDcUM7QUFDbkMsU0FBS0EsUUFBTCxHQUFnQixHQUFoQjtBQUNEOztBQUVEO0FBQ0EsTUFBSSxLQUFLQSxRQUFMLElBQWlCLEtBQUtGLE1BQTFCLEVBQWtDO0FBQ2hDLFFBQUlxRSxJQUFJLEtBQUtuRSxRQUFMLElBQWlCLEVBQXpCO0FBQ0EsUUFBSTBFLElBQUksS0FBSzVFLE1BQUwsSUFBZSxFQUF2QjtBQUNBLFNBQUtHLElBQUwsR0FBWWtFLElBQUlPLENBQWhCO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFLeEUsSUFBTCxHQUFZLEtBQUtkLE1BQUwsRUFBWjtBQUNBLFNBQU8sSUFBUDtBQUNELENBblFEOztBQXFRQTtBQUNBLFNBQVNDLFNBQVQsQ0FBbUJzRixHQUFuQixFQUF3QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUkvRixLQUFLNkMsUUFBTCxDQUFja0QsR0FBZCxDQUFKLEVBQXdCQSxNQUFNNUYsU0FBUzRGLEdBQVQsQ0FBTjtBQUN4QixNQUFJLEVBQUVBLGVBQWVyRixHQUFqQixDQUFKLEVBQTJCLE9BQU9BLElBQUlrQyxTQUFKLENBQWNwQyxNQUFkLENBQXFCd0YsSUFBckIsQ0FBMEJELEdBQTFCLENBQVA7QUFDM0IsU0FBT0EsSUFBSXZGLE1BQUosRUFBUDtBQUNEOztBQUVERSxJQUFJa0MsU0FBSixDQUFjcEMsTUFBZCxHQUF1QixZQUFXO0FBQ2hDLE1BQUlLLE9BQU8sS0FBS0EsSUFBTCxJQUFhLEVBQXhCO0FBQ0EsTUFBSUEsSUFBSixFQUFVO0FBQ1JBLFdBQU84RSxtQkFBbUI5RSxJQUFuQixDQUFQO0FBQ0FBLFdBQU9BLEtBQUt3QyxPQUFMLENBQWEsTUFBYixFQUFxQixHQUFyQixDQUFQO0FBQ0F4QyxZQUFRLEdBQVI7QUFDRDs7QUFFRCxNQUFJRixXQUFXLEtBQUtBLFFBQUwsSUFBaUIsRUFBaEM7QUFBQSxNQUNJUyxXQUFXLEtBQUtBLFFBQUwsSUFBaUIsRUFEaEM7QUFBQSxNQUVJSCxPQUFPLEtBQUtBLElBQUwsSUFBYSxFQUZ4QjtBQUFBLE1BR0lILE9BQU8sS0FIWDtBQUFBLE1BSUlLLFFBQVEsRUFKWjs7QUFNQSxNQUFJLEtBQUtMLElBQVQsRUFBZTtBQUNiQSxXQUFPRCxPQUFPLEtBQUtDLElBQW5CO0FBQ0QsR0FGRCxNQUVPLElBQUksS0FBS0UsUUFBVCxFQUFtQjtBQUN4QkYsV0FBT0QsUUFBUSxLQUFLRyxRQUFMLENBQWNnQyxPQUFkLENBQXNCLEdBQXRCLE1BQStCLENBQUMsQ0FBaEMsR0FDWCxLQUFLaEMsUUFETSxHQUVYLE1BQU0sS0FBS0EsUUFBWCxHQUFzQixHQUZuQixDQUFQO0FBR0EsUUFBSSxLQUFLRCxJQUFULEVBQWU7QUFDYkQsY0FBUSxNQUFNLEtBQUtDLElBQW5CO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLEtBQUtJLEtBQUwsSUFDQW5CLEtBQUswQyxRQUFMLENBQWMsS0FBS3ZCLEtBQW5CLENBREEsSUFFQThFLE9BQU9DLElBQVAsQ0FBWSxLQUFLL0UsS0FBakIsRUFBd0JzQyxNQUY1QixFQUVvQztBQUNsQ3RDLFlBQVFtQixZQUFZNkQsU0FBWixDQUFzQixLQUFLaEYsS0FBM0IsQ0FBUjtBQUNEOztBQUVELE1BQUlELFNBQVMsS0FBS0EsTUFBTCxJQUFnQkMsU0FBVSxNQUFNQSxLQUFoQyxJQUEyQyxFQUF4RDs7QUFFQSxNQUFJUixZQUFZQSxTQUFTaUQsTUFBVCxDQUFnQixDQUFDLENBQWpCLE1BQXdCLEdBQXhDLEVBQTZDakQsWUFBWSxHQUFaOztBQUU3QztBQUNBO0FBQ0EsTUFBSSxLQUFLQyxPQUFMLElBQ0EsQ0FBQyxDQUFDRCxRQUFELElBQWEwQixnQkFBZ0IxQixRQUFoQixDQUFkLEtBQTRDRyxTQUFTLEtBRHpELEVBQ2dFO0FBQzlEQSxXQUFPLFFBQVFBLFFBQVEsRUFBaEIsQ0FBUDtBQUNBLFFBQUlNLFlBQVlBLFNBQVNnRixNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQXZDLEVBQTRDaEYsV0FBVyxNQUFNQSxRQUFqQjtBQUM3QyxHQUpELE1BSU8sSUFBSSxDQUFDTixJQUFMLEVBQVc7QUFDaEJBLFdBQU8sRUFBUDtBQUNEOztBQUVELE1BQUlHLFFBQVFBLEtBQUttRixNQUFMLENBQVksQ0FBWixNQUFtQixHQUEvQixFQUFvQ25GLE9BQU8sTUFBTUEsSUFBYjtBQUNwQyxNQUFJQyxVQUFVQSxPQUFPa0YsTUFBUCxDQUFjLENBQWQsTUFBcUIsR0FBbkMsRUFBd0NsRixTQUFTLE1BQU1BLE1BQWY7O0FBRXhDRSxhQUFXQSxTQUFTaUMsT0FBVCxDQUFpQixPQUFqQixFQUEwQixVQUFTVyxLQUFULEVBQWdCO0FBQ25ELFdBQU8yQixtQkFBbUIzQixLQUFuQixDQUFQO0FBQ0QsR0FGVSxDQUFYO0FBR0E5QyxXQUFTQSxPQUFPbUMsT0FBUCxDQUFlLEdBQWYsRUFBb0IsS0FBcEIsQ0FBVDs7QUFFQSxTQUFPMUMsV0FBV0csSUFBWCxHQUFrQk0sUUFBbEIsR0FBNkJGLE1BQTdCLEdBQXNDRCxJQUE3QztBQUNELENBdEREOztBQXdEQSxTQUFTWixVQUFULENBQW9CZ0csTUFBcEIsRUFBNEJDLFFBQTVCLEVBQXNDO0FBQ3BDLFNBQU9uRyxTQUFTa0csTUFBVCxFQUFpQixLQUFqQixFQUF3QixJQUF4QixFQUE4QmpHLE9BQTlCLENBQXNDa0csUUFBdEMsQ0FBUDtBQUNEOztBQUVENUYsSUFBSWtDLFNBQUosQ0FBY3hDLE9BQWQsR0FBd0IsVUFBU2tHLFFBQVQsRUFBbUI7QUFDekMsU0FBTyxLQUFLaEcsYUFBTCxDQUFtQkgsU0FBU21HLFFBQVQsRUFBbUIsS0FBbkIsRUFBMEIsSUFBMUIsQ0FBbkIsRUFBb0Q5RixNQUFwRCxFQUFQO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTRCxnQkFBVCxDQUEwQjhGLE1BQTFCLEVBQWtDQyxRQUFsQyxFQUE0QztBQUMxQyxNQUFJLENBQUNELE1BQUwsRUFBYSxPQUFPQyxRQUFQO0FBQ2IsU0FBT25HLFNBQVNrRyxNQUFULEVBQWlCLEtBQWpCLEVBQXdCLElBQXhCLEVBQThCL0YsYUFBOUIsQ0FBNENnRyxRQUE1QyxDQUFQO0FBQ0Q7O0FBRUQ1RixJQUFJa0MsU0FBSixDQUFjdEMsYUFBZCxHQUE4QixVQUFTZ0csUUFBVCxFQUFtQjtBQUMvQyxNQUFJdEcsS0FBSzZDLFFBQUwsQ0FBY3lELFFBQWQsQ0FBSixFQUE2QjtBQUMzQixRQUFJQyxNQUFNLElBQUk3RixHQUFKLEVBQVY7QUFDQTZGLFFBQUlyRyxLQUFKLENBQVVvRyxRQUFWLEVBQW9CLEtBQXBCLEVBQTJCLElBQTNCO0FBQ0FBLGVBQVdDLEdBQVg7QUFDRDs7QUFFRCxNQUFJQyxTQUFTLElBQUk5RixHQUFKLEVBQWI7QUFDQSxNQUFJK0YsUUFBUVIsT0FBT0MsSUFBUCxDQUFZLElBQVosQ0FBWjtBQUNBLE9BQUssSUFBSVEsS0FBSyxDQUFkLEVBQWlCQSxLQUFLRCxNQUFNaEQsTUFBNUIsRUFBb0NpRCxJQUFwQyxFQUEwQztBQUN4QyxRQUFJQyxPQUFPRixNQUFNQyxFQUFOLENBQVg7QUFDQUYsV0FBT0csSUFBUCxJQUFlLEtBQUtBLElBQUwsQ0FBZjtBQUNEOztBQUVEO0FBQ0E7QUFDQUgsU0FBT3ZGLElBQVAsR0FBY3FGLFNBQVNyRixJQUF2Qjs7QUFFQTtBQUNBLE1BQUlxRixTQUFTaEYsSUFBVCxLQUFrQixFQUF0QixFQUEwQjtBQUN4QmtGLFdBQU9sRixJQUFQLEdBQWNrRixPQUFPaEcsTUFBUCxFQUFkO0FBQ0EsV0FBT2dHLE1BQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUlGLFNBQVMxRixPQUFULElBQW9CLENBQUMwRixTQUFTM0YsUUFBbEMsRUFBNEM7QUFDMUM7QUFDQSxRQUFJaUcsUUFBUVgsT0FBT0MsSUFBUCxDQUFZSSxRQUFaLENBQVo7QUFDQSxTQUFLLElBQUlPLEtBQUssQ0FBZCxFQUFpQkEsS0FBS0QsTUFBTW5ELE1BQTVCLEVBQW9Db0QsSUFBcEMsRUFBMEM7QUFDeEMsVUFBSUMsT0FBT0YsTUFBTUMsRUFBTixDQUFYO0FBQ0EsVUFBSUMsU0FBUyxVQUFiLEVBQ0VOLE9BQU9NLElBQVAsSUFBZVIsU0FBU1EsSUFBVCxDQUFmO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJekUsZ0JBQWdCbUUsT0FBTzdGLFFBQXZCLEtBQ0E2RixPQUFPeEYsUUFEUCxJQUNtQixDQUFDd0YsT0FBT3BGLFFBRC9CLEVBQ3lDO0FBQ3ZDb0YsYUFBT25GLElBQVAsR0FBY21GLE9BQU9wRixRQUFQLEdBQWtCLEdBQWhDO0FBQ0Q7O0FBRURvRixXQUFPbEYsSUFBUCxHQUFja0YsT0FBT2hHLE1BQVAsRUFBZDtBQUNBLFdBQU9nRyxNQUFQO0FBQ0Q7O0FBRUQsTUFBSUYsU0FBUzNGLFFBQVQsSUFBcUIyRixTQUFTM0YsUUFBVCxLQUFzQjZGLE9BQU83RixRQUF0RCxFQUFnRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDMEIsZ0JBQWdCaUUsU0FBUzNGLFFBQXpCLENBQUwsRUFBeUM7QUFDdkMsVUFBSXVGLE9BQU9ELE9BQU9DLElBQVAsQ0FBWUksUUFBWixDQUFYO0FBQ0EsV0FBSyxJQUFJUyxJQUFJLENBQWIsRUFBZ0JBLElBQUliLEtBQUt6QyxNQUF6QixFQUFpQ3NELEdBQWpDLEVBQXNDO0FBQ3BDLFlBQUloQyxJQUFJbUIsS0FBS2EsQ0FBTCxDQUFSO0FBQ0FQLGVBQU96QixDQUFQLElBQVl1QixTQUFTdkIsQ0FBVCxDQUFaO0FBQ0Q7QUFDRHlCLGFBQU9sRixJQUFQLEdBQWNrRixPQUFPaEcsTUFBUCxFQUFkO0FBQ0EsYUFBT2dHLE1BQVA7QUFDRDs7QUFFREEsV0FBTzdGLFFBQVAsR0FBa0IyRixTQUFTM0YsUUFBM0I7QUFDQSxRQUFJLENBQUMyRixTQUFTeEYsSUFBVixJQUFrQixDQUFDc0IsaUJBQWlCa0UsU0FBUzNGLFFBQTFCLENBQXZCLEVBQTREO0FBQzFELFVBQUlxRyxVQUFVLENBQUNWLFNBQVNsRixRQUFULElBQXFCLEVBQXRCLEVBQTBCK0IsS0FBMUIsQ0FBZ0MsR0FBaEMsQ0FBZDtBQUNBLGFBQU82RCxRQUFRdkQsTUFBUixJQUFrQixFQUFFNkMsU0FBU3hGLElBQVQsR0FBZ0JrRyxRQUFRQyxLQUFSLEVBQWxCLENBQXpCLENBQTREO0FBQzVELFVBQUksQ0FBQ1gsU0FBU3hGLElBQWQsRUFBb0J3RixTQUFTeEYsSUFBVCxHQUFnQixFQUFoQjtBQUNwQixVQUFJLENBQUN3RixTQUFTdEYsUUFBZCxFQUF3QnNGLFNBQVN0RixRQUFULEdBQW9CLEVBQXBCO0FBQ3hCLFVBQUlnRyxRQUFRLENBQVIsTUFBZSxFQUFuQixFQUF1QkEsUUFBUTNCLE9BQVIsQ0FBZ0IsRUFBaEI7QUFDdkIsVUFBSTJCLFFBQVF2RCxNQUFSLEdBQWlCLENBQXJCLEVBQXdCdUQsUUFBUTNCLE9BQVIsQ0FBZ0IsRUFBaEI7QUFDeEJtQixhQUFPcEYsUUFBUCxHQUFrQjRGLFFBQVExRCxJQUFSLENBQWEsR0FBYixDQUFsQjtBQUNELEtBUkQsTUFRTztBQUNMa0QsYUFBT3BGLFFBQVAsR0FBa0JrRixTQUFTbEYsUUFBM0I7QUFDRDtBQUNEb0YsV0FBT3RGLE1BQVAsR0FBZ0JvRixTQUFTcEYsTUFBekI7QUFDQXNGLFdBQU9yRixLQUFQLEdBQWVtRixTQUFTbkYsS0FBeEI7QUFDQXFGLFdBQU8xRixJQUFQLEdBQWN3RixTQUFTeEYsSUFBVCxJQUFpQixFQUEvQjtBQUNBMEYsV0FBTzNGLElBQVAsR0FBY3lGLFNBQVN6RixJQUF2QjtBQUNBMkYsV0FBT3hGLFFBQVAsR0FBa0JzRixTQUFTdEYsUUFBVCxJQUFxQnNGLFNBQVN4RixJQUFoRDtBQUNBMEYsV0FBT3pGLElBQVAsR0FBY3VGLFNBQVN2RixJQUF2QjtBQUNBO0FBQ0EsUUFBSXlGLE9BQU9wRixRQUFQLElBQW1Cb0YsT0FBT3RGLE1BQTlCLEVBQXNDO0FBQ3BDLFVBQUlxRSxJQUFJaUIsT0FBT3BGLFFBQVAsSUFBbUIsRUFBM0I7QUFDQSxVQUFJMEUsSUFBSVUsT0FBT3RGLE1BQVAsSUFBaUIsRUFBekI7QUFDQXNGLGFBQU9uRixJQUFQLEdBQWNrRSxJQUFJTyxDQUFsQjtBQUNEO0FBQ0RVLFdBQU81RixPQUFQLEdBQWlCNEYsT0FBTzVGLE9BQVAsSUFBa0IwRixTQUFTMUYsT0FBNUM7QUFDQTRGLFdBQU9sRixJQUFQLEdBQWNrRixPQUFPaEcsTUFBUCxFQUFkO0FBQ0EsV0FBT2dHLE1BQVA7QUFDRDs7QUFFRCxNQUFJVSxjQUFlVixPQUFPcEYsUUFBUCxJQUFtQm9GLE9BQU9wRixRQUFQLENBQWdCZ0YsTUFBaEIsQ0FBdUIsQ0FBdkIsTUFBOEIsR0FBcEU7QUFBQSxNQUNJZSxXQUNJYixTQUFTeEYsSUFBVCxJQUNBd0YsU0FBU2xGLFFBQVQsSUFBcUJrRixTQUFTbEYsUUFBVCxDQUFrQmdGLE1BQWxCLENBQXlCLENBQXpCLE1BQWdDLEdBSDdEO0FBQUEsTUFLSWdCLGFBQWNELFlBQVlELFdBQVosSUFDQ1YsT0FBTzFGLElBQVAsSUFBZXdGLFNBQVNsRixRQU4zQztBQUFBLE1BT0lpRyxnQkFBZ0JELFVBUHBCO0FBQUEsTUFRSUUsVUFBVWQsT0FBT3BGLFFBQVAsSUFBbUJvRixPQUFPcEYsUUFBUCxDQUFnQitCLEtBQWhCLENBQXNCLEdBQXRCLENBQW5CLElBQWlELEVBUi9EO0FBQUEsTUFTSTZELFVBQVVWLFNBQVNsRixRQUFULElBQXFCa0YsU0FBU2xGLFFBQVQsQ0FBa0IrQixLQUFsQixDQUF3QixHQUF4QixDQUFyQixJQUFxRCxFQVRuRTtBQUFBLE1BVUlvRSxZQUFZZixPQUFPN0YsUUFBUCxJQUFtQixDQUFDMEIsZ0JBQWdCbUUsT0FBTzdGLFFBQXZCLENBVnBDOztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJNEcsU0FBSixFQUFlO0FBQ2JmLFdBQU94RixRQUFQLEdBQWtCLEVBQWxCO0FBQ0F3RixXQUFPekYsSUFBUCxHQUFjLElBQWQ7QUFDQSxRQUFJeUYsT0FBTzFGLElBQVgsRUFBaUI7QUFDZixVQUFJd0csUUFBUSxDQUFSLE1BQWUsRUFBbkIsRUFBdUJBLFFBQVEsQ0FBUixJQUFhZCxPQUFPMUYsSUFBcEIsQ0FBdkIsS0FDS3dHLFFBQVFqQyxPQUFSLENBQWdCbUIsT0FBTzFGLElBQXZCO0FBQ047QUFDRDBGLFdBQU8xRixJQUFQLEdBQWMsRUFBZDtBQUNBLFFBQUl3RixTQUFTM0YsUUFBYixFQUF1QjtBQUNyQjJGLGVBQVN0RixRQUFULEdBQW9CLElBQXBCO0FBQ0FzRixlQUFTdkYsSUFBVCxHQUFnQixJQUFoQjtBQUNBLFVBQUl1RixTQUFTeEYsSUFBYixFQUFtQjtBQUNqQixZQUFJa0csUUFBUSxDQUFSLE1BQWUsRUFBbkIsRUFBdUJBLFFBQVEsQ0FBUixJQUFhVixTQUFTeEYsSUFBdEIsQ0FBdkIsS0FDS2tHLFFBQVEzQixPQUFSLENBQWdCaUIsU0FBU3hGLElBQXpCO0FBQ047QUFDRHdGLGVBQVN4RixJQUFULEdBQWdCLElBQWhCO0FBQ0Q7QUFDRHNHLGlCQUFhQSxlQUFlSixRQUFRLENBQVIsTUFBZSxFQUFmLElBQXFCTSxRQUFRLENBQVIsTUFBZSxFQUFuRCxDQUFiO0FBQ0Q7O0FBRUQsTUFBSUgsUUFBSixFQUFjO0FBQ1o7QUFDQVgsV0FBTzFGLElBQVAsR0FBZXdGLFNBQVN4RixJQUFULElBQWlCd0YsU0FBU3hGLElBQVQsS0FBa0IsRUFBcEMsR0FDQXdGLFNBQVN4RixJQURULEdBQ2dCMEYsT0FBTzFGLElBRHJDO0FBRUEwRixXQUFPeEYsUUFBUCxHQUFtQnNGLFNBQVN0RixRQUFULElBQXFCc0YsU0FBU3RGLFFBQVQsS0FBc0IsRUFBNUMsR0FDQXNGLFNBQVN0RixRQURULEdBQ29Cd0YsT0FBT3hGLFFBRDdDO0FBRUF3RixXQUFPdEYsTUFBUCxHQUFnQm9GLFNBQVNwRixNQUF6QjtBQUNBc0YsV0FBT3JGLEtBQVAsR0FBZW1GLFNBQVNuRixLQUF4QjtBQUNBbUcsY0FBVU4sT0FBVjtBQUNBO0FBQ0QsR0FWRCxNQVVPLElBQUlBLFFBQVF2RCxNQUFaLEVBQW9CO0FBQ3pCO0FBQ0E7QUFDQSxRQUFJLENBQUM2RCxPQUFMLEVBQWNBLFVBQVUsRUFBVjtBQUNkQSxZQUFRRSxHQUFSO0FBQ0FGLGNBQVVBLFFBQVExRixNQUFSLENBQWVvRixPQUFmLENBQVY7QUFDQVIsV0FBT3RGLE1BQVAsR0FBZ0JvRixTQUFTcEYsTUFBekI7QUFDQXNGLFdBQU9yRixLQUFQLEdBQWVtRixTQUFTbkYsS0FBeEI7QUFDRCxHQVJNLE1BUUEsSUFBSSxDQUFDbkIsS0FBS3lILGlCQUFMLENBQXVCbkIsU0FBU3BGLE1BQWhDLENBQUwsRUFBOEM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsUUFBSXFHLFNBQUosRUFBZTtBQUNiZixhQUFPeEYsUUFBUCxHQUFrQndGLE9BQU8xRixJQUFQLEdBQWN3RyxRQUFRTCxLQUFSLEVBQWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSVMsYUFBYWxCLE9BQU8xRixJQUFQLElBQWUwRixPQUFPMUYsSUFBUCxDQUFZa0MsT0FBWixDQUFvQixHQUFwQixJQUEyQixDQUExQyxHQUNBd0QsT0FBTzFGLElBQVAsQ0FBWXFDLEtBQVosQ0FBa0IsR0FBbEIsQ0FEQSxHQUN5QixLQUQxQztBQUVBLFVBQUl1RSxVQUFKLEVBQWdCO0FBQ2RsQixlQUFPM0YsSUFBUCxHQUFjNkcsV0FBV1QsS0FBWCxFQUFkO0FBQ0FULGVBQU8xRixJQUFQLEdBQWMwRixPQUFPeEYsUUFBUCxHQUFrQjBHLFdBQVdULEtBQVgsRUFBaEM7QUFDRDtBQUNGO0FBQ0RULFdBQU90RixNQUFQLEdBQWdCb0YsU0FBU3BGLE1BQXpCO0FBQ0FzRixXQUFPckYsS0FBUCxHQUFlbUYsU0FBU25GLEtBQXhCO0FBQ0E7QUFDQSxRQUFJLENBQUNuQixLQUFLMkgsTUFBTCxDQUFZbkIsT0FBT3BGLFFBQW5CLENBQUQsSUFBaUMsQ0FBQ3BCLEtBQUsySCxNQUFMLENBQVluQixPQUFPdEYsTUFBbkIsQ0FBdEMsRUFBa0U7QUFDaEVzRixhQUFPbkYsSUFBUCxHQUFjLENBQUNtRixPQUFPcEYsUUFBUCxHQUFrQm9GLE9BQU9wRixRQUF6QixHQUFvQyxFQUFyQyxLQUNDb0YsT0FBT3RGLE1BQVAsR0FBZ0JzRixPQUFPdEYsTUFBdkIsR0FBZ0MsRUFEakMsQ0FBZDtBQUVEO0FBQ0RzRixXQUFPbEYsSUFBUCxHQUFja0YsT0FBT2hHLE1BQVAsRUFBZDtBQUNBLFdBQU9nRyxNQUFQO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDYyxRQUFRN0QsTUFBYixFQUFxQjtBQUNuQjtBQUNBO0FBQ0ErQyxXQUFPcEYsUUFBUCxHQUFrQixJQUFsQjtBQUNBO0FBQ0EsUUFBSW9GLE9BQU90RixNQUFYLEVBQW1CO0FBQ2pCc0YsYUFBT25GLElBQVAsR0FBYyxNQUFNbUYsT0FBT3RGLE1BQTNCO0FBQ0QsS0FGRCxNQUVPO0FBQ0xzRixhQUFPbkYsSUFBUCxHQUFjLElBQWQ7QUFDRDtBQUNEbUYsV0FBT2xGLElBQVAsR0FBY2tGLE9BQU9oRyxNQUFQLEVBQWQ7QUFDQSxXQUFPZ0csTUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLE1BQUlvQixPQUFPTixRQUFRaEQsS0FBUixDQUFjLENBQUMsQ0FBZixFQUFrQixDQUFsQixDQUFYO0FBQ0EsTUFBSXVELG1CQUNBLENBQUNyQixPQUFPMUYsSUFBUCxJQUFld0YsU0FBU3hGLElBQXhCLElBQWdDd0csUUFBUTdELE1BQVIsR0FBaUIsQ0FBbEQsTUFDQ21FLFNBQVMsR0FBVCxJQUFnQkEsU0FBUyxJQUQxQixLQUNtQ0EsU0FBUyxFQUZoRDs7QUFJQTtBQUNBO0FBQ0EsTUFBSUUsS0FBSyxDQUFUO0FBQ0EsT0FBSyxJQUFJNUQsSUFBSW9ELFFBQVE3RCxNQUFyQixFQUE2QlMsS0FBSyxDQUFsQyxFQUFxQ0EsR0FBckMsRUFBMEM7QUFDeEMwRCxXQUFPTixRQUFRcEQsQ0FBUixDQUFQO0FBQ0EsUUFBSTBELFNBQVMsR0FBYixFQUFrQjtBQUNoQk4sY0FBUVMsTUFBUixDQUFlN0QsQ0FBZixFQUFrQixDQUFsQjtBQUNELEtBRkQsTUFFTyxJQUFJMEQsU0FBUyxJQUFiLEVBQW1CO0FBQ3hCTixjQUFRUyxNQUFSLENBQWU3RCxDQUFmLEVBQWtCLENBQWxCO0FBQ0E0RDtBQUNELEtBSE0sTUFHQSxJQUFJQSxFQUFKLEVBQVE7QUFDYlIsY0FBUVMsTUFBUixDQUFlN0QsQ0FBZixFQUFrQixDQUFsQjtBQUNBNEQ7QUFDRDtBQUNGOztBQUVEO0FBQ0EsTUFBSSxDQUFDVixVQUFELElBQWUsQ0FBQ0MsYUFBcEIsRUFBbUM7QUFDakMsV0FBT1MsSUFBUCxFQUFhQSxFQUFiLEVBQWlCO0FBQ2ZSLGNBQVFqQyxPQUFSLENBQWdCLElBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJK0IsY0FBY0UsUUFBUSxDQUFSLE1BQWUsRUFBN0IsS0FDQyxDQUFDQSxRQUFRLENBQVIsQ0FBRCxJQUFlQSxRQUFRLENBQVIsRUFBV2xCLE1BQVgsQ0FBa0IsQ0FBbEIsTUFBeUIsR0FEekMsQ0FBSixFQUNtRDtBQUNqRGtCLFlBQVFqQyxPQUFSLENBQWdCLEVBQWhCO0FBQ0Q7O0FBRUQsTUFBSXdDLG9CQUFxQlAsUUFBUWhFLElBQVIsQ0FBYSxHQUFiLEVBQWtCTSxNQUFsQixDQUF5QixDQUFDLENBQTFCLE1BQWlDLEdBQTFELEVBQWdFO0FBQzlEMEQsWUFBUWxDLElBQVIsQ0FBYSxFQUFiO0FBQ0Q7O0FBRUQsTUFBSTRDLGFBQWFWLFFBQVEsQ0FBUixNQUFlLEVBQWYsSUFDWkEsUUFBUSxDQUFSLEtBQWNBLFFBQVEsQ0FBUixFQUFXbEIsTUFBWCxDQUFrQixDQUFsQixNQUF5QixHQUQ1Qzs7QUFHQTtBQUNBLE1BQUltQixTQUFKLEVBQWU7QUFDYmYsV0FBT3hGLFFBQVAsR0FBa0J3RixPQUFPMUYsSUFBUCxHQUFja0gsYUFBYSxFQUFiLEdBQ0FWLFFBQVE3RCxNQUFSLEdBQWlCNkQsUUFBUUwsS0FBUixFQUFqQixHQUFtQyxFQURuRTtBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUlTLGFBQWFsQixPQUFPMUYsSUFBUCxJQUFlMEYsT0FBTzFGLElBQVAsQ0FBWWtDLE9BQVosQ0FBb0IsR0FBcEIsSUFBMkIsQ0FBMUMsR0FDQXdELE9BQU8xRixJQUFQLENBQVlxQyxLQUFaLENBQWtCLEdBQWxCLENBREEsR0FDeUIsS0FEMUM7QUFFQSxRQUFJdUUsVUFBSixFQUFnQjtBQUNkbEIsYUFBTzNGLElBQVAsR0FBYzZHLFdBQVdULEtBQVgsRUFBZDtBQUNBVCxhQUFPMUYsSUFBUCxHQUFjMEYsT0FBT3hGLFFBQVAsR0FBa0IwRyxXQUFXVCxLQUFYLEVBQWhDO0FBQ0Q7QUFDRjs7QUFFREcsZUFBYUEsY0FBZVosT0FBTzFGLElBQVAsSUFBZXdHLFFBQVE3RCxNQUFuRDs7QUFFQSxNQUFJMkQsY0FBYyxDQUFDWSxVQUFuQixFQUErQjtBQUM3QlYsWUFBUWpDLE9BQVIsQ0FBZ0IsRUFBaEI7QUFDRDs7QUFFRCxNQUFJLENBQUNpQyxRQUFRN0QsTUFBYixFQUFxQjtBQUNuQitDLFdBQU9wRixRQUFQLEdBQWtCLElBQWxCO0FBQ0FvRixXQUFPbkYsSUFBUCxHQUFjLElBQWQ7QUFDRCxHQUhELE1BR087QUFDTG1GLFdBQU9wRixRQUFQLEdBQWtCa0csUUFBUWhFLElBQVIsQ0FBYSxHQUFiLENBQWxCO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJLENBQUN0RCxLQUFLMkgsTUFBTCxDQUFZbkIsT0FBT3BGLFFBQW5CLENBQUQsSUFBaUMsQ0FBQ3BCLEtBQUsySCxNQUFMLENBQVluQixPQUFPdEYsTUFBbkIsQ0FBdEMsRUFBa0U7QUFDaEVzRixXQUFPbkYsSUFBUCxHQUFjLENBQUNtRixPQUFPcEYsUUFBUCxHQUFrQm9GLE9BQU9wRixRQUF6QixHQUFvQyxFQUFyQyxLQUNDb0YsT0FBT3RGLE1BQVAsR0FBZ0JzRixPQUFPdEYsTUFBdkIsR0FBZ0MsRUFEakMsQ0FBZDtBQUVEO0FBQ0RzRixTQUFPM0YsSUFBUCxHQUFjeUYsU0FBU3pGLElBQVQsSUFBaUIyRixPQUFPM0YsSUFBdEM7QUFDQTJGLFNBQU81RixPQUFQLEdBQWlCNEYsT0FBTzVGLE9BQVAsSUFBa0IwRixTQUFTMUYsT0FBNUM7QUFDQTRGLFNBQU9sRixJQUFQLEdBQWNrRixPQUFPaEcsTUFBUCxFQUFkO0FBQ0EsU0FBT2dHLE1BQVA7QUFDRCxDQTVRRDs7QUE4UUE5RixJQUFJa0MsU0FBSixDQUFjNEIsU0FBZCxHQUEwQixZQUFXO0FBQ25DLE1BQUkxRCxPQUFPLEtBQUtBLElBQWhCO0FBQ0EsTUFBSUMsT0FBT1MsWUFBWW1DLElBQVosQ0FBaUI3QyxJQUFqQixDQUFYO0FBQ0EsTUFBSUMsSUFBSixFQUFVO0FBQ1JBLFdBQU9BLEtBQUssQ0FBTCxDQUFQO0FBQ0EsUUFBSUEsU0FBUyxHQUFiLEVBQWtCO0FBQ2hCLFdBQUtBLElBQUwsR0FBWUEsS0FBSzZDLE1BQUwsQ0FBWSxDQUFaLENBQVo7QUFDRDtBQUNEOUMsV0FBT0EsS0FBSzhDLE1BQUwsQ0FBWSxDQUFaLEVBQWU5QyxLQUFLMkMsTUFBTCxHQUFjMUMsS0FBSzBDLE1BQWxDLENBQVA7QUFDRDtBQUNELE1BQUkzQyxJQUFKLEVBQVUsS0FBS0UsUUFBTCxHQUFnQkYsSUFBaEI7QUFDWCxDQVhEIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///21\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function(__resourceQuery) {\\n\\n/* global __resourceQuery WorkerGlobalScope self */\\n/* eslint prefer-destructuring: off */\\n\\nvar url = __webpack_require__(/*! url */ 21);\\nvar stripAnsi = __webpack_require__(/*! strip-ansi */ 14);\\nvar log = __webpack_require__(/*! loglevel */ 12).getLogger('webpack-dev-server');\\nvar socket = __webpack_require__(/*! ./socket */ 11);\\nvar overlay = __webpack_require__(/*! ./overlay */ 9);\\n\\nfunction getCurrentScriptSource() {\\n  // `document.currentScript` is the most accurate way to find the current script,\\n  // but is not supported in all browsers.\\n  if (document.currentScript) {\\n    return document.currentScript.getAttribute('src');\\n  }\\n  // Fall back to getting all scripts in the document.\\n  var scriptElements = document.scripts || [];\\n  var currentScript = scriptElements[scriptElements.length - 1];\\n  if (currentScript) {\\n    return currentScript.getAttribute('src');\\n  }\\n  // Fail as there was no script to use.\\n  throw new Error('[WDS] Failed to get current script source.');\\n}\\n\\nvar urlParts = void 0;\\nvar hotReload = true;\\nif (typeof window !== 'undefined') {\\n  var qs = window.location.search.toLowerCase();\\n  hotReload = qs.indexOf('hotreload=false') === -1;\\n}\\nif (true) {\\n  // If this bundle is inlined, use the resource query to get the correct url.\\n  urlParts = url.parse(__resourceQuery.substr(1));\\n} else { var scriptHost; }\\n\\nif (!urlParts.port || urlParts.port === '0') {\\n  urlParts.port = self.location.port;\\n}\\n\\nvar _hot = false;\\nvar initial = true;\\nvar currentHash = '';\\nvar useWarningOverlay = false;\\nvar useErrorOverlay = false;\\nvar useProgress = false;\\n\\nvar INFO = 'info';\\nvar WARNING = 'warning';\\nvar ERROR = 'error';\\nvar NONE = 'none';\\n\\n// Set the default log level\\nlog.setDefaultLevel(INFO);\\n\\n// Send messages to the outside, so plugins can consume it.\\nfunction sendMsg(type, data) {\\n  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {\\n    self.postMessage({\\n      type: 'webpack' + type,\\n      data: data\\n    }, '*');\\n  }\\n}\\n\\nvar onSocketMsg = {\\n  hot: function hot() {\\n    _hot = true;\\n    log.info('[WDS] Hot Module Replacement enabled.');\\n  },\\n  invalid: function invalid() {\\n    log.info('[WDS] App updated. Recompiling...');\\n    // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    sendMsg('Invalid');\\n  },\\n  hash: function hash(_hash) {\\n    currentHash = _hash;\\n  },\\n\\n  'still-ok': function stillOk() {\\n    log.info('[WDS] Nothing changed.');\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    sendMsg('StillOk');\\n  },\\n  'log-level': function logLevel(level) {\\n    var hotCtx = __webpack_require__(6);\\n    if (hotCtx.keys().indexOf('./log') !== -1) {\\n      hotCtx('./log').setLogLevel(level);\\n    }\\n    switch (level) {\\n      case INFO:\\n      case ERROR:\\n        log.setLevel(level);\\n        break;\\n      case WARNING:\\n        // loglevel's warning name is different from webpack's\\n        log.setLevel('warn');\\n        break;\\n      case NONE:\\n        log.disableAll();\\n        break;\\n      default:\\n        log.error('[WDS] Unknown clientLogLevel \\\\'' + level + '\\\\'');\\n    }\\n  },\\n  overlay: function overlay(value) {\\n    if (typeof document !== 'undefined') {\\n      if (typeof value === 'boolean') {\\n        useWarningOverlay = false;\\n        useErrorOverlay = value;\\n      } else if (value) {\\n        useWarningOverlay = value.warnings;\\n        useErrorOverlay = value.errors;\\n      }\\n    }\\n  },\\n  progress: function progress(_progress) {\\n    if (typeof document !== 'undefined') {\\n      useProgress = _progress;\\n    }\\n  },\\n\\n  'progress-update': function progressUpdate(data) {\\n    if (useProgress) log.info('[WDS] ' + data.percent + '% - ' + data.msg + '.');\\n  },\\n  ok: function ok() {\\n    sendMsg('Ok');\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\\n    reloadApp();\\n  },\\n\\n  'content-changed': function contentChanged() {\\n    log.info('[WDS] Content base changed. Reloading...');\\n    self.location.reload();\\n  },\\n  warnings: function warnings(_warnings) {\\n    log.warn('[WDS] Warnings while compiling.');\\n    var strippedWarnings = _warnings.map(function (warning) {\\n      return stripAnsi(warning);\\n    });\\n    sendMsg('Warnings', strippedWarnings);\\n    for (var i = 0; i < strippedWarnings.length; i++) {\\n      log.warn(strippedWarnings[i]);\\n    }\\n    if (useWarningOverlay) overlay.showMessage(_warnings);\\n\\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\\n    reloadApp();\\n  },\\n  errors: function errors(_errors) {\\n    log.error('[WDS] Errors while compiling. Reload prevented.');\\n    var strippedErrors = _errors.map(function (error) {\\n      return stripAnsi(error);\\n    });\\n    sendMsg('Errors', strippedErrors);\\n    for (var i = 0; i < strippedErrors.length; i++) {\\n      log.error(strippedErrors[i]);\\n    }\\n    if (useErrorOverlay) overlay.showMessage(_errors);\\n    initial = false;\\n  },\\n  error: function error(_error) {\\n    log.error(_error);\\n  },\\n  close: function close() {\\n    log.error('[WDS] Disconnected!');\\n    sendMsg('Close');\\n  }\\n};\\n\\nvar hostname = urlParts.hostname;\\nvar protocol = urlParts.protocol;\\n\\n// check ipv4 and ipv6 `all hostname`\\nif (hostname === '0.0.0.0' || hostname === '::') {\\n  // why do we need this check?\\n  // hostname n/a for file protocol (example, when using electron, ionic)\\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\\n  // eslint-disable-next-line no-bitwise\\n  if (self.location.hostname && !!~self.location.protocol.indexOf('http')) {\\n    hostname = self.location.hostname;\\n  }\\n}\\n\\n// `hostname` can be empty when the script path is relative. In that case, specifying\\n// a protocol would result in an invalid URL.\\n// When https is used in the app, secure websockets are always necessary\\n// because the browser doesn't accept non-secure websockets.\\nif (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {\\n  protocol = self.location.protocol;\\n}\\n\\nvar socketUrl = url.format({\\n  protocol: protocol,\\n  auth: urlParts.auth,\\n  hostname: hostname,\\n  port: urlParts.port,\\n  pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path\\n});\\n\\nsocket(socketUrl, onSocketMsg);\\n\\nvar isUnloading = false;\\nself.addEventListener('beforeunload', function () {\\n  isUnloading = true;\\n});\\n\\nfunction reloadApp() {\\n  if (isUnloading || !hotReload) {\\n    return;\\n  }\\n  if (_hot) {\\n    log.info('[WDS] App hot update...');\\n    // eslint-disable-next-line global-require\\n    var hotEmitter = __webpack_require__(/*! webpack/hot/emitter */ 1);\\n    hotEmitter.emit('webpackHotUpdate', currentHash);\\n    if (typeof self !== 'undefined' && self.window) {\\n      // broadcast update to window\\n      self.postMessage('webpackHotUpdate' + currentHash, '*');\\n    }\\n  } else {\\n    var rootWindow = self;\\n    // use parent window for reload (in case we're in an iframe with no valid src)\\n    var intervalId = self.setInterval(function () {\\n      if (rootWindow.location.protocol !== 'about:') {\\n        // reload immediately if protocol is valid\\n        applyReload(rootWindow, intervalId);\\n      } else {\\n        rootWindow = rootWindow.parent;\\n        if (rootWindow.parent === rootWindow) {\\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\\n          applyReload(rootWindow, intervalId);\\n        }\\n      }\\n    });\\n  }\\n\\n  function applyReload(rootWindow, intervalId) {\\n    clearInterval(intervalId);\\n    log.info('[WDS] App updated. Reloading...');\\n    rootWindow.location.reload();\\n  }\\n}\\n/* WEBPACK VAR INJECTION */}.call(this, \\\"?http://0.0.0.0:8090\\\"))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50P2YyYzciXSwibmFtZXMiOlsidXJsIiwicmVxdWlyZSIsInN0cmlwQW5zaSIsImxvZyIsImdldExvZ2dlciIsInNvY2tldCIsIm92ZXJsYXkiLCJnZXRDdXJyZW50U2NyaXB0U291cmNlIiwiZG9jdW1lbnQiLCJjdXJyZW50U2NyaXB0IiwiZ2V0QXR0cmlidXRlIiwic2NyaXB0RWxlbWVudHMiLCJzY3JpcHRzIiwibGVuZ3RoIiwiRXJyb3IiLCJ1cmxQYXJ0cyIsImhvdFJlbG9hZCIsIndpbmRvdyIsInFzIiwibG9jYXRpb24iLCJzZWFyY2giLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJwYXJzZSIsIl9fcmVzb3VyY2VRdWVyeSIsInN1YnN0ciIsInBvcnQiLCJzZWxmIiwiX2hvdCIsImluaXRpYWwiLCJjdXJyZW50SGFzaCIsInVzZVdhcm5pbmdPdmVybGF5IiwidXNlRXJyb3JPdmVybGF5IiwidXNlUHJvZ3Jlc3MiLCJJTkZPIiwiV0FSTklORyIsIkVSUk9SIiwiTk9ORSIsInNldERlZmF1bHRMZXZlbCIsInNlbmRNc2ciLCJ0eXBlIiwiZGF0YSIsIldvcmtlckdsb2JhbFNjb3BlIiwicG9zdE1lc3NhZ2UiLCJvblNvY2tldE1zZyIsImhvdCIsImluZm8iLCJpbnZhbGlkIiwiY2xlYXIiLCJoYXNoIiwiX2hhc2giLCJzdGlsbE9rIiwibG9nTGV2ZWwiLCJsZXZlbCIsImhvdEN0eCIsImtleXMiLCJzZXRMb2dMZXZlbCIsInNldExldmVsIiwiZGlzYWJsZUFsbCIsImVycm9yIiwidmFsdWUiLCJ3YXJuaW5ncyIsImVycm9ycyIsInByb2dyZXNzIiwiX3Byb2dyZXNzIiwicHJvZ3Jlc3NVcGRhdGUiLCJwZXJjZW50IiwibXNnIiwib2siLCJyZWxvYWRBcHAiLCJjb250ZW50Q2hhbmdlZCIsInJlbG9hZCIsIl93YXJuaW5ncyIsIndhcm4iLCJzdHJpcHBlZFdhcm5pbmdzIiwibWFwIiwid2FybmluZyIsImkiLCJzaG93TWVzc2FnZSIsIl9lcnJvcnMiLCJzdHJpcHBlZEVycm9ycyIsIl9lcnJvciIsImNsb3NlIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInNvY2tldFVybCIsImZvcm1hdCIsImF1dGgiLCJwYXRobmFtZSIsInBhdGgiLCJpc1VubG9hZGluZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJob3RFbWl0dGVyIiwiZW1pdCIsInJvb3RXaW5kb3ciLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJhcHBseVJlbG9hZCIsInBhcmVudCIsImNsZWFySW50ZXJ2YWwiXSwibWFwcGluZ3MiOiJ1REFBQTs7QUFFQTtBQUNBOztBQUVBLElBQUlBLE1BQU0sbUJBQUFDLENBQVEsYUFBUixDQUFWO0FBQ0EsSUFBSUMsWUFBWSxtQkFBQUQsQ0FBUSxvQkFBUixDQUFoQjtBQUNBLElBQUlFLE1BQU0sbUJBQUFGLENBQVEsa0JBQVIsRUFBb0JHLFNBQXBCLENBQThCLG9CQUE5QixDQUFWO0FBQ0EsSUFBSUMsU0FBUyxtQkFBQUosQ0FBUSxrQkFBUixDQUFiO0FBQ0EsSUFBSUssVUFBVSxtQkFBQUwsQ0FBUSxrQkFBUixDQUFkOztBQUVBLFNBQVNNLHNCQUFULEdBQWtDO0FBQ2hDO0FBQ0E7QUFDQSxNQUFJQyxTQUFTQyxhQUFiLEVBQTRCO0FBQzFCLFdBQU9ELFNBQVNDLGFBQVQsQ0FBdUJDLFlBQXZCLENBQW9DLEtBQXBDLENBQVA7QUFDRDtBQUNEO0FBQ0EsTUFBSUMsaUJBQWlCSCxTQUFTSSxPQUFULElBQW9CLEVBQXpDO0FBQ0EsTUFBSUgsZ0JBQWdCRSxlQUFlQSxlQUFlRSxNQUFmLEdBQXdCLENBQXZDLENBQXBCO0FBQ0EsTUFBSUosYUFBSixFQUFtQjtBQUNqQixXQUFPQSxjQUFjQyxZQUFkLENBQTJCLEtBQTNCLENBQVA7QUFDRDtBQUNEO0FBQ0EsUUFBTSxJQUFJSSxLQUFKLENBQVUsNENBQVYsQ0FBTjtBQUNEOztBQUVELElBQUlDLFdBQVcsS0FBSyxDQUFwQjtBQUNBLElBQUlDLFlB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LEdBQXFCO0FBQ25CLE1BQUlxQixlQUFlLENBQUMxRSxTQUFwQixFQUErQjtBQUM3QjtBQUNEO0FBQ0QsTUFBSVksSUFBSixFQUFVO0FBQ1J6QixRQUFJMkMsSUFBSixDQUFTLHlCQUFUO0FBQ0E7QUFDQSxRQUFJOEMsYUFBYSxtQkFBQTNGLENBQVEsNEJBQVIsQ0FBakI7QUFDQTJGLGVBQVdDLElBQVgsQ0FBZ0Isa0JBQWhCLEVBQW9DL0QsV0FBcEM7QUFDQSxRQUFJLE9BQU9ILElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLEtBQUtWLE1BQXhDLEVBQWdEO0FBQzlDO0FBQ0FVLFdBQUtnQixXQUFMLENBQWlCLHFCQUFxQmIsV0FBdEMsRUFBbUQsR0FBbkQ7QUFDRDtBQUNGLEdBVEQsTUFTTztBQUNMLFFBQUlnRSxhQUFhbkUsSUFBakI7QUFDQTtBQUNBLFFBQUlvRSxhQUFhcEUsS0FBS3FFLFdBQUwsQ0FBaUIsWUFBWTtBQUM1QyxVQUFJRixXQUFXM0UsUUFBWCxDQUFvQmlFLFFBQXBCLEtBQWlDLFFBQXJDLEVBQStDO0FBQzdDO0FBQ0FhLG9CQUFZSCxVQUFaLEVBQXdCQyxVQUF4QjtBQUNELE9BSEQsTUFHTztBQUNMRCxxQkFBYUEsV0FBV0ksTUFBeEI7QUFDQSxZQUFJSixXQUFXSSxNQUFYLEtBQXNCSixVQUExQixFQUFzQztBQUNwQztBQUNBRyxzQkFBWUgsVUFBWixFQUF3QkMsVUFBeEI7QUFDRDtBQUNGO0FBQ0YsS0FYZ0IsQ0FBakI7QUFZRDs7QUFFRCxXQUFTRSxXQUFULENBQXFCSCxVQUFyQixFQUFpQ0MsVUFBakMsRUFBNkM7QUFDM0NJLGtCQUFjSixVQUFkO0FBQ0E1RixRQUFJMkMsSUFBSixDQUFTLGlDQUFUO0FBQ0FnRCxlQUFXM0UsUUFBWCxDQUFvQm9ELE1BQXBCO0FBQ0Q7QUFDRixDIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKS5nZXRMb2dnZXIoJ3dlYnBhY2stZGV2LXNlcnZlcicpO1xudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfVxuICAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG4gIHZhciBzY3JpcHRFbGVtZW50cyA9IGRvY3VtZW50LnNjcmlwdHMgfHwgW107XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gc2NyaXB0RWxlbWVudHNbc2NyaXB0RWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfVxuICAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuICB0aHJvdyBuZXcgRXJyb3IoJ1tXRFNdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLicpO1xufVxuXG52YXIgdXJsUGFydHMgPSB2b2lkIDA7XG52YXIgaG90UmVsb2FkID0gdHJ1ZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIGhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cbmlmICh0eXBlb2YgX19yZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiBfX3Jlc291cmNlUXVlcnkpIHtcbiAgLy8gSWYgdGhpcyBidW5kbGUgaXMgaW5saW5lZCwgdXNlIHRoZSByZXNvdXJjZSBxdWVyeSB0byBnZXQgdGhlIGNvcnJlY3QgdXJsLlxuICB1cmxQYXJ0cyA9IHVybC5wYXJzZShfX3Jlc291cmNlUXVlcnkuc3Vic3RyKDEpKTtcbn0gZWxzZSB7XG4gIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gIHZhciBzY3JpcHRIb3N0ID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgc2NyaXB0SG9zdCA9IHNjcmlwdEhvc3QucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnJyk7XG4gIHVybFBhcnRzID0gdXJsLnBhcnNlKHNjcmlwdEhvc3QgfHwgJy8nLCBmYWxzZSwgdHJ1ZSk7XG59XG5cbmlmICghdXJsUGFydHMucG9ydCB8fCB1cmxQYXJ0cy5wb3J0ID09PSAnMCcpIHtcbiAgdXJsUGFydHMucG9ydCA9IHNlbGYubG9jYXRpb24ucG9ydDtcbn1cblxudmFyIF9ob3QgPSBmYWxzZTtcbnZhciBpbml0aWFsID0gdHJ1ZTtcbnZhciBjdXJyZW50SGFzaCA9ICcnO1xudmFyIHVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XG52YXIgdXNlRXJyb3JPdmVybGF5ID0gZmFsc2U7XG52YXIgdXNlUHJvZ3Jlc3MgPSBmYWxzZTtcblxudmFyIElORk8gPSAnaW5mbyc7XG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgTk9ORSA9ICdub25lJztcblxuLy8gU2V0IHRoZSBkZWZhdWx0IGxvZyBsZXZlbFxubG9nLnNldERlZmF1bHRMZXZlbChJTkZPKTtcblxuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnIHx8ICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICd3ZWJwYWNrJyArIHR5cGUsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgJyonKTtcbiAgfVxufVxuXG52YXIgb25Tb2NrZXRNc2cgPSB7XG4gIGhvdDogZnVuY3Rpb24gaG90KCkge1xuICAgIF9ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGludmFsaWQ6IGZ1bmN0aW9uIGludmFsaWQoKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWNvbXBpbGluZy4uLicpO1xuICAgIC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICBzZW5kTXNnKCdJbnZhbGlkJyk7XG4gIH0sXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBjdXJyZW50SGFzaCA9IF9oYXNoO1xuICB9LFxuXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcbiAgICBpZiAodXNlV2FybmluZ092ZXJsYXkgfHwgdXNlRXJyb3JPdmVybGF5KSBvdmVybGF5LmNsZWFyKCk7XG4gICAgc2VuZE1zZygnU3RpbGxPaycpO1xuICB9LFxuICAnbG9nLWxldmVsJzogZnVuY3Rpb24gbG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB2YXIgaG90Q3R4ID0gcmVxdWlyZS5jb250ZXh0KCd3ZWJwYWNrL2hvdCcsIGZhbHNlLCAvXlxcLlxcL2xvZyQvKTtcbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSBJTkZPOlxuICAgICAgY2FzZSBFUlJPUjpcbiAgICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdBUk5JTkc6XG4gICAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xuICAgICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5PTkU6XG4gICAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nLmVycm9yKCdbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsIFxcJycgKyBsZXZlbCArICdcXCcnKTtcbiAgICB9XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XG4gICAgICAgIHVzZUVycm9yT3ZlcmxheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICB1c2VFcnJvck92ZXJsYXkgPSB2YWx1ZS5lcnJvcnM7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHVzZVByb2dyZXNzID0gX3Byb2dyZXNzO1xuICAgIH1cbiAgfSxcblxuICAncHJvZ3Jlc3MtdXBkYXRlJzogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmICh1c2VQcm9ncmVzcykgbG9nLmluZm8oJ1tXRFNdICcgKyBkYXRhLnBlcmNlbnQgKyAnJSAtICcgKyBkYXRhLm1zZyArICcuJyk7XG4gIH0sXG4gIG9rOiBmdW5jdGlvbiBvaygpIHtcbiAgICBzZW5kTXNnKCdPaycpO1xuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICBpZiAoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gICAgcmVsb2FkQXBwKCk7XG4gIH0sXG5cbiAgJ2NvbnRlbnQtY2hhbmdlZCc6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBDb250ZW50IGJhc2UgY2hhbmdlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xuICAgIGxvZy53YXJuKCdbV0RTXSBXYXJuaW5ncyB3aGlsZSBjb21waWxpbmcuJyk7XG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuICAgIHNlbmRNc2coJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZFdhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cud2FybihzdHJpcHBlZFdhcm5pbmdzW2ldKTtcbiAgICB9XG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5KSBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG5cbiAgICBpZiAoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gICAgcmVsb2FkQXBwKCk7XG4gIH0sXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuJyk7XG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcbiAgICBzZW5kTXNnKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZEVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLmVycm9yKHN0cmlwcGVkRXJyb3JzW2ldKTtcbiAgICB9XG4gICAgaWYgKHVzZUVycm9yT3ZlcmxheSkgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICBpbml0aWFsID0gZmFsc2U7XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGxvZy5lcnJvcignW1dEU10gRGlzY29ubmVjdGVkIScpO1xuICAgIHNlbmRNc2coJ0Nsb3NlJyk7XG4gIH1cbn07XG5cbnZhciBob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lO1xudmFyIHByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2w7XG5cbi8vIGNoZWNrIGlwdjQgYW5kIGlwdjYgYGFsbCBob3N0bmFtZWBcbmlmIChob3N0bmFtZSA9PT0gJzAuMC4wLjAnIHx8IGhvc3RuYW1lID09PSAnOjonKSB7XG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIGlmIChzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICYmICEhfnNlbGYubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpKSB7XG4gICAgaG9zdG5hbWUgPSBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9XG59XG5cbi8vIGBob3N0bmFtZWAgY2FuIGJlIGVtcHR5IHdoZW4gdGhlIHNjcmlwdCBwYXRoIGlzIHJlbGF0aXZlLiBJbiB0aGF0IGNhc2UsIHNwZWNpZnlpbmdcbi8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxuLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XG4vLyBiZWNhdXNlIHRoZSBicm93c2VyIGRvZXNuJ3QgYWNjZXB0IG5vbi1zZWN1cmUgd2Vic29ja2V0cy5cbmlmIChob3N0bmFtZSAmJiAoc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgdXJsUGFydHMuaG9zdG5hbWUgPT09ICcwLjAuMC4wJykpIHtcbiAgcHJvdG9jb2wgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sO1xufVxuXG52YXIgc29ja2V0VXJsID0gdXJsLmZvcm1hdCh7XG4gIHByb3RvY29sOiBwcm90b2NvbCxcbiAgYXV0aDogdXJsUGFydHMuYXV0aCxcbiAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICBwb3J0OiB1cmxQYXJ0cy5wb3J0LFxuICBwYXRobmFtZTogdXJsUGFydHMucGF0aCA9PSBudWxsIHx8IHVybFBhcnRzLnBhdGggPT09ICcvJyA/ICcvc29ja2pzLW5vZGUnIDogdXJsUGFydHMucGF0aFxufSk7XG5cbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TXNnKTtcblxudmFyIGlzVW5sb2FkaW5nID0gZmFsc2U7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcCgpIHtcbiAgaWYgKGlzVW5sb2FkaW5nIHx8ICFob3RSZWxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9ob3QpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoJ3dlYnBhY2svaG90L2VtaXR0ZXInKTtcbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoJ3dlYnBhY2tIb3RVcGRhdGUnICsgY3VycmVudEhhc2gsICcqJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciByb290V2luZG93ID0gc2VsZjtcbiAgICAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdhYm91dDonKSB7XG4gICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcbiAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbn0iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///22\\n\")},function(Q,B,F){F(22),F(4),function(){var Q=new Error('Cannot find module \"./client/main.jsx\"');throw Q.code=\"MODULE_NOT_FOUND\",Q}()}]);","extractedComments":[]}